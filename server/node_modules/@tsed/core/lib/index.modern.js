import 'reflect-metadata';
import { join } from 'path';

function catchError(cb) {
  try {
    cb();
  } catch (er) {
    return er;
  }
}
async function catchAsyncError(cb) {
  try {
    await cb();
  } catch (er) {
    return er;
  }
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var id = 0;

function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}

function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }

  return receiver;
}

/**
 * Create a complete and iterable trap.
 * @param self
 * @param options
 * @ignore
 */
function proxyDelegation(self, options = {}) {
  const {
    handlers = {},
    remove,
    ownKeys
  } = options;

  const get = options.getter || ((target, propertyKey) => target.get(propertyKey));

  const set = options.setter || ((target, propertyKey, value) => !!target.set(propertyKey, value));

  const itsOwnProp = (target, p) => Reflect.has(target, p) || typeof p === "symbol";

  return new Proxy(self, _extends({
    getOwnPropertyDescriptor(target, p) {
      return Reflect.getOwnPropertyDescriptor(target, p);
    },

    has(target, p) {
      if (itsOwnProp(target, p)) {
        return Reflect.has(target, p);
      }

      return get(target, p) !== undefined;
    },

    get(target, p, receiver) {
      if (itsOwnProp(target, p)) {
        return Reflect.get(target, p, receiver);
      }

      return get(target, p);
    },

    set(target, p, value, receiver) {
      if (itsOwnProp(target, p)) {
        return Reflect.set(target, p, value, receiver);
      }

      return !!set(target, p, value, receiver);
    },

    deleteProperty(target, p) {
      if (itsOwnProp(target, p) || !remove) {
        return Reflect.deleteProperty(target, p);
      }

      return remove(target, p);
    },

    defineProperty(target, p, attributes) {
      return Reflect.defineProperty(target, p, attributes);
    },

    ownKeys(target) {
      return Reflect.ownKeys(target).concat(ownKeys && ownKeys(target) || []);
    }

  }, handlers));
}

function uniq(list) {
  return Array.from(new Set(list).values());
}
function uniqBy(list, key = "id") {
  const map = new Map();
  list.forEach(item => {
    map.set(item[key], item);
  });
  return Array.from(map.values());
}

/**
 * Get the provide constructor if target is an instance.
 * @param target
 * @returns {*}
 */
function getClass(target) {
  return target.prototype ? target : target.constructor;
}
/**
 * Get the provide constructor if target is an instance.
 * @param target
 * @returns {*}
 * @alias getClass
 */

function classOf(target) {
  return getClass(target);
}

function getInheritedClass(target) {
  return Object.getPrototypeOf(target);
}

/**
 * Get the provide name.
 * @param targetClass
 */
function nameOfClass(targetClass) {
  return typeof targetClass === "function" ? targetClass.name : targetClass.constructor.name;
}
/**
 * Get symbol name.
 * @param sym
 */

const nameOfSymbol = sym => sym.toString().replace("Symbol(", "").replace(")", "");
/**
 * Get object name
 */

function nameOf(obj) {
  switch (typeof obj) {
    default:
      return "" + obj;

    case "symbol":
      return nameOfSymbol(obj);

    case "function":
      return nameOfClass(obj);
  }
}

/**
 *
 * @param target
 * @returns {Array}
 */

function ancestorsOf(target) {
  const classes = [];
  let currentTarget = classOf(target);

  while (nameOf(currentTarget) !== "") {
    classes.unshift(currentTarget);
    currentTarget = getInheritedClass(currentTarget);
  }

  return classes;
}

/**
 * Return the prototype of the given class.
 * @param target
 * @returns {any}
 */

function prototypeOf(target) {
  return classOf(target) === target ? target.prototype : target;
}

/**
 * Return all methods for a given class.
 * @param target
 */

function methodsOf(target) {
  const methods = new Map();
  target = classOf(target);
  ancestorsOf(target).forEach(target => {
    const keys = Reflect.ownKeys(prototypeOf(target));
    keys.forEach(propertyKey => {
      if (propertyKey !== "constructor") {
        methods.set(propertyKey, {
          target,
          propertyKey
        });
      }
    });
  });
  return Array.from(methods.values());
}

/**
 * Return the descriptor for a given class and propertyKey
 * @param target
 * @param {string} propertyKey
 * @returns {PropertyDescriptor}
 */
function descriptorOf(target, propertyKey) {
  return Object.getOwnPropertyDescriptor(target && target.prototype || target, propertyKey);
}

function decorateMethodsOf(klass, decorator) {
  methodsOf(klass).forEach(({
    target,
    propertyKey
  }) => {
    if (target !== classOf(klass)) {
      Object.defineProperty(prototypeOf(klass), propertyKey, {
        value(...args) {
          return prototypeOf(target)[propertyKey].apply(this, args);
        }

      });
    }

    decorator(prototypeOf(klass), propertyKey, descriptorOf(klass, propertyKey));
  });
}

function decoratorArgs(target, propertyKey) {
  return [target, propertyKey, descriptorOf(target, propertyKey)];
}

var DecoratorTypes;

(function (DecoratorTypes) {
  DecoratorTypes["PARAM"] = "parameter";
  DecoratorTypes["PARAM_CTOR"] = "parameter.constructor";
  DecoratorTypes["PARAM_STC"] = "parameter.static";
  DecoratorTypes["PROP"] = "property";
  DecoratorTypes["PROP_STC"] = "property.static";
  DecoratorTypes["METHOD"] = "method";
  DecoratorTypes["METHOD_STC"] = "method.static";
  DecoratorTypes["CLASS"] = "class";
})(DecoratorTypes || (DecoratorTypes = {}));

function decoratorTypeOf(args) {
  const [target, propertyKey, descriptor] = args;

  const staticType = type => {
    return target !== classOf(target) ? type : `${type}.static`;
  };

  if (typeof descriptor === "number") {
    return propertyKey ? staticType("parameter") : "parameter.constructor";
  }

  if (descriptor && descriptor.value) {
    return staticType("method");
  }

  if (propertyKey && descriptor === undefined || descriptor) {
    return staticType("property");
  }

  return DecoratorTypes.CLASS;
}

function inheritedDescriptorOf(target, propertyKey) {
  for (const klass of ancestorsOf(target)) {
    const descriptor = Object.getOwnPropertyDescriptor(klass && klass.prototype || klass, propertyKey);

    if (descriptor) {
      return descriptor;
    }
  }

  return undefined;
}

function useDecorators(...decorators) {
  return (...args) => {
    decorators.filter(o => !!o).forEach(decorator => {
      decorator(...args);
    });
  };
}

function useMethodDecorator(decorator) {
  return (target, propertyKey) => decorator(target, propertyKey, descriptorOf(target, propertyKey));
}
function useMethodDecorators(...decorators) {
  return (target, propertyKey) => {
    decorators.filter(Boolean).forEach(decorator => decorator(target, propertyKey, descriptorOf(target, propertyKey)));
  };
}

/**
 * Prevent prototype pollution vulnerability
 * @param key
 */
function isProtectedKey(key) {
  return ["__proto__", "constructor", "prototype"].includes(key);
}

/**
 * Remove undefined value
 * @param obj
 * @param ignore
 */

function cleanObject(obj, ignore = []) {
  return Object.entries(obj).reduce((obj, [key, value]) => {
    if (isProtectedKey(key) || ignore.includes(key)) {
      return obj;
    }

    return value === undefined ? obj : _extends({}, obj, {
      [key]: value
    });
  }, {});
}

/**
 * Get the class constructor
 * @param target
 */
function getConstructor(target) {
  return typeof target === "function" ? target : target.constructor;
}
/**
 * Get the class constructor
 * @param target
 */

function constructorOf(target) {
  return getConstructor(target);
}

/**
 * Return true if value is an array
 * @param target
 * @returns {boolean}
 */
function isArray(target) {
  return Array.isArray(target);
}
/**
 * Return true if the clazz is an array.
 * @param target
 * @returns {boolean}
 * @ignore
 */

function isArrayOrArrayClass(target) {
  return target === Array || isArray(target);
}

/**
 *
 * @param target
 * @returns {boolean}
 */
function isDate(target) {
  return target === Date || target instanceof Date && !isNaN(+target);
}

function isFunction(target) {
  return typeof target === "function";
}

function isNil(value) {
  return value === undefined || value === null;
}

/**
 *
 * @param target
 * @returns {boolean}
 */
function isBoolean(target) {
  return typeof target === "boolean" || target instanceof Boolean || target === Boolean;
}
function isBooleanOrBooleanClass(target) {
  return typeof target === "boolean" || target instanceof Boolean || target === Boolean;
}

/**
 *
 * @param target
 * @returns {boolean}
 */
function isNumber(target) {
  return typeof target === "number";
}
function isNumberOrNumberClass(target) {
  return typeof target === "number" || target instanceof Number || target === Number;
}

/**
 * @param target
 * @returns {boolean}
 */
function isString(target) {
  return typeof target === "string";
}
function isStringOrStringClass(target) {
  return typeof target === "string" || target instanceof String || target === String;
}

/**
 * Return true if the given obj is a primitive.
 * @param target
 * @returns {boolean}
 * @ignore
 */

function isPrimitiveOrPrimitiveClass(target) {
  return isStringOrStringClass(target) || isNumberOrNumberClass(target) || isBooleanOrBooleanClass(target);
}
/**
 * Return true if the given obj is a primitive.
 * @param target
 * @returns {boolean}
 */

function isPrimitive(target) {
  return isString(target) || isNumber(target) || isBoolean(target);
}
function isPrimitiveClass(target) {
  return [String, Number, Boolean].includes(target);
}

/**
 *
 * @param target
 */
function isSymbol(target) {
  return typeof target === "symbol";
}
function isSymbolOrSymbolClass(target) {
  return typeof target === "symbol" || target instanceof Symbol || target === Symbol;
}

const isBasicType = source => isNil(source) || isPrimitive(source) || isSymbol(source) || isFunction(source);
/**
 * Return a cloned value
 * @param source
 */


function deepClone(source) {
  let dest;

  if (isBasicType(source)) {
    return source;
  }

  if (isDate(source)) {
    return new Date(source);
  }

  dest = isArray(source) ? [] : {};

  for (const key in source) {
    // Use getOwnPropertyDescriptor instead of source[key] to prevent from triggering setter/getter.
    const descriptor = Object.getOwnPropertyDescriptor(source, key);

    if (descriptor) {
      if (!isFunction(descriptor.value)) {
        dest[key] = deepClone(descriptor.value);
      } else {
        Object.defineProperty(dest, key, descriptor);
      }
    }
  }

  if (!isArray(source)) {
    const prototype = Reflect.getPrototypeOf(source);
    Reflect.setPrototypeOf(dest, prototype);
  }

  return dest;
}

function createInstance(obj) {
  return obj ? classOf(obj) !== Object ? Object.create(obj) : {} : {};
}

function objectKeys(obj) {
  return Object.keys(obj).filter(key => !isProtectedKey(key));
}

function reducer() {
  return (collection, value) => {
    collection.indexOf(value) === -1 && collection.push(value);
    return collection;
  };
}
/**
 * Deep extends a model with another one.
 * @param out
 * @param obj
 * @param reducers
 * @returns {any}
 * @deprecated Since 2021-07-16. Use deepMerge instead of
 */


function deepExtends(out, obj, reducers = {}) {
  if (obj === undefined || obj === null) {
    return out;
  }

  if (isPrimitive(obj) || typeof obj === "symbol" || typeof obj === "function") {
    return obj;
  }

  if (isArrayOrArrayClass(obj)) {
    out = out || [];
  } else {
    out = out || createInstance(obj);
  }

  const defaultReducer = reducers["default"] ? reducers["default"] : reducer();

  const set = (key, value) => {
    if (isArrayOrArrayClass(obj)) {
      out.indexOf(value) === -1 && out.push(value);
    } else {
      out[key] = value;
    }
  };

  objectKeys(obj).forEach(key => {
    let value = obj[key]; // istanbul ignore next

    if (value === undefined || value === null) {
      return;
    } // istanbul ignore next


    if (value === "" && out[key] !== "") {
      return;
    }

    if (isPrimitive(value) || typeof value === "function") {
      set(key, value);
      return;
    }

    if (isArrayOrArrayClass(value)) {
      value = value.map(value => deepExtends(undefined, value));
      set(key, [].concat(out[key] || [], value).reduce((collection, value) => reducers[key] ? reducers[key](collection, value) : defaultReducer(collection, value), []));
      return;
    } // Object


    if (isArrayOrArrayClass(obj)) {
      set(key, deepExtends(undefined, value, reducers));
    } else {
      set(key, deepExtends(out[key], value, reducers));
    }
  });

  if (isArrayOrArrayClass(out)) {
    out.reduce((collection, value) => defaultReducer(collection, value), []);
  }

  return out;
}

function mergeReducerBuilder(cb) {
  return (collection, value, options) => {
    const index = collection.findIndex(item => cb(item, value));

    if (index === -1) {
      return [...collection, value];
    }

    collection[index] = deepMerge(collection[index], value, options);
    return collection;
  };
}
const defaultReducer = mergeReducerBuilder((a, b) => a === b);

function getReducer({
  reducers,
  parentKey
}) {
  if (!reducers) {
    return defaultReducer;
  }

  if (parentKey && reducers[parentKey]) {
    return reducers[parentKey];
  }

  return reducers["default"] || defaultReducer;
}

function shouldReturnObj(obj, source) {
  return isPrimitive(obj) || isSymbol(obj) || isFunction(obj) || source === undefined;
}

function shouldReturnSource(obj, source) {
  return obj === undefined || obj === null || obj === "" && source !== "";
}

function deepMerge(source, obj, options = {}) {
  if (shouldReturnSource(obj, source)) {
    return source;
  }

  if (shouldReturnObj(obj, source)) {
    return obj;
  }

  if (Array.isArray(source)) {
    const reducer = getReducer(options);
    return [].concat(obj).reduce((out, value) => reducer(out, value, options), [...source]);
  }

  return [...objectKeys(source), ...objectKeys(obj)].reduce((out, key) => {
    const src = source && source[key];
    const value = deepMerge(src, obj && obj[key], _extends({}, options, {
      parentKey: key
    }));

    if (options.cleanUndefinedProps && value === undefined) {
      return out;
    }

    return _extends({}, out, {
      [key]: value
    });
  }, createInstance(source));
}

function isArrowFn(target) {
  return target && isFunction(target) && !target.prototype;
}

/**
 *
 * @param target
 * @returns {boolean}
 */

function isClassObject(target) {
  return target === Object;
}
function isPlainObject(target) {
  return isClassObject(classOf(target));
}

/**
 * Tests to see if the object is an ES2015 (ES6) Promise
 * @see {@link https://www.ecma-international.org/ecma-262/6.0/#sec-promise-objects}
 * @param target
 * @returns {boolean}
 */
function isPromise(target) {
  return target === Promise || target instanceof Promise || !!target && typeof target.subscribe !== "function" && typeof target.then === "function";
}

function isClass(target) {
  if (!target) {
    return false;
  }

  if (isArrowFn(target)) {
    return false;
  }

  return !(isSymbol(target) || isPrimitiveOrPrimitiveClass(target) || isClassObject(target) || isDate(target) || isPromise(target) || isArrayOrArrayClass(target));
}

function getClassOrSymbol(target) {
  return isClass(target) ? classOf(target) : target;
}

function toStringConstructor(target) {
  const ctr = constructorOf(target);
  const strings = ctr.toString().split("\n");
  const ctrString = strings.find(s => s.indexOf("constructor(") > -1) || "constructor()";
  return `${ctrString.replace("{", "").trim()}`;
}

function getConstructorArgNames(target) {
  return toStringConstructor(target).replace("constructor(", "").replace(")", "").split(", ").filter(Boolean);
}

/**
 *
 * @param obj
 * @param key
 */

function isEnumerable(obj, key) {
  const klass = classOf(obj);

  if (klass) {
    const descriptor = inheritedDescriptorOf(klass, key);

    if (descriptor) {
      return descriptor.enumerable;
    }
  }

  return Object.prototype.propertyIsEnumerable.call(obj, key);
}

/**
 * Return all enumerable keys of the given object
 * @param obj
 */

function getEnumerableKeys(obj) {
  const keys = [];

  for (const key in obj) {
    if (!isProtectedKey(key) && isEnumerable(obj, key)) {
      keys.push(key);
    }
  }

  return keys;
}

function isObject(target) {
  return typeof target === "object";
}

const mapOptions = args => {
  const [expression, scope, defaultValue, separator = "."] = args;

  if (isObject(scope) || isString(expression)) {
    return {
      expression,
      scope,
      defaultValue,
      separator
    };
  }

  return {
    expression: scope,
    scope: expression,
    defaultValue,
    separator
  };
};

function getValue(...args) {
  const options = mapOptions(args);
  let scope = options.scope;
  const {
    expression,
    defaultValue,
    separator
  } = options;

  if (!expression) {
    return scope;
  }

  if (!scope) {
    return defaultValue;
  }

  const keys = expression.split(separator);

  const getValue = key => {
    if (scope instanceof Map || isFunction(scope.get)) {
      return scope[key] || scope.get(key);
    }

    return scope[key];
  };

  while ((scope = getValue(keys.shift())) && keys.length) {}

  return scope === undefined ? defaultValue : scope;
}

/**
 * Return true if the target.
 * @param target
 * @returns {boolean}
 */

function isCollection(target) {
  return isArrayOrArrayClass(target) || target === Map || target instanceof Map || target === Set || target instanceof Set || target === WeakMap || target instanceof WeakMap || target === WeakSet || target instanceof WeakSet;
}

/**
 * Return true if the value is an empty string, null or undefined.
 * @param value
 * @returns {boolean}
 */

function isEmpty(value) {
  return value === "" || isNil(value);
}

function isInheritedFrom(target, from, deep = 5) {
  if (!target || !from) {
    return false;
  }

  target = classOf(target);
  from = classOf(from);

  while (nameOf(target) !== "") {
    if (!deep) {
      return false;
    }

    if (target === from) {
      return true;
    }

    target = getInheritedClass(target);
    deep--;
  }

  return false;
}

function isObservable(obj) {
  return !!obj && typeof obj.lift === "function" && typeof obj.subscribe === "function";
}

function isStream(obj) {
  return obj !== null && typeof obj === "object" && typeof obj.pipe === "function";
}

function primitiveOf(target) {
  if (isStringOrStringClass(target)) {
    return "string";
  }

  if (isNumberOrNumberClass(target)) {
    return "number";
  }

  if (isBooleanOrBooleanClass(target)) {
    return "boolean";
  }

  return "any";
}

function setValue(scope, expression, value, separator = ".") {
  const keys = expression.split(separator);

  const setValue = (key, add) => {
    if (isProtectedKey(key)) {
      return false;
    }

    if (add) {
      if (typeof scope.set === "function") {
        scope.set(key, value);
      } else {
        scope[key] = value;
      }

      return false;
    }

    if (typeof scope.set === "function") {
      if (!scope.has(key)) {
        scope.set(key, {});
      }

      scope = scope.get(key);
    } else {
      scope = scope[key] = scope[key] || {};
    }

    return true;
  };

  while (setValue(keys.shift(), !keys.length)) {}
}

function createIdentityFn(keyOrFn) {
  if (!keyOrFn) {
    return (v, k) => String(k);
  }

  if (isString(keyOrFn)) {
    return item => {
      return item[keyOrFn];
    };
  }

  return keyOrFn;
}

function toMap(input, keyOrFn) {
  if (isArray(input)) {
    const _identity = createIdentityFn(keyOrFn || "id");

    return input.reduce((map, value, index) => {
      const ids = [].concat(_identity(value, index));
      ids.forEach(id => map.set(id, value));
      return map;
    }, new Map());
  }

  const identity = createIdentityFn(keyOrFn);
  return Object.entries(input).reduce((map, [key, value]) => {
    return map.set(identity(value, key), value);
  }, new Map());
}

const fixPath = require("normalize-path");

function normalizePath(item, ...paths) {
  if (isString(item)) {
    const path = join(item, ...paths);
    return fixPath(path);
  }

  if (isArray(item)) {
    return item.map(item => normalizePath(item));
  }

  return item;
}

class Entity {
  constructor({
    target,
    propertyKey,
    descriptor,
    index
  }) {
    this._target = target;
    this.propertyKey = propertyKey;
    this.propertyName = String(propertyKey);
    this.descriptor = descriptor;
    this.index = index;
    this.decoratorType = decoratorTypeOf([target, propertyKey, descriptor || index]);
    this.token = target && classOf(target);
  }
  /**
   * Reference to the class
   */


  get target() {
    return this._target;
  }
  /**
   * Return the class name of the entity.
   * @returns {string}
   */


  get targetName() {
    return nameOf(this.token);
  }
  /**
   *
   * @returns {Type<any>}
   */


  get type() {
    return this._type;
  }
  /**
   * Get original type without transformation
   * @param value
   */


  set type(value) {
    this._type = value;
  }
  /**
   * Return the itemSchema target type. if the type is a function used for recursive model, the function will be called to
   * get the right type.
   */


  get computedType() {
    return this._type;
  }
  /**
   *
   * @returns {boolean}
   */


  get isCollection() {
    return !!this.collectionType;
  }
  /**
   *
   * @returns {boolean}
   */


  get isArray() {
    return isArrayOrArrayClass(this.collectionType);
  }
  /**
   *
   * @returns {boolean}
   */


  get isPrimitive() {
    return isPrimitiveOrPrimitiveClass(this._type);
  }
  /**
   *
   * @returns {boolean}
   */


  get isDate() {
    return isDate(this.computedType);
  }
  /**
   *
   * @returns {boolean}
   */


  get isObject() {
    return isObject(this.computedType);
  }
  /**
   *
   */


  get isClass() {
    return isClass(this.computedType);
  }

}

/**
 *
 */
var Env;

(function (Env) {
  Env["PROD"] = "production";
  Env["DEV"] = "development";
  Env["TEST"] = "test";
})(Env || (Env = {}));
/**
 * Fallback
 * @type {Env}
 */
// tslint:disable-next-line: variable-name


const EnvTypes = Env;

class Hooks {
  constructor() {
    this.listeners = new Map();
  }
  /**
   * Listen a hook event
   * @param event
   * @param cb
   */


  on(event, cb) {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }

    this.listeners.get(event).push(cb);
    return this;
  }
  /**
   * Remove a listener attached to an event
   * @param event
   * @param cb
   */


  off(event, cb) {
    if (this.listeners.has(event)) {
      this.listeners.set(event, this.listeners.get(event).filter(item => item === cb));
    }

    return this;
  }
  /**
   * Trigger an event and call listener.
   * @param event
   * @param args
   * @param callThis
   */


  emit(event, args = [], callThis = null) {
    if (this.listeners.has(event)) {
      for (const cb of this.listeners.get(event)) {
        cb.call(callThis, ...args);
      }
    }
  }
  /**
   * Trigger an event, listener alter given value and return it.
   * @param event
   * @param value
   * @param args
   * @param callThis
   */


  alter(event, value, args = [], callThis = null) {
    if (this.listeners.has(event)) {
      for (const cb of this.listeners.get(event)) {
        value = cb.call(callThis, value, ...args);
      }
    }

    return value;
  }
  /**
   * Trigger an event and call async listener.
   * @param event
   * @param args
   * @param callThis
   */


  async asyncEmit(event, args = [], callThis = null) {
    if (this.listeners.has(event)) {
      for (const cb of this.listeners.get(event)) {
        await cb.call(callThis, ...args);
      }
    }
  }
  /**
   * Trigger an event, async listener alter given value and return it.
   * @param event
   * @param value
   * @param args
   * @param callThis
   */


  async asyncAlter(event, value, args = [], callThis = null) {
    if (this.listeners.has(event)) {
      for (const cb of this.listeners.get(event)) {
        value = await cb.call(callThis, value, ...args);
      }
    }

    return value;
  }

}

/**
 * Metadata key
 * @private
 * @type {string}
 */

const DESIGN_PARAM_TYPES = "design:paramtypes";
/**
 * Metadata key
 * @private
 * @type {string}
 */

const DESIGN_TYPE = "design:type";
/**
 * Metadata key
 * @private
 * @type {string}
 */

const DESIGN_RETURN_TYPE = "design:returntype";
/**
 * Properties collections
 * @private
 * @type {string}
 */

const PROPERTIES = new Map();
/**
 * @stable
 */

class Metadata {
  /**
   * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
   * @param key A key used to store and retrieve metadata.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // constructor
   * result = Metadata.get("custom:annotation", Example);
   *
   * // property (on constructor)
   * result = Metadata.get("custom:annotation", Example, "staticProperty");
   *
   * // property (on prototype)
   * result = Metadata.get("custom:annotation", Example.prototype, "property");
   *
   * // method (on constructor)
   * result = Metadata.get("custom:annotation", Example, "staticMethod");
   *
   * // method (on prototype)
   * result = Metadata.get("custom:annotation", Example.prototype, "method");
   * ```
   *
   */
  static get(key, target, propertyKey) {
    return Reflect.getMetadata(key, classOf(target), propertyKey);
  }
  /**
   * Gets the metadata value for the provided metadata key on the target object or its prototype chain.
   * @param key A key used to store and retrieve metadata.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // constructor
   * result = Metadata.getOwn("custom:annotation", Example);
   *
   * // property (on constructor)
   * result = Metadata.getOwn("custom:annotation", Example, "staticProperty");
   *
   * // property (on prototype)
   * result = Metadata.getOwn("custom:annotation", Example.prototype, "property");
   *
   * // method (on constructor)
   * result = Metadata.getOwn("custom:annotation", Example, "staticMethod");
   *
   * // method (on prototype)
   * result = Metadata.getOwn("custom:annotation", Example.prototype, "method");
   * ```
   *
   */


  static getOwn(key, target, propertyKey) {
    return Reflect.getOwnMetadata(key, classOf(target), propertyKey);
  }
  /**
   * Gets the metadata value for the provided metadata DESIGN_TYPE on the target object or its prototype chain.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.getType(Example);
   *
   * // property (on constructor)
   * result = Metadata.getType(Example, "staticProperty");
   *
   * // method (on constructor)
   * result = Metadata.getType(Example, "staticMethod");
   * ```
   *
   */


  static getType(target, propertyKey) {
    return Reflect.getMetadata(DESIGN_TYPE, target, propertyKey);
  }
  /**
   * Gets the metadata value for the provided metadata DESIGN_TYPE on the target object or its prototype chain.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.getOwnType(Example);
   *
   * // property (on constructor)
   * result = Metadata.getOwnType(Example, "staticProperty");
   *
   * // method (on constructor)
   * result = Metadata.getOwnType(Example, "staticMethod");
   * ```
   *
   */


  static getOwnType(target, propertyKey) {
    return Reflect.getMetadata(DESIGN_TYPE, target, propertyKey);
  }
  /**
   * Gets the metadata value for the provided metadata DESIGN_RETURN_TYPE on the target object or its prototype chain.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.getReturnType(Example);
   *
   * // property (on constructor)
   * result = Metadata.getReturnType(Example, "staticProperty");
   *
   * // method (on constructor)
   * result = Metadata.getReturnType(Example, "staticMethod");
   * ```
   *
   */


  static getReturnType(target, propertyKey) {
    return Reflect.getMetadata(DESIGN_RETURN_TYPE, target, propertyKey);
  }
  /**
   * Gets the metadata value for the provided metadata DESIGN_RETURN_TYPE on the target object or its prototype chain.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.getOwnReturnType(Example);
   *
   * // property (on constructor)
   * result = Metadata.getOwnReturnType(Example, "staticProperty");
   *
   * // method (on constructor)
   * result = Metadata.getOwnReturnType(Example, "staticMethod");
   * ```
   *
   */


  static getOwnReturnType(target, propertyKey) {
    return Reflect.getOwnMetadata(DESIGN_RETURN_TYPE, target, propertyKey);
  }
  /**
   * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
   * @param key A key used to store and retrieve metadata.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // constructor
   * result = Metadata.has("custom:annotation", Example);
   *
   * // property (on constructor)
   * result = Metadata.has("custom:annotation", Example, "staticProperty");
   *
   * // property (on prototype)
   * result = Metadata.has("custom:annotation", Example.prototype, "property");
   *
   * // method (on constructor)
   * result = Metadata.has("custom:annotation", Example, "staticMethod");
   *
   * // method (on prototype)
   * result = Metadata.has("custom:annotation", Example.prototype, "method");
   * ```
   *
   */


  static has(key, target, propertyKey) {
    try {
      return Reflect.hasMetadata(key, classOf(target), propertyKey);
    } catch (er) {}

    return false;
  }
  /**
   * Gets a value indicating whether the target object or its prototype chain has the provided metadata key defined.
   * @param key A key used to store and retrieve metadata.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns `true` if the metadata key was defined on the target object or its prototype chain; otherwise, `false`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // constructor
   * result = Metadata.has("custom:annotation", Example);
   *
   * // property (on constructor)
   * result = Metadata.hasOwn("custom:annotation", Example, "staticProperty");
   *
   * // property (on prototype)
   * result = Metadata.hasOwn("custom:annotation", Example.prototype, "property");
   *
   * // method (on constructor)
   * result = Metadata.hasOwn("custom:annotation", Example, "staticMethod");
   *
   * // method (on prototype)
   * result = Metadata.hasOwn("custom:annotation", Example.prototype, "method");
   * ```
   *
   */


  static hasOwn(key, target, propertyKey) {
    return Reflect.hasOwnMetadata(key, classOf(target), propertyKey);
  }
  /**
   * Deletes the metadata entry from the target object with the provided key.
   * @param key A key used to store and retrieve metadata.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns `true` if the metadata entry was found and deleted; otherwise, false.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // constructor
   * result = Metadata.delete("custom:annotation", Example);
   *
   * // property (on constructor)
   * result = Metadata.delete("custom:annotation", Example, "staticProperty");
   *
   * // property (on prototype)
   * result = Metadata.delete("custom:annotation", Example.prototype, "property");
   *
   * // method (on constructor)
   * result = Metadata.delete("custom:annotation", Example, "staticMethod");
   *
   * // method (on prototype)
   * result = Metadata.delete("custom:annotation", Example.prototype, "method");
   * ```
   *
   */


  static delete(key, target, propertyKey) {
    return Reflect.deleteMetadata(key, classOf(target), propertyKey);
  }
  /**
   * Set the metadata value for the provided metadata DESIGN_PARAM_TYPES on the target object or its prototype chain.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @param value A value that contains attached metadata.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.setParamTypes(Example, undefined, [Object]);
   *
   * // property (on constructor)
   * result = Metadata.setParamTypes(Example, "staticProperty", [Object]);
   *
   * // property (on prototype)
   * result = Metadata.setParamTypes(Example.prototype, "property", [Object]);
   *
   * // method (on constructor)
   * result = Metadata.setParamTypes(Example, "staticMethod", [Object]);
   *
   * // method (on prototype)
   * result = Metadata.setParamTypes(Example.prototype, "method", [Object]);
   * ```
   *
   */


  static setParamTypes(target, propertyKey, value) {
    return this.set(DESIGN_PARAM_TYPES, value, target.prototype, propertyKey);
  }
  /**
   * Define a unique metadata entry on the target.
   * @param key A key used to store and retrieve metadata.
   * @param value A value that contains attached metadata.
   * @param target The target object on which to define metadata.
   * @param propertyKey The property key for the target.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // constructor
   * Reflect.defineMetadata("custom:annotation", options, Example);
   *
   * // property (on constructor)
   * Reflect.defineMetadata("custom:annotation", Number, Example, "staticProperty");
   *
   * // property (on prototype)
   * Reflect.defineMetadata("custom:annotation", Number, Example.prototype, "property");
   *
   * // method (on constructor)
   * Reflect.defineMetadata("custom:annotation", Number, Example, "staticMethod");
   *
   * // method (on prototype)
   * Reflect.defineMetadata("custom:annotation", Number, Example.prototype, "method");
   *
   * // decorator factory as metadata-producing annotation.
   * function MyAnnotation(options): PropertyDecorator {
   *     return (target, key) => Reflect.defineMetadata("custom:annotation", options, target, key);
   * }
   * ```
   *
   */


  static set(key, value, target, propertyKey) {
    const targets = PROPERTIES.has(key) ? PROPERTIES.get(key) || [] : [];
    const classConstructor = classOf(target);

    if (targets.indexOf(classConstructor) === -1) {
      targets.push(classConstructor);
      PROPERTIES.set(key, targets);
    }

    Reflect.defineMetadata(key, value, classOf(target), propertyKey);
  }
  /**
   * Gets the metadata value for the provided metadata DESIGN_PARAM_TYPES on the target object or its prototype chain.
   * @param targetPrototype
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.getParamTypes(Example.prototype);
   *
   * // property (on constructor)
   * result = Metadata.getParamTypes(Example.prototype, "staticProperty");
   *
   * // method (on constructor)
   * result = Metadata.getParamTypes(Example.prototype, "staticMethod");
   * ```
   *
   */


  static getParamTypes(targetPrototype, propertyKey) {
    return Reflect.getMetadata(DESIGN_PARAM_TYPES, targetPrototype, propertyKey) || [];
  }
  /**
   * Gets the metadata value for the provided metadata DESIGN_PARAM_TYPES on the target object or its prototype chain.
   * @param target The target object on which the metadata is defined.
   * @param propertyKey The property key for the target.
   * @returns The metadata value for the metadata key if found; otherwise, `undefined`.
   * @example
   *
   * ```typescript
   * class Example {
   *     // property declarations are not part of ES6, though they are valid in TypeScript:
   *     // static staticProperty;
   *     // property;
   *
   *     static staticMethod(p) { }
   *     method(p) { }
   * }
   *
   * // on contructor
   * result = Metadata.getParamTypes(Example);
   *
   * // property (on constructor)
   * result = Metadata.getParamTypes(Example, "staticProperty");
   *
   * // method (on constructor)
   * result = Metadata.getParamTypes(Example, "staticMethod");
   * ```
   *
   */


  static getOwnParamTypes(target, propertyKey) {
    return Reflect.getOwnMetadata(DESIGN_PARAM_TYPES, target, propertyKey) || [];
  }

}
/**
 * Get all metadata for a metadataKey.
 * @param metadataKey
 */

Metadata.getTargetsFromPropertyKey = metadataKey => PROPERTIES.has(metadataKey) ? PROPERTIES.get(metadataKey) || [] : [];

/**
 * @ignore
 */

const CLASS_STORE = "tsed:class:store";
/**
 * @ignore
 */

const METHOD_STORE = "tsed:method:store";
/**
 * @ignore
 */

const PROPERTY_STORE = "tsed:property:store";
/**
 * @ignore
 */

const PARAM_STORE = "tsed:param:store";
const stores = new Map();

function storeGet(key, ...args) {
  if (isSymbol(args[0])) {
    if (!stores.has(args[0])) {
      stores.set(args[0], new Store());
    }

    return stores.get(args[0]);
  } else {
    const registry = Metadata;

    if (!registry.hasOwn(key, ...args)) {
      registry.set(key, new Store(), ...args);
    }

    return registry.getOwn(key, ...args);
  }
}

function defineStore(args) {
  const [target, propertyKey, descriptor] = args;

  switch (decoratorTypeOf(args)) {
    case DecoratorTypes.PARAM_CTOR:
    case DecoratorTypes.PARAM_STC:
    case DecoratorTypes.PARAM:
      const store = storeGet(PARAM_STORE, target, propertyKey);

      if (!store.has("" + descriptor)) {
        store.set("" + descriptor, new Store());
      }

      return store.get("" + descriptor);

    case DecoratorTypes.PROP:
    case DecoratorTypes.PROP_STC:
      return storeGet(PROPERTY_STORE, target, propertyKey);

    case DecoratorTypes.METHOD:
    case DecoratorTypes.METHOD_STC:
      return storeGet(METHOD_STORE, target, propertyKey);

    case DecoratorTypes.CLASS:
      return storeGet(CLASS_STORE, target);
  }
}

var _entries = /*#__PURE__*/_classPrivateFieldLooseKey("entries");

class Store {
  constructor() {
    Object.defineProperty(this, _entries, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _entries)[_entries] = new Map();
  }

  /**
   * Create or get a Store from args {target + methodName + descriptor}
   * @param args
   * @returns {Store}
   */
  static from(...args) {
    return defineStore(args);
  }
  /**
   * Create store on the method.
   * @param target
   * @param {string} propertyKey
   * @returns {Store}
   */


  static fromMethod(target, propertyKey) {
    return Store.from(target, propertyKey, descriptorOf(target, propertyKey));
  }
  /**
   * The get() method returns a specified element from a Map object.
   * @param key Required. The key of the element to return from the Map object.
   * @param defaultValue
   * @returns {T} Returns the element associated with the specified key or undefined if the key can't be found in the Map object.
   */


  get(key, defaultValue) {
    return _classPrivateFieldLooseBase(this, _entries)[_entries].get(nameOf(key)) || defaultValue;
  }
  /**
   * The has() method returns a boolean indicating whether an element with the specified key exists or not.
   * @param key
   * @returns {boolean}
   */


  has(key) {
    return _classPrivateFieldLooseBase(this, _entries)[_entries].has(nameOf(key));
  }
  /**
   * The set() method adds or updates an element with a specified key and value to a Map object.
   * @param key Required. The key of the element to add to the Map object.
   * @param metadata Required. The value of the element to add to the Map object.
   */


  set(key, metadata) {
    _classPrivateFieldLooseBase(this, _entries)[_entries].set(nameOf(key), metadata);

    return this;
  }
  /**
   * The delete() method removes the specified element from a Map object.
   * @param key Required. The key of the element to remove from the Map object.
   * @returns {boolean} Returns true if an element in the Map object existed and has been removed, or false if the element does not exist.
   */


  delete(key) {
    return _classPrivateFieldLooseBase(this, _entries)[_entries].delete(nameOf(key));
  }
  /**
   * Merge given value with existing value.
   * @param key
   * @param value
   * @param inverse Change the merge order. Get the existing value and apply over given value
   * @returns {Store}
   */


  merge(key, value, inverse = false) {
    let _value_ = this.get(key);

    if (_value_) {
      value = deepClone(value);
      _value_ = deepClone(_value_);
      value = inverse ? deepMerge(value, _value_) : deepMerge(_value_, value);
    }

    this.set(key, value);
    return this;
  }

}

const Type = Function; // @ts-ignore

global.Type = Type;

class UnsupportedDecoratorType extends Error {
  constructor(decorator, args) {
    super(UnsupportedDecoratorType.buildMessage(decorator, args));
  }

  static buildMessage(decorator, args) {
    const [target, propertyKey, index] = args;
    const bindingType = decoratorTypeOf(args);
    const shortBinding = bindingType.split("/")[0];
    const param = shortBinding === "parameter" ? ".[" + index + "]" : "";
    const cstr = shortBinding === "parameter" ? ".constructor" : "";
    const method = propertyKey ? "." + propertyKey : cstr;
    const path = nameOf(classOf(target)) + method + param;
    return `${decorator.name} cannot be used as ${bindingType} decorator on ${path}`;
  }

}

/**
 * The `@Deprecated()` decorators wraps the given method in such a way that it is marked as deprecated.
 *
 * ```typescript
 * provide Foo {
 *
 * @Deprecated("Foo.method: Use Foo.method2 instead")
 * public method() {
 *
 * }
 * ```
 *
 * When called, @Deprecated() will return a function that will emit a `DeprecationWarning` using the `process.on('warning')` event.
 * By default, this warning will be emitted and printed to `stderr` exactly once, the first time it is called. After the warning is emitted, the wrapped method is called.
 *
 * If either the `--no-deprecation` or `--no-warnings` command line flags are used, or if the `process.noDeprecation`
 * property is set to `true` prior to the first deprecation warning, the `@Deprecated()` decorators does nothing.
 *
 * If the `--trace-deprecation` or `--trace-warnings` command line flags are set, or the `process.traceDeprecation`
 * property is set to `true`, a warning and a stack trace are printed to stderr the first time the deprecated function is called.
 *
 * If the `--throw-deprecation` command line flag is set, or the `process.throwDeprecation` property is set to `true`,
 * then an exception will be thrown when the deprecated function is called.
 *
 * The `--throw-deprecation` command line flag and `process.throwDeprecation` property take precedence over `--trace-deprecation`
 * and `process.traceDeprecation`.
 *
 * @param message
 * @returns {Function}
 * @decorator
 */
function Deprecated(message) {
  return (target, targetKey, descriptor) => {
    const originalMethod = descriptor.value;
    descriptor.value = require("util").deprecate(originalMethod, message);
    return descriptor;
  };
}

/**
 * @module common/core
 */
/** */

function Configurable(value = true) {
  return (target, propertyKey) => {
    const descriptor = descriptorOf(target, propertyKey) || {
      writable: true,
      enumerable: true
    };
    descriptor.configurable = value;
    Object.defineProperty(target && target.prototype || target, propertyKey, descriptor);
    return descriptor;
  };
}

/**
 * @module common/core
 */
/** */

function Enumerable(value = true) {
  return (target, propertyKey) => {
    const descriptor = descriptorOf(target, propertyKey) || {
      writable: true,
      configurable: true
    };
    descriptor.enumerable = value;
    Object.defineProperty(target && target.prototype || target, propertyKey, descriptor);
    return descriptor;
  };
}

/**
 * @module common/core
 */
/** */

function Writable(value = true) {
  return (target, propertyKey) => {
    const descriptor = descriptorOf(target, propertyKey) || {
      configurable: true,
      enumerable: true
    };
    descriptor.writable = value;
    Object.defineProperty(target && target.prototype || target, propertyKey, descriptor);
    return descriptor;
  };
}

/**
 * @module common/core
 */
/** */

function Readonly() {
  return Writable(false);
}

/**
 * @module common/core
 */
/** */

function NotConfigurable() {
  return Configurable(false);
}

/**
 * @module common/core
 */
/** */

function NotEnumerable() {
  return Enumerable(false);
}

/**
 * Create a store correctly configured from the parameters given by the decorator.
 * The `fn` can return a decorator that will be initialized with the parameters (target, propertyKey, descriptor).
 * @param {(store: Store, parameters: DecoratorParameters) => void} fn
 * @returns {Function}
 */

function StoreFn(fn) {
  return (...parameters) => {
    const store = Store.from(...parameters);
    const result = fn(store, parameters);

    if (typeof result === "function") {
      result(...parameters);
    }

    return parameters[2];
  };
}

function StoreSet(key, value) {
  return StoreFn(store => {
    store.set(key, value);
  });
}

function StoreMerge(key, value) {
  return StoreFn(store => {
    store.merge(key, value);
  });
}

export { CLASS_STORE, Configurable, DecoratorTypes, Deprecated, Entity, Enumerable, Env, EnvTypes, Hooks, METHOD_STORE, Metadata, NotConfigurable, NotEnumerable, PARAM_STORE, PROPERTY_STORE, Readonly, Store, StoreFn, StoreMerge, StoreSet, Type, UnsupportedDecoratorType, Writable, ancestorsOf, catchAsyncError, catchError, classOf, cleanObject, constructorOf, decorateMethodsOf, decoratorArgs, decoratorTypeOf, deepClone, deepExtends, deepMerge, descriptorOf, getClass, getClassOrSymbol, getConstructor, getConstructorArgNames, getEnumerableKeys, getInheritedClass, getValue, inheritedDescriptorOf, isArray, isArrayOrArrayClass, isArrowFn, isBoolean, isBooleanOrBooleanClass, isClass, isClassObject, isCollection, isDate, isEmpty, isEnumerable, isFunction, isInheritedFrom, isNil, isNumber, isNumberOrNumberClass, isObject, isObservable, isPlainObject, isPrimitive, isPrimitiveClass, isPrimitiveOrPrimitiveClass, isPromise, isProtectedKey, isStream, isString, isStringOrStringClass, isSymbol, isSymbolOrSymbolClass, mergeReducerBuilder, methodsOf, nameOf, nameOfClass, nameOfSymbol, normalizePath, objectKeys, primitiveOf, prototypeOf, proxyDelegation, setValue, toMap, toStringConstructor, uniq, uniqBy, useDecorators, useMethodDecorator, useMethodDecorators };
//# sourceMappingURL=index.modern.js.map
