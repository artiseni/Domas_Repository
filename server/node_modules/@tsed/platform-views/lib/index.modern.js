import { JsonEntityFn } from '@tsed/schema';
import { __decorate, __metadata } from 'tslib';
import { getValue, Env, nameOf } from '@tsed/core';
import { Constant, Injectable } from '@tsed/di';
import Fs from 'fs';
import { extname, resolve, join } from 'path';
import { InternalServerError } from '@tsed/exceptions';

/**
 * Use a view and sends the rendered HTML string to the client. Optional parameter:
 *
 * * viewOptions, an object whose properties define local variables for the view.
 *
 * The view argument is a string that is the file path of the view file to render.
 * This can be an absolute path, or a path relative to the views setting.
 * If the path does not contain a file extension, then the view engine setting determines the file extension.
 * If the path does contain a file extension, then Express will load the module for the specified template engine (via require())
 * and render it using the loaded moduleâ€™s __express function.
 *
 * For more information, see [Using template engines with Express](http://expressjs.com/guide/using-template-engines.html).
 *
 * > NOTE: The view argument performs file system operations like reading a file from disk and evaluating Node.js modules,
 * and as so for security reasons should not contain input from the end-user.
 *
 * @param path Relative path to the view file.
 * @param options Additional options
 * @decorator
 * @operation
 * @response
 */

function View(path, options) {
  return JsonEntityFn(entity => {
    entity.view = {
      path,
      options
    };
  });
}

const PLATFORM_VIEWS_EXTENSIONS = {
  atpl: "atpl",
  bracket: "bracket",
  dot: "dot",
  dust: "dust",
  ect: "ect",
  ejs: "ejs",
  haml: "haml",
  "haml-coffee": "haml-coffee",
  hamlet: "hamlet",
  hbs: "handlebars",
  handlebars: "handlebars",
  hogan: "hogan",
  htmling: "htmling",
  jazz: "jazz",
  jqtpl: "jqtpl",
  just: "just",
  kernel: "kernel",
  liquid: "liquid",
  liquor: "liquor",
  lodash: "lodash",
  mote: "mote",
  mustache: "mustache",
  nunjucks: "nunjucks",
  plates: "plates",
  pug: "pug",
  qejs: "qejs",
  ractive: "ractive",
  razor: "razor",
  jsx: "react",
  slm: "slm",
  squirelly: "squirelly",
  swig: "swig",
  teacup: "teacup",
  templayed: "templayed",
  toffee: "toffee",
  twig: "twig",
  underscore: "underscore",
  vash: "vash",
  velocityjs: "velocityjs",
  walrus: "walrus",
  whiskers: "whiskers"
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var id = 0;

function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}

function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }

  return receiver;
}

var _extensions, _engines, _cachePaths;

const _excluded = ["client"];

function patchEJS(ejs) {
  return {
    compile(str, _ref) {
      let options = _objectWithoutPropertiesLoose(_ref, _excluded);

      return (ejs || require("ejs")).compile(str, options);
    }

  };
}

async function tryImport(name) {
  try {
    return await import(name);
  } catch (er) {// istanbul ignore next
  }
}
/**
 * @platform
 */


let PlatformViews = (_extensions = /*#__PURE__*/_classPrivateFieldLooseKey("extensions"), _engines = /*#__PURE__*/_classPrivateFieldLooseKey("engines"), _cachePaths = /*#__PURE__*/_classPrivateFieldLooseKey("cachePaths"), class PlatformViews {
  constructor() {
    Object.defineProperty(this, _extensions, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _engines, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _cachePaths, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _engines)[_engines] = new Map();
    _classPrivateFieldLooseBase(this, _cachePaths)[_cachePaths] = new Map();
  }

  async $onInit() {
    _classPrivateFieldLooseBase(this, _extensions)[_extensions] = new Map(Object.entries(_extends({}, PLATFORM_VIEWS_EXTENSIONS, this.extensionsOptions)));
    await this.loadFromConsolidate();
    await this.loadFromTsedEngines();
  }
  /**
   * @deprecated
   */


  async loadFromConsolidate() {
    const cons = await tryImport("consolidate");

    if (cons) {
      cons.requires.ejs = patchEJS(cons.requires.ejs);

      _classPrivateFieldLooseBase(this, _extensions)[_extensions].forEach(engineType => {
        if (cons[engineType]) {
          const options = this.getEngineOptions(engineType);

          if (options.requires) {
            cons.requires[engineType] = options.requires;
          }

          this.registerEngine(engineType, {
            options,
            render: cons[engineType]
          });
        }
      });
    }
  }

  async loadFromTsedEngines() {
    const tsed = await tryImport("@tsed/engines");

    if (tsed) {
      tsed.requires.set("ejs", patchEJS(tsed.requires.get("ejs")));

      _classPrivateFieldLooseBase(this, _extensions)[_extensions].forEach(engineType => {
        if (tsed.engines.has(engineType)) {
          const options = this.getEngineOptions(engineType);

          if (options.requires) {
            tsed.requires.set(engineType, options.requires);
          }

          this.registerEngine(engineType, {
            options,
            render: tsed.getEngine(engineType)
          });
        }
      });
    }
  }

  getEngines() {
    return [..._classPrivateFieldLooseBase(this, _extensions)[_extensions].entries()].map(([extension, engineType]) => {
      const engine = this.getEngine(this.getExtension(engineType));
      return {
        extension,
        engine
      };
    });
  }

  registerEngine(engineType, engine) {
    _classPrivateFieldLooseBase(this, _engines)[_engines].set(engineType, engine);

    return this;
  }

  getEngine(type) {
    return _classPrivateFieldLooseBase(this, _engines)[_engines].get(_classPrivateFieldLooseBase(this, _extensions)[_extensions].get(type) || type);
  }

  getEngineOptions(engineType) {
    return getValue(this.engineOptions, engineType, {});
  }

  async render(viewPath, options = {}) {
    const {
      path,
      extension
    } = _classPrivateFieldLooseBase(this, _cachePaths)[_cachePaths].get(viewPath) || _classPrivateFieldLooseBase(this, _cachePaths)[_cachePaths].set(viewPath, this.resolve(viewPath)).get(viewPath);

    const engine = this.getEngine(extension);

    if (!engine) {
      throw new Error(`Engine not found to render the following "${viewPath}"`);
    }

    return engine.render(path, Object.assign({
      cache: this.cache || this.env === Env.PROD
    }, engine.options, options));
  }

  getExtension(viewPath) {
    return (extname(viewPath) || this.viewEngine).replace(/\./, "");
  }

  resolve(viewPath) {
    const extension = this.getExtension(viewPath);
    viewPath = viewPath.replace(extname(viewPath), "") + "." + extension;
    const path = [viewPath, resolve(join(this.root, viewPath)), resolve(join(process.cwd(), "views", viewPath)), resolve(join(process.cwd(), "public", viewPath))].find(file => Fs.existsSync(file)) || viewPath;
    return {
      path,
      extension
    };
  }

});

__decorate([Constant("env"), __metadata("design:type", String)], PlatformViews.prototype, "env", void 0);

__decorate([Constant("views.root", `${process.cwd()}/views`), __metadata("design:type", String)], PlatformViews.prototype, "root", void 0);

__decorate([Constant("views.cache"), __metadata("design:type", Boolean)], PlatformViews.prototype, "cache", void 0);

__decorate([Constant("views.viewEngine", "ejs"), __metadata("design:type", String)], PlatformViews.prototype, "viewEngine", void 0);

__decorate([Constant("views.extensions", {}), __metadata("design:type", Object)], PlatformViews.prototype, "extensionsOptions", void 0);

__decorate([Constant("views.options", {}), __metadata("design:type", Object)], PlatformViews.prototype, "engineOptions", void 0);

PlatformViews = __decorate([Injectable()], PlatformViews);

/**
 * @private
 */

class TemplateRenderError extends InternalServerError {
  constructor(target, method, err) {
    super(TemplateRenderError.buildMessage(target, method, err));
    this.name = "TEMPLATE_RENDER_ERROR";
  }
  /**
   *
   * @returns {string}
   */


  static buildMessage(target, method, err) {
    return `Template rendering error: ${nameOf(target)}.${String(method)}()\n` + err;
  }

}

/**
 * @ignore
 */

async function renderView(data, $ctx) {
  const {
    response,
    endpoint
  } = $ctx;

  try {
    const {
      data: _data
    } = $ctx;
    const {
      path,
      options
    } = endpoint.view;
    return await response.render(path, _extends({}, options, _data, {
      $ctx
    }));
  } catch (err) {
    throw new TemplateRenderError(endpoint.targetName, endpoint.propertyKey, err);
  }
}

export { PLATFORM_VIEWS_EXTENSIONS, PlatformViews, TemplateRenderError, View, renderView };
//# sourceMappingURL=index.modern.js.map
