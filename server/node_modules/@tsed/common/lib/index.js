var di = require('@tsed/di');
var platformParams = require('@tsed/platform-params');
var platformExceptions = require('@tsed/platform-exceptions');
var platformResponseFilter = require('@tsed/platform-response-filter');
var platformCache = require('@tsed/platform-cache');
var platformMiddlewares = require('@tsed/platform-middlewares');
var platformViews = require('@tsed/platform-views');
var logger = require('@tsed/logger');
var tslib = require('tslib');
var core = require('@tsed/core');
var perf = require('@tsed/perf');
var exceptions = require('@tsed/exceptions');
var schema = require('@tsed/schema');
var jsonMapper = require('@tsed/json-mapper');
var util = require('util');
var Http = require('http');
var Https = require('https');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Http__default = /*#__PURE__*/_interopDefaultLegacy(Http);
var Https__default = /*#__PURE__*/_interopDefaultLegacy(Https);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var id = 0;

function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}

function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }

  return receiver;
}

var PlatformConfiguration_1;
const rootDir = process.cwd();
/**
 * `PlatformConfiguration` contains all information about your Server configuration.
 */

exports.PlatformConfiguration = PlatformConfiguration_1 = class PlatformConfiguration extends di.DIConfiguration {
  constructor() {
    super({
      rootDir,
      env: process.env.NODE_ENV || core.Env.DEV,
      httpPort: 8080,
      httpsPort: false,
      scopes: {
        [di.ProviderType.CONTROLLER]: di.ProviderScope.SINGLETON
      },
      logger: {
        debug: false,
        level: "info",
        logRequest: true,
        jsonIndentation: process.env.NODE_ENV === core.Env.PROD ? 0 : 2
      },
      errors: {
        headerName: "errors"
      },
      mount: {
        "/rest": "${rootDir}/controllers/**/*.ts"
      },
      exclude: ["**/*.spec.ts", "**/*.spec.js"],
      componentsScan: ["${rootDir}/mvc/**/*.ts", "${rootDir}/services/**/*.ts", "${rootDir}/middlewares/**/*.ts"]
    });
  }

  get version() {
    return this.getRaw("version");
  }

  set version(v) {
    this.setRaw("version", v);
  }

  get rootDir() {
    return this.getRaw("rootDir");
  }

  set rootDir(value) {
    this.setRaw("rootDir", value);
  }

  get port() {
    return this.httpPort;
  }

  set port(value) {
    this.httpPort = value;
  }

  get httpsOptions() {
    return this.getRaw("httpsOptions");
  }

  set httpsOptions(value) {
    this.setRaw("httpsOptions", value);
  }

  get httpPort() {
    return this.getRaw("httpPort");
  }

  set httpPort(value) {
    this.setRaw("httpPort", value);
  }

  get httpsPort() {
    return this.getRaw("httpsPort");
  }

  set httpsPort(value) {
    this.setRaw("httpsPort", value);
  }

  get env() {
    return this.getRaw("env");
  }

  set env(value) {
    this.setRaw("env", value);
  }

  get mount() {
    return this.get("mount");
  }

  set mount(value) {
    this.setRaw("mount", value);
  }

  get componentsScan() {
    return this.resolve(this.getRaw("componentsScan"));
  }

  set componentsScan(value) {
    this.setRaw("componentsScan", value);
  }

  get statics() {
    return this.getRaw("statics") || this.getRaw("serveStatic") || {};
  }

  set statics(value) {
    this.setRaw("statics", value);
  }

  get acceptMimes() {
    return this.getRaw("acceptMimes");
  }

  set acceptMimes(value) {
    this.setRaw("acceptMimes", value || []);
  }

  get debug() {
    return this.logger.level === "debug";
  }

  set debug(debug) {
    this.logger = _extends({}, this.logger, {
      level: debug ? "debug" : "info"
    });
  }

  get converter() {
    return this.get("converter") || {};
  }

  set converter(options) {
    this.setRaw("converter", options);
  }

  get logger() {
    return this.get("logger");
  }

  set logger(value) {
    const logger$1 = _extends({}, this.logger, value);

    logger$1.debug = logger$1.level === "debug";
    this.setRaw("logger", logger$1);
    this.setRaw("debug", logger$1.debug);

    if (logger$1.format) {
      logger.$log.appenders.set("stdout", {
        type: "stdout",
        levels: ["info", "debug"],
        layout: {
          type: "pattern",
          pattern: logger$1.format
        }
      });
      logger.$log.appenders.set("stderr", {
        levels: ["trace", "fatal", "error", "warn"],
        type: "stderr",
        layout: {
          type: "pattern",
          pattern: logger$1.format
        }
      });
    }
  }

  get exclude() {
    return this.get("exclude");
  }

  set exclude(exclude) {
    this.setRaw("exclude", exclude);
  }
  /**
   *
   * @param addressPort
   * @returns {{address: string, port: number}}
   */


  static buildAddressAndPort(addressPort) {
    let address = "0.0.0.0";
    let port = addressPort;

    if (typeof addressPort === "string" && addressPort.indexOf(":") > -1) {
      [address, port] = addressPort.split(":");
      port = +port;
    }

    return {
      address,
      port: port
    };
  }
  /**
   *
   * @returns {string|number}
   */


  getHttpPort() {
    return PlatformConfiguration_1.buildAddressAndPort(this.getRaw("httpPort"));
  }
  /**
   *
   * @param settings
   */


  setHttpPort(settings) {
    this.setRaw("httpPort", `${settings.address}:${settings.port}`);
  }
  /**
   *
   * @returns {string|number}
   */


  getHttpsPort() {
    return PlatformConfiguration_1.buildAddressAndPort(this.getRaw("httpsPort"));
  }
  /**
   *
   * @param settings
   */


  setHttpsPort(settings) {
    this.setRaw("httpsPort", `${settings.address}:${settings.port}`);
  }

};
exports.PlatformConfiguration = PlatformConfiguration_1 = tslib.__decorate([di.Injectable({
  scope: di.ProviderScope.SINGLETON,
  global: true
}), tslib.__metadata("design:paramtypes", [])], exports.PlatformConfiguration);

/**
 * @ignore
 */
function bindEndpointMiddleware(endpoint) {
  return ctx => {
    ctx.endpoint = endpoint;
  };
}

var PlatformLogMiddleware_1;
/**
 * @middleware
 * @platform
 */

exports.PlatformLogMiddleware = PlatformLogMiddleware_1 = class PlatformLogMiddleware {
  // tslint:disable-next-line: no-unused-variable
  constructor(injector) {
    this.settings = injector.settings.logger || {};
    this.settings.requestFields = this.settings.requestFields || PlatformLogMiddleware_1.DEFAULT_FIELDS;

    if (this.settings.level !== "off") {
      this.$onResponse = this.onLogEnd.bind(this);
    }
  }
  /**
   * Handle the request.
   */


  use(ctx) {
    this.configureRequest(ctx);
    this.onLogStart(ctx);
  }
  /**
   * The separate onLogStart() function will allow developer to overwrite the initial request log.
   * @param ctx
   */


  onLogStart(ctx) {
    const {
      debug,
      logRequest,
      logStart
    } = this.settings;

    if (logStart !== false) {
      if (debug) {
        ctx.logger.debug({
          event: "request.start"
        });
      } else if (logRequest) {
        ctx.logger.info({
          event: "request.start"
        });
      }
    }
  }
  /**
   * Called when the `$onResponse` is called by Ts.ED (through Express.end).
   */


  onLogEnd(ctx) {
    const {
      debug,
      logRequest,
      logEnd
    } = this.settings;

    if (logEnd !== false) {
      if (debug) {
        ctx.logger.debug({
          event: "request.end",
          status: ctx.response.statusCode,
          data: ctx.data
        });
      } else if (logRequest) {
        ctx.logger.info({
          event: "request.end",
          status: ctx.response.statusCode
        });
      }
    }

    ctx.logger.flush();
  }
  /**
   * Attach all information that will be necessary to log the request. Attach a new `request.log` object.
   */


  configureRequest(ctx) {
    ctx.logger.minimalRequestPicker = obj => _extends({}, this.minimalRequestPicker(ctx), obj);

    ctx.logger.completeRequestPicker = obj => _extends({}, this.requestToObject(ctx), obj);
  }
  /**
   * Return complete request info.
   * @returns {Object}
   * @param ctx
   */


  requestToObject(ctx) {
    const {
      request
    } = ctx;
    return {
      method: request.method,
      url: request.url,
      headers: request.headers,
      body: request.body,
      query: request.query,
      params: request.params
    };
  }
  /**
   * Return a filtered request from global configuration.
   * @returns {Object}
   * @param ctx
   */


  minimalRequestPicker(ctx) {
    const {
      requestFields
    } = this.settings;
    const info = this.requestToObject(ctx);
    return requestFields.reduce((acc, key) => {
      acc[key] = info[key];
      return acc;
    }, {});
  }

};
exports.PlatformLogMiddleware.DEFAULT_FIELDS = ["reqId", "method", "url", "duration"];

tslib.__decorate([tslib.__param(0, platformParams.Context()), tslib.__metadata("design:type", Function), tslib.__metadata("design:paramtypes", [Object]), tslib.__metadata("design:returntype", void 0)], exports.PlatformLogMiddleware.prototype, "use", null);

exports.PlatformLogMiddleware = PlatformLogMiddleware_1 = tslib.__decorate([platformMiddlewares.Middleware(), tslib.__metadata("design:paramtypes", [di.InjectorService])], exports.PlatformLogMiddleware);

/**
 * @ignore
 */
const createFakeRawDriver = () => {
  // istanbul ignore next
  function FakeRawDriver() {} // istanbul ignore next


  function use() {
    return this;
  }

  FakeRawDriver.use = use;
  FakeRawDriver.all = use;
  FakeRawDriver.get = use;
  FakeRawDriver.patch = use;
  FakeRawDriver.post = use;
  FakeRawDriver.put = use;
  FakeRawDriver.head = use;
  FakeRawDriver.delete = use;
  FakeRawDriver.options = use;
  return FakeRawDriver;
};

/**
 * @ignore
 */

function isResponse(obj) {
  return obj.data && obj.headers && obj.status && obj.statusText;
}
/**
 * @ignore
 */


exports.HandlerContextStatus = void 0;

(function (HandlerContextStatus) {
  HandlerContextStatus["PENDING"] = "pending";
  HandlerContextStatus["CANCELED"] = "canceled";
  HandlerContextStatus["RESOLVED"] = "resolved";
  HandlerContextStatus["REJECTED"] = "rejected";
})(exports.HandlerContextStatus || (exports.HandlerContextStatus = {}));

var _resolves = /*#__PURE__*/_classPrivateFieldLooseKey("resolves");

var _rejects = /*#__PURE__*/_classPrivateFieldLooseKey("rejects");

var _promise = /*#__PURE__*/_classPrivateFieldLooseKey("promise");

class HandlerContext {
  constructor({
    $ctx,
    err,
    metadata,
    args
  }) {
    Object.defineProperty(this, _resolves, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _rejects, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _promise, {
      writable: true,
      value: void 0
    });
    this.status = exports.HandlerContextStatus.PENDING;
    this.$ctx = $ctx;
    _classPrivateFieldLooseBase(this, _promise)[_promise] = new Promise((resolve, reject) => {
      _classPrivateFieldLooseBase(this, _resolves)[_resolves] = resolve;
      _classPrivateFieldLooseBase(this, _rejects)[_rejects] = reject;
    });
    err && (this.err = err);
    metadata && (this.metadata = metadata);
    args && (this.args = args || []);
    this.next = this.next.bind(this);
  }

  get request() {
    var _this$$ctx;

    return (_this$$ctx = this.$ctx) == null ? void 0 : _this$$ctx.getRequest();
  }

  get response() {
    var _this$$ctx2;

    return (_this$$ctx2 = this.$ctx) == null ? void 0 : _this$$ctx2.getResponse();
  }

  get isDone() {
    const {
      $ctx
    } = this;

    if (!$ctx || $ctx.isDone()) {
      return true;
    }

    if ($ctx.request.isAborted() || $ctx.response.isDone()) {
      this.destroy();

      if (this.status === exports.HandlerContextStatus.PENDING) {
        this.status = exports.HandlerContextStatus.RESOLVED;
      }
    }

    return this.status !== exports.HandlerContextStatus.PENDING;
  }

  get handler() {
    const {
      metadata
    } = this;

    if (metadata.handler) {
      return metadata.handler;
    }

    if (this.metadata.scope === di.ProviderScope.SINGLETON) {
      if (!this.$ctx.injector.has(metadata.token)) {
        this.$ctx.injector.invoke(metadata.token);
      }

      const instance = this.$ctx.injector.get(metadata.token);
      metadata.handler = instance[metadata.propertyKey].bind(instance);
      return metadata.handler;
    }

    const instance = this.$ctx.injector.invoke(metadata.token, this.$ctx.container);
    return instance[metadata.propertyKey].bind(instance);
  }
  /**
   *
   */


  async callHandler() {
    if (this.isDone) {
      return this;
    }

    try {
      this.handle(this.handler(...this.args, this.$ctx));
    } catch (er) {
      this.reject(er);
    }

    return _classPrivateFieldLooseBase(this, _promise)[_promise];
  }

  reject(er) {
    if (this.isDone) {
      return;
    }

    this.destroy();
    this.status = exports.HandlerContextStatus.REJECTED;

    _classPrivateFieldLooseBase(this, _rejects)[_rejects](er);
  }

  resolve(data) {
    if (this.isDone) {
      return;
    }

    if (this.$ctx && data !== undefined) {
      this.$ctx.data = data;
    }

    this.destroy();
    this.status = exports.HandlerContextStatus.RESOLVED;

    _classPrivateFieldLooseBase(this, _resolves)[_resolves](data);
  }

  next(error) {
    if (this.isDone) {
      return;
    }

    return error ? this.reject(error) : this.resolve();
  }

  destroy() {
    // @ts-ignore
    delete this.$ctx; // @ts-ignore

    delete this.args; // @ts-ignore

    delete this.metadata; // @ts-ignore

    delete this.err;
  }

  cancel() {
    if (this.isDone) {
      return;
    }

    this.destroy();
    this.status = exports.HandlerContextStatus.CANCELED;
    return _classPrivateFieldLooseBase(this, _resolves)[_resolves]();
  }

  handle(process) {
    if (this.isDone) {
      return;
    }

    const {
      metadata: {
        hasNextFunction
      },
      $ctx
    } = this;

    if (process) {
      if (process === $ctx.getResponse()) {
        // ABANDON
        return this.cancel();
      }

      if (core.isObservable(process)) {
        process = process.toPromise();
      }

      if (isResponse(process)) {
        $ctx.response.setHeaders(process.headers);
        $ctx.response.status(process.status);
        return this.handle(process.data);
      }

      if (core.isStream(process) || Buffer.isBuffer(process)) {
        return this.resolve(process);
      }

      if (core.isPromise(process)) {
        return process.then(result => this.handle(result)).catch(error => {
          if (error.response && isResponse(error.response)) {
            return this.handle(error.response);
          }

          return this.reject(error);
        });
      }
    }

    if (!hasNextFunction) {
      // no next function and empty response
      return this.resolve(process);
    }
  }

}

/**
 * @ignore
 */
exports.HandlerType = void 0;

(function (HandlerType) {
  HandlerType["CUSTOM"] = "custom";
  HandlerType["ENDPOINT"] = "endpoint";
  HandlerType["MIDDLEWARE"] = "middleware";
  HandlerType["ERR_MIDDLEWARE"] = "err:middleware";
  HandlerType["CTX_FN"] = "context";
  HandlerType["RAW_FN"] = "raw:middleware";
  HandlerType["RAW_ERR_FN"] = "raw:err:middleware";
})(exports.HandlerType || (exports.HandlerType = {}));

class HandlerMetadata {
  constructor(options) {
    this.injectable = false;
    this.type = exports.HandlerType.RAW_FN;
    this.hasNextFunction = false;
    const {
      target,
      token,
      propertyKey,
      type,
      scope,
      routeOptions
    } = options;
    this.type = type || target.type || exports.HandlerType.RAW_FN;
    this.scope = scope || di.ProviderScope.SINGLETON;
    this.routeOptions = routeOptions || {};
    const handler = propertyKey ? target.prototype[propertyKey] : target;

    if (propertyKey) {
      this.target = target;
      this.token = token;
      this.propertyKey = propertyKey;
      this.hasNextFunction = this.hasParamType(platformParams.ParamTypes.NEXT_FN);

      if (this.hasParamType(platformParams.ParamTypes.ERR)) {
        this.type = exports.HandlerType.ERR_MIDDLEWARE;
      }

      this.injectable = platformParams.ParamMetadata.getParams(target, propertyKey).length > 0;
    } else {
      this.handler = handler;
    }

    if (!this.injectable) {
      if (handler.length === 4) {
        this.type = exports.HandlerType.RAW_ERR_FN;
      }

      this.hasNextFunction = handler.length >= 3;
    }
  }

  get hasErrorParam() {
    return this.type === exports.HandlerType.ERR_MIDDLEWARE || this.type === exports.HandlerType.RAW_ERR_FN;
  }

  get parameters() {
    return this.injectable ? this.getParams() : [];
  }

  getParams() {
    return platformParams.ParamMetadata.getParams(this.target, this.propertyKey) || [];
  }

  hasParamType(paramType) {
    return this.getParams().findIndex(p => p.paramType === paramType) > -1;
  }

  isFinal() {
    var _this$routeOptions;

    return ((_this$routeOptions = this.routeOptions) == null ? void 0 : _this$routeOptions.isFinal) || false;
  }

  toString() {
    return [this.target && core.nameOf(this.target), this.propertyKey].filter(Boolean).join(".");
  }

}

var EndpointMetadata_1;
/**
 * EndpointMetadata contains metadata about a controller and his method.
 * Each annotation (@Get, @Body...) attached to a method are stored in a endpoint.
 * EndpointMetadata convert this metadata to an array which contain arguments to call an Express method.
 *
 * Example :
 *
 *    @Controller("/my-path")
 *    provide MyClass {
 *
 *        @Get("/")
 *        @Authenticated()
 *        public myMethod(){}
 *    }
 *
 */

exports.EndpointMetadata = EndpointMetadata_1 = class EndpointMetadata extends schema.JsonEntityStore {
  constructor(options) {
    super(_extends({
      store: core.Store.fromMethod(options.target, options.propertyKey),
      descriptor: core.descriptorOf(options.target, options.propertyKey)
    }, options)); // LIFECYCLE

    this.beforeMiddlewares = [];
    this.middlewares = [];
    this.afterMiddlewares = [];
    this.statusCode = 200;
    const {
      beforeMiddlewares = [],
      middlewares = [],
      afterMiddlewares = []
    } = options;
    this.after(afterMiddlewares);
    this.before(beforeMiddlewares);
    this.use(middlewares);
  }

  get targetName() {
    return core.nameOf(this.token);
  }

  get params() {
    return Array.from(this.children.values());
  }
  /**
   * Return the JsonOperation
   */


  get operation() {
    return this._operation;
  }

  get operationPaths() {
    return this.operation.operationPaths;
  }

  get view() {
    return this.store.get("view");
  }

  set view(view) {
    this.store.set("view", view);
  }

  get location() {
    return this.store.get("location");
  }

  set location(url) {
    this.store.set("location", url);
  }

  get acceptMimes() {
    return this.store.get("acceptMimes", []);
  }

  set acceptMimes(mimes) {
    this.store.set("acceptMimes", mimes);
  }

  get redirect() {
    return this.store.get("redirect");
  }

  set redirect(options) {
    this.store.set("redirect", _extends({
      status: 302
    }, options));
  }
  /**
   * Get all endpoints from a given class and his parents.
   * @param {Type<any>} target
   * @returns {EndpointMetadata[]}
   */


  static getEndpoints(target) {
    const operations = schema.getOperationsStores(target);
    return Array.from(operations.values()).map(endpoint => {
      endpoint = endpoint.clone();
      endpoint.token = core.classOf(target);
      return endpoint;
    });
  }
  /**
   * Get an endpoint.
   * @param target
   * @param propertyKey
   * @param descriptor
   */


  static get(target, propertyKey, descriptor) {
    descriptor = descriptor || core.descriptorOf(core.prototypeOf(target), propertyKey);
    return schema.JsonEntityStore.from(core.prototypeOf(target), propertyKey, descriptor);
  }

  addOperationPath(method, path, options = {}) {
    return this.operation.addOperationPath(method, path, options);
  }
  /**
   * Find the a value at the controller level. Let this value be extended or overridden by the endpoint itself.
   *
   * @param key
   * @returns {any}
   */


  get(key) {
    const ctrlValue = core.Store.from(this.target).get(key);
    return core.deepMerge(ctrlValue, this.store.get(key));
  }
  /**
   * Append middlewares to the beforeMiddlewares list.
   * @param args
   * @returns {EndpointMetadata}
   */


  before(args) {
    this.beforeMiddlewares = this.beforeMiddlewares.concat(args).filter(core.isFunction);
    return this;
  }
  /**
   * Append middlewares to the afterMiddlewares list.
   * @param args
   * @returns {EndpointMetadata}
   */


  after(args) {
    this.afterMiddlewares = this.afterMiddlewares.concat(args).filter(core.isFunction);
    return this;
  }
  /**
   * Store all arguments collected via Annotation.
   * @param args
   */


  use(args) {
    this.middlewares = this.middlewares.concat(args).filter(core.isFunction);
    return this;
  }

  clone() {
    const endpoint = new EndpointMetadata_1(_extends({}, this, {
      target: this.target,
      propertyKey: this.propertyKey,
      descriptor: this.descriptor,
      store: this.store,
      children: this.children
    }));
    endpoint.collectionType = this.collectionType;
    endpoint._type = this._type;
    endpoint._operation = this.operation;
    endpoint._schema = this._schema;
    endpoint.middlewares = [...this.middlewares];
    endpoint.afterMiddlewares = [...this.afterMiddlewares];
    endpoint.beforeMiddlewares = [...this.beforeMiddlewares];
    return endpoint;
  }

};

tslib.__decorate([core.Enumerable(), tslib.__metadata("design:type", Array)], exports.EndpointMetadata.prototype, "beforeMiddlewares", void 0);

tslib.__decorate([core.Enumerable(), tslib.__metadata("design:type", Array)], exports.EndpointMetadata.prototype, "middlewares", void 0);

tslib.__decorate([core.Enumerable(), tslib.__metadata("design:type", Array)], exports.EndpointMetadata.prototype, "afterMiddlewares", void 0);

tslib.__decorate([core.Enumerable(), tslib.__metadata("design:type", Number)], exports.EndpointMetadata.prototype, "statusCode", void 0);

exports.EndpointMetadata = EndpointMetadata_1 = tslib.__decorate([schema.JsonEntityComponent(core.DecoratorTypes.METHOD), tslib.__metadata("design:paramtypes", [Object])], exports.EndpointMetadata);

function isMetadata(input) {
  return input instanceof HandlerMetadata;
}
/**
 * @ignore
 */


function createHandlerMetadata(injector, obj, routeOptions = {}) {
  if (isMetadata(obj)) {
    return obj;
  }

  let options;

  if (obj instanceof exports.EndpointMetadata) {
    const provider = injector.getProvider(obj.token);
    options = {
      token: provider.token,
      target: provider.useClass,
      scope: provider.scope,
      type: exports.HandlerType.ENDPOINT,
      propertyKey: obj.propertyKey
    };
  } else {
    const provider = injector.getProvider(obj);

    if (provider) {
      options = {
        token: provider.token,
        target: provider.useClass,
        scope: provider.scope,
        type: exports.HandlerType.MIDDLEWARE,
        propertyKey: "use"
      };
    } else {
      options = {
        target: obj
      };
    }
  }

  options.routeOptions = routeOptions;
  return new HandlerMetadata(options);
}

function toHeaders(headers) {
  return Object.entries(headers).reduce((headers, [key, item]) => {
    return _extends({}, headers, {
      [key]: String(item.example)
    });
  }, {});
}
/**
 * @ignore
 */


function setResponseHeaders(ctx) {
  const {
    response,
    endpoint
  } = ctx;
  const {
    operation
  } = endpoint;

  if (response.isDone()) {
    return;
  }

  if (!response.hasStatus()) {
    // apply status only if the isn't already modified
    response.status(operation.getStatus());
  }

  const headers = operation.getHeadersOf(response.statusCode);
  response.setHeaders(toHeaders(headers));

  if (endpoint.redirect) {
    response.redirect(endpoint.redirect.status || 302, endpoint.redirect.url);
  }

  if (endpoint.location) {
    response.location(endpoint.location);
  }
}

var _converterSettings;
exports.ConverterService = (_converterSettings = /*#__PURE__*/_classPrivateFieldLooseKey("converterSettings"), class ConverterService {
  constructor(injectorService, configuration) {
    Object.defineProperty(this, _converterSettings, {
      writable: true,
      value: void 0
    });
    this.injectorService = injectorService;
    _classPrivateFieldLooseBase(this, _converterSettings)[_converterSettings] = configuration.get("converter") || {};
  }

  /**
   * Convert instance to plainObject.
   *
   * @param obj
   * @param options
   */
  serialize(obj, options = {}) {
    return jsonMapper.serialize(obj, _extends({
      useAlias: true,
      additionalProperties: _classPrivateFieldLooseBase(this, _converterSettings)[_converterSettings].additionalProperties === "accept"
    }, options));
  }
  /**
   * Convert a plainObject to targetType.
   *
   * ### Options
   *
   * - `ignoreCallback`: callback called for each object which will be deserialized. The callback can return a boolean to avoid the default converter behavior.
   * - `checkRequiredValue`: Disable the required check condition.
   *
   * @param obj Object source that will be deserialized
   * @param options Mapping options
   * @returns {any}
   */


  deserialize(obj, options = {}) {
    return jsonMapper.deserialize(obj, _extends({
      useAlias: true,
      additionalProperties: _classPrivateFieldLooseBase(this, _converterSettings)[_converterSettings].additionalProperties === "accept"
    }, options));
  }

});
exports.ConverterService = tslib.__decorate([di.Injectable(), tslib.__param(1, di.Configuration()), tslib.__metadata("design:paramtypes", [di.InjectorService, Object])], exports.ConverterService);

function shouldBeSent(data) {
  return Buffer.isBuffer(data) || core.isBoolean(data) || core.isNumber(data) || core.isString(data) || data === null;
}

function shouldBeSerialized(data) {
  return !(core.isStream(data) || shouldBeSent(data) || data === undefined);
}
/**
 * Platform Handler abstraction layer. Wrap original class method to a pure platform handler (Express, Koa, etc...).
 * @platform
 */


exports.PlatformHandler = class PlatformHandler {
  constructor(injector, params) {
    this.injector = injector;
    this.params = params;
  }
  /**
   * Create a native middleware based on the given metadata and return an instance of HandlerContext
   * @param input
   * @param options
   */


  createHandler(input, options = {}) {
    const metadata = this.createHandlerMetadata(input, options);
    this.buildPipe(metadata);
    return this.createRawHandler(metadata);
  }

  createCustomHandler(provider, propertyKey) {
    const metadata = new HandlerMetadata({
      token: provider.provide,
      target: provider.useClass,
      type: exports.HandlerType.CUSTOM,
      scope: provider.scope,
      propertyKey
    });
    this.buildPipe(metadata);
    return this.createRawHandler(metadata);
  }
  /**
   * Create handler metadata
   * @param obj
   * @param routeOptions
   */


  createHandlerMetadata(obj, routeOptions = {}) {
    return createHandlerMetadata(this.injector, obj, routeOptions);
  }
  /**
   * Send the response to the consumer.
   * @param data
   * @param ctx
   * @protected
   */


  async flush(data, ctx) {
    const {
      response,
      endpoint
    } = ctx;

    if (endpoint) {
      if (endpoint.view) {
        data = await this.render(data, ctx);
      } else if (shouldBeSerialized(data)) {
        data = this.injector.get(exports.ConverterService).serialize(data, _extends({}, endpoint.getResponseOptions(), {
          endpoint: true
        }));
      }
    }

    if (!response.isDone()) {
      const responseFilter = this.injector.get(platformResponseFilter.PlatformResponseFilter);
      response.body(responseFilter.transform(data, ctx));
    }
  }

  async onCtxRequest(requestOptions) {
    const {
      metadata,
      $ctx
    } = requestOptions;
    await metadata.handler($ctx);
    return this.next(requestOptions);
  }
  /**
   * Call handler when a request his handle
   * @param requestOptions
   */


  async onRequest(requestOptions) {
    // istanbul ignore next
    if (!requestOptions.$ctx) {
      logger.$log.error(`Endpoint ${requestOptions.metadata.toString()} is called but the response is already send to your consumer. Check your code and his middlewares please!`);
      return;
    }

    const h = new HandlerContext(_extends({}, requestOptions, {
      args: []
    }));
    const {
      $ctx
    } = h;
    return this.injector.runInContext($ctx, async () => {
      try {
        h.args = await this.getArgs(h);
        await h.callHandler();

        if (h.status === exports.HandlerContextStatus.RESOLVED) {
          // Can be canceled by the handler itself
          return await this.onSuccess($ctx.data, requestOptions);
        }
      } catch (er) {
        return this.onError(er, requestOptions);
      }
    });
  }

  async onError(er, requestOptions) {
    const {
      next,
      $ctx
    } = requestOptions;
    $ctx.data = er;

    if (!next) {
      throw er;
    }

    return !$ctx.response.isHeadersSent() && next && next(er);
  }
  /**
   * Manage success scenario
   * @param data
   * @param requestOptions
   * @protected
   */


  async onSuccess(data, requestOptions) {
    const {
      metadata,
      $ctx,
      next
    } = requestOptions;

    if ($ctx.request.isAborted() || $ctx.response.isDone()) {
      return;
    } // set headers each times that an endpoint is called


    if (metadata.type === exports.HandlerType.ENDPOINT) {
      this.setHeaders($ctx);
    } // call returned middleware


    if (core.isFunction(data) && !core.isStream(data)) {
      return this.callReturnedMiddleware(data, $ctx, next);
    }

    if (metadata.isFinal()) {
      return this.flush(data, $ctx);
    }

    return this.next(requestOptions);
  }
  /**
   * Call the returned middleware by the handler.
   * @param middleware
   * @param ctx
   * @param next
   * @protected
   */


  callReturnedMiddleware(middleware, ctx, next) {
    return middleware(ctx.getRequest(), ctx.getResponse(), next);
  }
  /**
   * Render the view if the endpoint has a configured view.
   * @param data
   * @param ctx
   * @protected
   */


  async render(data, ctx) {
    return platformViews.renderView(data, ctx);
  }
  /**
   * create Raw handler
   * @param metadata
   */


  createRawHandler(metadata) {
    switch (metadata.type) {
      case exports.HandlerType.CUSTOM:
        return (ctx, next) => this.onRequest({
          metadata,
          next,
          $ctx: ctx
        });

      case exports.HandlerType.RAW_ERR_FN:
      case exports.HandlerType.RAW_FN:
        return metadata.handler;

      default:
      case exports.HandlerType.ENDPOINT:
      case exports.HandlerType.MIDDLEWARE:
        return (request, response, next) => this.onRequest({
          metadata,
          next,
          $ctx: request.$ctx
        });
    }
  }
  /**
   * Set response headers
   * @param ctx
   * @protected
   */


  setHeaders(ctx) {
    return setResponseHeaders(ctx);
  }

  next(requestOptions) {
    const {
      $ctx,
      next
    } = requestOptions;
    return !$ctx.response.isDone() && next && next();
  }

  buildPipe(metadata) {
    if (metadata.injectable) {
      return metadata.parameters.forEach(param => {
        this.params.build(param);
      });
    }
  }

  getArgs(h) {
    const {
      metadata
    } = h;

    if (metadata.injectable) {
      return this.params.getArgs(h, metadata.parameters);
    }

    return [metadata.hasErrorParam && h.err, h.$ctx.request.request, h.$ctx.response.response, metadata.hasNextFunction && h.next].filter(Boolean);
  }

};
exports.PlatformHandler = tslib.__decorate([di.Injectable({
  scope: di.ProviderScope.SINGLETON
}), tslib.__metadata("design:paramtypes", [di.InjectorService, platformParams.PlatformParams])], exports.PlatformHandler);

var PlatformRouter_1;
/**
 * @ignore
 */

const PLATFORM_ROUTER_OPTIONS = Symbol.for("PlatformRouterOptions");
/**
 * Platform Router abstraction layer.
 * @platform
 */

exports.PlatformRouter = PlatformRouter_1 = class PlatformRouter {
  constructor(platformHandler) {
    this.platformHandler = platformHandler;
    this.rawRouter = this.raw = PlatformRouter_1.createRawRouter();
  }
  /**
   * Create a new instance of PlatformRouter
   * @param injector
   * @param routerOptions
   */


  static create(injector, routerOptions = {}) {
    const locals = new Map();
    locals.set(PLATFORM_ROUTER_OPTIONS, routerOptions);
    return injector.invoke(PlatformRouter_1, locals);
  }

  static createRawRouter() {
    return createFakeRawDriver();
  }

  callback() {
    return this.raw;
  }

  getRouter() {
    return this.rawRouter;
  }

  use(...handlers) {
    // @ts-ignore
    this.getRouter().use(...this.mapHandlers(handlers));
    return this;
  }

  addRoute(options) {
    const {
      method,
      path,
      handlers,
      isFinal
    } = options; // @ts-ignore

    this.getRouter()[method](path, ...this.mapHandlers(handlers, {
      method,
      path,
      isFinal
    }));
    return this;
  }

  all(path, ...handlers) {
    return this.addRoute({
      method: "all",
      path,
      handlers,
      isFinal: true
    });
  }

  get(path, ...handlers) {
    return this.addRoute({
      method: "get",
      path,
      handlers,
      isFinal: true
    });
  }

  post(path, ...handlers) {
    return this.addRoute({
      method: "post",
      path,
      handlers,
      isFinal: true
    });
  }

  put(path, ...handlers) {
    return this.addRoute({
      method: "put",
      path,
      handlers,
      isFinal: true
    });
  }

  delete(path, ...handlers) {
    return this.addRoute({
      method: "delete",
      path,
      handlers,
      isFinal: true
    });
  }

  patch(path, ...handlers) {
    return this.addRoute({
      method: "patch",
      path,
      handlers,
      isFinal: true
    });
  }

  head(path, ...handlers) {
    return this.addRoute({
      method: "head",
      path,
      handlers,
      isFinal: true
    });
  }

  options(path, ...handlers) {
    return this.addRoute({
      method: "options",
      path,
      handlers,
      isFinal: true
    });
  }

  statics(path, options) {
    return this;
  }

  multer(options) {
    const m = require("multer")(options);

    const makePromise = (multer, name) => {
      // istanbul ignore next
      if (!multer[name]) return;
      const fn = multer[name];

      multer[name] = function apply(...args) {
        const middleware = Reflect.apply(fn, this, args);
        return (req, res) => util.promisify(middleware)(req, res);
      };
    };

    makePromise(m, "any");
    makePromise(m, "array");
    makePromise(m, "fields");
    makePromise(m, "none");
    makePromise(m, "single");
    return m;
  }

  mapHandlers(handlers, options = {}) {
    return handlers.reduce((list, handler, index) => {
      if (typeof handler === "string") {
        return list.concat(handler);
      }

      if (handler instanceof PlatformRouter_1) {
        return list.concat(handler.callback());
      }

      return list.concat(this.platformHandler.createHandler(handler, _extends({}, options, {
        isFinal: options.isFinal ? index === handlers.length - 1 : false
      })));
    }, []);
  }

};

tslib.__decorate([di.Inject(), tslib.__metadata("design:type", di.InjectorService)], exports.PlatformRouter.prototype, "injector", void 0);

exports.PlatformRouter = PlatformRouter_1 = tslib.__decorate([di.Injectable({
  scope: di.ProviderScope.INSTANCE
}), tslib.__metadata("design:paramtypes", [exports.PlatformHandler])], exports.PlatformRouter);

var PlatformApplication_1;
/**
 * `PlatformApplication` is used to provide all routes collected by annotation `@Controller`.
 *
 * @platform
 */

exports.PlatformApplication = PlatformApplication_1 = class PlatformApplication extends exports.PlatformRouter {
  constructor(platformHandler) {
    super(platformHandler);
    this.rawApp = this.raw = PlatformApplication_1.createRawApp();
  }

  static createRawApp() {
    return createFakeRawDriver();
  }

  getApp() {
    return this.raw;
  }

};
exports.PlatformApplication = PlatformApplication_1 = tslib.__decorate([di.Injectable({
  scope: di.ProviderScope.SINGLETON
}), tslib.__metadata("design:paramtypes", [exports.PlatformHandler])], exports.PlatformApplication);

var PlatformMulterMiddleware_1;
/**
 * @middleware
 */

exports.PlatformMulterMiddleware = PlatformMulterMiddleware_1 = class PlatformMulterMiddleware {
  async use(ctx) {
    try {
      const {
        fields,
        options = {}
      } = ctx.endpoint.get(PlatformMulterMiddleware_1);

      const settings = _extends({}, this.settings, options);
      /* istanbul ignore next */


      if (settings.storage) {
        delete settings.dest;
      }

      const middleware = this.app.multer(settings).fields(this.getFields({
        fields
      }));
      return await middleware(ctx.getRequest(), ctx.getResponse());
    } catch (er) {
      throw er.code ? new exceptions.Exception(er.code, `${er.message} ${er.field || ""}`.trim()) : er;
    }
  }

  getFields(conf) {
    return conf.fields.map(({
      name,
      maxCount
    }) => ({
      name,
      maxCount
    }));
  }

};

tslib.__decorate([di.Constant("multer", {}), tslib.__metadata("design:type", Object)], exports.PlatformMulterMiddleware.prototype, "settings", void 0);

tslib.__decorate([di.Inject(), tslib.__metadata("design:type", exports.PlatformApplication)], exports.PlatformMulterMiddleware.prototype, "app", void 0);

tslib.__decorate([tslib.__param(0, platformParams.Context()), tslib.__metadata("design:type", Function), tslib.__metadata("design:paramtypes", [Object]), tslib.__metadata("design:returntype", Promise)], exports.PlatformMulterMiddleware.prototype, "use", null);

exports.PlatformMulterMiddleware = PlatformMulterMiddleware_1 = tslib.__decorate([platformMiddlewares.Middleware()], exports.PlatformMulterMiddleware);

/**
 * @deprecated Since 2020-11-30. Use PlatformAcceptMimesMiddleware.
 * @ignore
 */

exports.GlobalAcceptMimesMiddleware = class GlobalAcceptMimesMiddleware {
  use(ctx) {
    return;
  }

};

tslib.__decorate([tslib.__param(0, platformParams.Context()), tslib.__metadata("design:type", Function), tslib.__metadata("design:paramtypes", [Object]), tslib.__metadata("design:returntype", void 0)], exports.GlobalAcceptMimesMiddleware.prototype, "use", null);

exports.GlobalAcceptMimesMiddleware = tslib.__decorate([platformMiddlewares.Middleware()], exports.GlobalAcceptMimesMiddleware);

/**
 * @middleware
 * @platform
 */

exports.PlatformAcceptMimesMiddleware = class PlatformAcceptMimesMiddleware {
  use(ctx) {
    const {
      endpoint,
      request
    } = ctx;
    const mimes = core.uniq(((endpoint == null ? void 0 : endpoint.get("acceptMimes")) || []).concat(this.acceptMimes));

    if (mimes.length && !request.accepts(mimes)) {
      throw new exceptions.NotAcceptable(mimes.join(", "));
    }
  }

};

tslib.__decorate([di.Constant("acceptMimes", []), tslib.__metadata("design:type", Array)], exports.PlatformAcceptMimesMiddleware.prototype, "acceptMimes", void 0);

tslib.__decorate([tslib.__param(0, platformParams.Context()), tslib.__metadata("design:type", Function), tslib.__metadata("design:paramtypes", [Object]), tslib.__metadata("design:returntype", void 0)], exports.PlatformAcceptMimesMiddleware.prototype, "use", null);

exports.PlatformAcceptMimesMiddleware = tslib.__decorate([platformMiddlewares.Middleware()], exports.PlatformAcceptMimesMiddleware);

/**
 * @middleware
 * @deprecated Since 2020-11-30. Use PlatformAcceptMimesMiddleware.
 * @ignore
 */

exports.AcceptMimesMiddleware = class AcceptMimesMiddleware {
  use(ctx) {
    return;
  }

};

tslib.__decorate([tslib.__param(0, platformParams.Context()), tslib.__metadata("design:type", Function), tslib.__metadata("design:paramtypes", [Object]), tslib.__metadata("design:returntype", void 0)], exports.AcceptMimesMiddleware.prototype, "use", null);

exports.AcceptMimesMiddleware = tslib.__decorate([platformMiddlewares.Middleware()], exports.AcceptMimesMiddleware);

/**
 * Create Ts.ED context handler
 * @param fn
 * @ignore
 */

function useCtxHandler(fn) {
  fn.type = exports.HandlerType.CTX_FN;
  return fn;
}

/**
 * @ignore
 */

function formatMethod(method) {
  return (method === schema.OperationMethods.CUSTOM ? "use" : method || "use").toLowerCase();
}
/**
 * @ignore
 */


class PlatformControllerBuilder {
  constructor(provider) {
    this.provider = provider;
  }
  /**
   *
   * @returns {any}
   */


  build(injector) {
    const {
      middlewares: {
        useBefore
      }
    } = this.provider; // Controller lifecycle

    this.buildMiddlewares(useBefore) // Controller before-middleware
    .buildEndpoints() // All endpoints and his middlewares
    .buildChildrenCtrls(injector); // Children controllers

    return this.provider.getRouter();
  }

  buildEndpoints() {
    const {
      endpoints
    } = this.provider;
    const operationPaths = new Map();

    const getKey = (method, path) => `${method}-${path}`;

    const updateFinalRouteState = key => {
      if (operationPaths.has(key)) {
        operationPaths.get(key).isFinal = false;
      }
    };

    const setFinalRoute = (key, operationPath) => {
      operationPaths.set(key, operationPath);
      operationPath.isFinal = true;
    };

    endpoints.forEach(({
      operation
    }) => {
      operation == null ? void 0 : operation.operationPaths.forEach(operationPath => {
        if (operationPath.method !== schema.OperationMethods.CUSTOM) {
          const key = getKey(operationPath.method, operationPath.path);
          updateFinalRouteState(key);
          updateFinalRouteState(getKey(schema.OperationMethods.ALL, operationPath.path));
          setFinalRoute(key, operationPath);
        }
      });
    });
    endpoints.forEach(endpoint => {
      this.buildEndpoint(endpoint);
    });
    return this;
  }

  buildEndpoint(endpoint) {
    const {
      beforeMiddlewares,
      middlewares: mldwrs,
      afterMiddlewares,
      operation
    } = endpoint;
    const {
      middlewares: {
        use,
        useAfter
      }
    } = this.provider;
    const router = this.provider.getRouter(); // Endpoint lifecycle

    let handlers = [];
    const hasFiles = [...endpoint.children.values()].find(item => item.paramType === platformParams.ParamTypes.FILES);
    handlers = handlers.concat(useCtxHandler(bindEndpointMiddleware(endpoint))).concat(exports.PlatformAcceptMimesMiddleware).concat(hasFiles && exports.PlatformMulterMiddleware).concat(use) // Controller use-middlewares
    .concat(beforeMiddlewares) // Endpoint before-middlewares
    // .concat(endpoint.cache && PlatformCacheMiddleware)
    .concat(mldwrs) // Endpoint middlewares
    .concat(endpoint) // Endpoint metadata
    .concat(afterMiddlewares) // Endpoint after-middlewares
    .concat(useAfter) // Controller after middlewares (equivalent to afterEach)
    .filter(item => !!item); // Add handlers to the router

    operation == null ? void 0 : operation.operationPaths.forEach(({
      path,
      method,
      isFinal
    }) => {
      router.addRoute({
        method: formatMethod(method),
        path,
        handlers,
        isFinal
      });
    });

    if (!(operation != null && operation.operationPaths.size)) {
      router.use(...handlers);
    }
  }

  buildChildrenCtrls(injector) {
    const {
      children
    } = this.provider;
    const router = this.provider.getRouter();
    children.forEach(child => {
      const provider = injector.getProvider(child);
      /* istanbul ignore next */

      if (!provider) {
        throw new Error("Controller component not found in the ControllerRegistry");
      }

      new PlatformControllerBuilder(provider).build(injector);
      router.use(provider.path, provider.getRouter());
    });
  }

  buildMiddlewares(middlewares) {
    const router = this.provider.getRouter();
    middlewares.filter(o => typeof o === "function").forEach(middleware => {
      router.use(middleware);
    });
    return this;
  }

}

/**
 * Platform Request abstraction layer.
 * @platform
 */

exports.PlatformRequest = class PlatformRequest {
  constructor(raw) {
    this.raw = raw;
  }

  get secure() {
    return this.raw.secure;
  }

  get host() {
    return this.get("host");
  }

  get protocol() {
    return this.raw.protocol;
  }
  /**
   * Get the url of the request.
   *
   * Is equivalent of `express.response.originalUrl || express.response.url`.
   */


  get url() {
    return this.raw.originalUrl || this.raw.url;
  }

  get headers() {
    return this.raw.headers;
  }

  get method() {
    return this.raw.method;
  }
  /**
   * Contains key-value pairs of data submitted in the request body. By default, it is `undefined`, and is populated when you use
   * `body-parsing` middleware such as `express.json()` or `express.urlencoded()`.
   */


  get body() {
    return this.raw.body;
  }

  get rawBody() {
    return this.raw.rawBody;
  }
  /**
   * When using `cookie-parser` middleware, this property is an object that contains cookies sent by the request.
   * If the request contains no cookies, it defaults to `{}`.
   */


  get cookies() {
    return this.raw.cookies;
  }
  /**
   * This property is an object containing properties mapped to the named route `parameters`.
   * For example, if you have the route `/user/:name`, then the `name` property is available as `req.params.name`.
   * This object defaults to `{}`.
   */


  get params() {
    return this.raw.params;
  }
  /**
   * This property is an object containing a property for each query string parameter in the route.
   * When query parser is set to disabled, it is an empty object `{}`, otherwise it is the result of the configured query parser.
   */


  get query() {
    return this.raw.query;
  }
  /**
   * This property is an object containing a property for each session attributes set by any code.
   * It require to install a middleware like express-session to work.
   */


  get session() {
    return this.raw.session;
  }

  get files() {
    return this.raw.files;
  }
  /**
   * Return the original request framework instance
   */


  get request() {
    return this.getRequest();
  }
  /**
   * Return the original request node.js instance
   */


  get req() {
    return this.getReq();
  }
  /**
   * Returns the HTTP request header specified by field. The match is case-insensitive.
   *
   * ```typescript
   * request.get('Content-Type') // => "text/plain"
   * ```
   *
   * @param name
   */


  get(name) {
    return this.raw.get(name);
  }

  accepts(mime) {
    // @ts-ignore
    return this.raw.accepts(mime);
  }

  isAborted() {
    return this.raw.aborted;
  }

  destroy() {
    // @ts-ignore
    delete this.raw;
  }
  /**
   * Return the Framework response object (express, koa, etc...)
   */


  getRequest() {
    return this.raw;
  }
  /**
   * Return the Node.js response object
   */


  getReq() {
    return this.raw;
  }

};
exports.PlatformRequest = tslib.__decorate([di.Injectable(), di.Scope(di.ProviderScope.INSTANCE), tslib.__param(0, di.Opts), tslib.__metadata("design:paramtypes", [Object])], exports.PlatformRequest);

var PlatformResponse_1;

const onFinished = require("on-finished");
/**
 * Platform Response abstraction layer.
 * @platform
 */


exports.PlatformResponse = PlatformResponse_1 = class PlatformResponse {
  constructor(raw) {
    this.raw = raw;
  }
  /**
   * Get the current statusCode
   */


  get statusCode() {
    return this.raw.statusCode;
  }
  /**
   * An object that contains response local variables scoped to the request, and therefore available only to the view(s) rendered during that request / response cycle (if any). Otherwise, this property is identical to app.locals.
   *
   * This property is useful for exposing request-level information such as the request path name, authenticated user, user settings, and so on.
   */


  get locals() {
    return this.raw.locals;
  }
  /**
   * Return the original response framework instance
   */


  get response() {
    return this.getResponse();
  }
  /**
   * Return the original response node.js instance
   */


  get res() {
    return this.getRes();
  }

  static onFinished(res, cb) {
    onFinished(res, cb);
  }
  /**
   * Returns the HTTP response header specified by field. The match is case-insensitive.
   *
   * ```typescript
   * response.get('Content-Type') // => "text/plain"
   * ```
   *
   * @param name
   */


  get(name) {
    return this.raw.get(name);
  }

  getHeaders() {
    return this.raw.getHeaders();
  }
  /**
   * Return the Framework response object (express, koa, etc...)
   */


  getResponse() {
    return this.raw;
  }
  /**
   * Return the Node.js response object
   */


  getRes() {
    return this.raw;
  }

  hasStatus() {
    return this.statusCode !== 200;
  }
  /**
   * Sets the HTTP status for the response.
   *
   * @param status
   */


  status(status) {
    this.raw.status(status);
    return this;
  }
  /**
   * Set header `field` to `val`, or pass
   * an object of header fields.
   *
   * Examples:
   * ```typescript
   * response.setHeaders({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
   * ```
   *
   * Aliased as `res.header()`.
   */


  setHeaders(headers) {
    // apply headers
    Object.entries(headers).forEach(([key, item]) => {
      this.setHeader(key, item);
    });
    return this;
  }

  setHeader(key, item) {
    this.raw.set(key, String(item));
    return this;
  }
  /**
   * Set `Content-Type` response header with `type` through `mime.lookup()`
   * when it does not contain "/", or set the Content-Type to `type` otherwise.
   *
   * Examples:
   *
   *     res.type('.html');
   *     res.type('html');
   *     res.type('json');
   *     res.type('application/json');
   *     res.type('png');
   */


  contentType(contentType) {
    this.raw.contentType(contentType);
    return this;
  }

  contentLength(length) {
    this.setHeader("Content-Length", length);
    return this;
  }

  getContentLength() {
    if (this.get("Content-Length")) {
      return parseInt(this.get("Content-Length"), 10) || 0;
    }
  }

  getContentType() {
    return (this.get("Content-Type") || "").split(";")[0];
  }
  /**
   * Sets the HTTP response Content-Disposition header field to attachment.
   * If a filename is given, then it sets the Content-Type based on the extension name via res.type(), and sets the Content-Disposition filename= parameter.
   *
   * ```typescript
   * res.attachment()
   * // Content-Disposition: attachment
   *
   * res.attachment('path/to/logo.png')
   * // Content-Disposition: attachment; filename="logo.png"
   * // Content-Type: image/png
   * ```
   *
   * @param filename
   */


  attachment(filename) {
    this.raw.attachment(filename);
    return this;
  }
  /**
   * Redirects to the URL derived from the specified path, with specified status, a positive integer that corresponds to an [HTTP status code](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
   * If not specified, status defaults to `302 Found`.
   *
   * @param status
   * @param url
   */


  redirect(status, url) {
    this.raw.redirect(status, url);
    return this;
  }
  /**
   * Sets the response Location HTTP header to the specified path parameter.
   *
   * @param location
   */


  location(location) {
    this.raw.location(location);
    return this;
  }
  /**
   * Stream the given data.
   *
   * @param data
   */


  stream(data) {
    data.pipe(this.raw);
    return this;
  }
  /**
   * Renders a view and sends the rendered HTML string to the client.
   *
   * @param path
   * @param options
   */


  async render(path, options = {}) {
    return this.platformViews.render(path, _extends({}, this.locals, options));
  }
  /**
   * Send any data to your consumer.
   *
   * This method accept a ReadableStream, a plain object, boolean, string, number, null and undefined data.
   * It choose the better way to send the data.
   *
   * @param data
   */


  body(data) {
    this.data = data;

    if (data === undefined) {
      this.raw.send();
      return this;
    }

    if (core.isStream(data)) {
      this.stream(data);
      return this;
    }

    if (Buffer.isBuffer(data)) {
      if (!this.getContentType()) {
        this.contentType("application/octet-stream");
      }

      this.contentLength(data.length);
      this.raw.send(data);
      return this;
    }

    if (core.isBoolean(data) || core.isNumber(data) || core.isString(data) || data === null) {
      this.raw.send(data);
      return this;
    }

    this.raw.json(data);
    return this;
  }

  getBody() {
    return this.data;
  }
  /**
   * Add a listener to handler the end of the request/response.
   * @param cb
   */


  onEnd(cb) {
    PlatformResponse_1.onFinished(this.getRes(), cb);
    return this;
  }

  isDone() {
    if (!this.raw) {
      return true;
    }

    const res = this.getRes();
    return Boolean(this.isHeadersSent() || res.writableEnded || res.writableFinished);
  }

  destroy() {
    // @ts-ignore
    delete this.raw;
    delete this.data;
  }

  isHeadersSent() {
    return this.getRes().headersSent;
  }

};

tslib.__decorate([di.Inject(), tslib.__metadata("design:type", platformViews.PlatformViews)], exports.PlatformResponse.prototype, "platformViews", void 0);

exports.PlatformResponse = PlatformResponse_1 = tslib.__decorate([di.Injectable(), di.Scope(di.ProviderScope.INSTANCE), tslib.__param(0, di.Opts), tslib.__metadata("design:paramtypes", [Object])], exports.PlatformResponse);

const _excluded$2 = ["response", "request", "endpoint", "url", "ignoreUrlPatterns"];

var _ignoreUrlPatterns = /*#__PURE__*/_classPrivateFieldLooseKey("ignoreUrlPatterns");

class PlatformContext extends di.DIContext {
  constructor(_ref) {
    let {
      response,
      request,
      endpoint,
      url,
      ignoreUrlPatterns = []
    } = _ref,
        options = _objectWithoutPropertiesLoose(_ref, _excluded$2);

    super(_extends({}, options, {
      ignoreLog: () => {
        return _classPrivateFieldLooseBase(this, _ignoreUrlPatterns)[_ignoreUrlPatterns].find(reg => !!this.url.match(reg));
      }
    }));
    Object.defineProperty(this, _ignoreUrlPatterns, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _ignoreUrlPatterns)[_ignoreUrlPatterns] = [];
    this.url = url;
    endpoint && (this.endpoint = endpoint);
    _classPrivateFieldLooseBase(this, _ignoreUrlPatterns)[_ignoreUrlPatterns] = ignoreUrlPatterns.map(pattern => typeof pattern === "string" ? new RegExp(pattern, "gi") : pattern);

    if (response) {
      this.response = response;
      this.container.set(exports.PlatformResponse, response);
    }

    if (request) {
      this.request = request;
      this.container.set(exports.PlatformRequest, request);
    }

    this.container.set(PlatformContext, this);
  }

  get app() {
    return this.injector.get(exports.PlatformApplication);
  }

  async destroy() {
    await super.destroy();
    this.response.destroy();
    this.request.destroy(); // @ts-ignore

    delete this.endpoint; // @ts-ignore

    delete this.response; // @ts-ignore

    delete this.request;
  }

  isDone() {
    return !this.request || !this.response;
  }
  /**
   * Return the framework request instance (Express, Koa, etc...)
   */


  getRequest() {
    return this.request.getRequest();
  }
  /**
   * Return the framework response instance (Express, Koa, etc...)
   */


  getResponse() {
    return this.response.getResponse();
  }
  /**
   * Get Node.js request
   */


  getReq() {
    return this.request.getReq();
  }
  /**
   * Get Node.js response
   */


  getRes() {
    return this.response.getRes();
  }
  /**
   * Return the original application instance.
   */


  getApp() {
    return this.app.getApp();
  }

}

class PlatformRouteDetails {
  constructor({
    provider,
    endpoint,
    method,
    url
  }) {
    this.provider = provider;
    this.endpoint = endpoint;
    this.method = method;
    this.url = url;
    this.rawBody = !!endpoint.params.find(param => param.paramType === platformParams.ParamTypes.RAW_BODY);
  }

  get name() {
    return `${this.endpoint.targetName}.${this.methodClassName}()`;
  }

  get className() {
    return this.endpoint.targetName;
  }

  get methodClassName() {
    return String(this.endpoint.propertyKey);
  }

  get parameters() {
    return this.endpoint.params;
  }

  toJSON() {
    return {
      method: this.method,
      name: this.name,
      url: this.url,
      className: this.className,
      methodClassName: this.methodClassName,
      parameters: this.parameters,
      rawBody: this.rawBody
    };
  }

}

const ROUTER_OPTIONS = Symbol.for("ROUTER_OPTIONS");

class ControllerProvider extends di.Provider {
  constructor(provide) {
    super(provide);
    this.type = di.ProviderType.CONTROLLER;
    this.entity = schema.JsonEntityStore.from(provide);
  }

  get path() {
    return this.entity.path;
  }

  set path(path) {
    this.entity.path = path;
  }
  /**
   *
   * @returns {EndpointMetadata[]}
   */


  get endpoints() {
    return exports.EndpointMetadata.getEndpoints(this.provide);
  }

  get children() {
    return this.store.get("childrenControllers", []);
  }
  /**
   *
   * @returns {ControllerProvider}
   */


  get parent() {
    return this.store.get("parentController");
  }
  /**
   *
   */


  get routerOptions() {
    return this.store.get(ROUTER_OPTIONS) || {};
  }
  /**
   *
   * @param value
   */


  set routerOptions(value) {
    this.store.set(ROUTER_OPTIONS, value);
  }
  /**
   *
   * @returns {any[]}
   */


  get middlewares() {
    return Object.assign({
      use: [],
      useAfter: [],
      useBefore: []
    }, this.store.get("middlewares", {}));
  }
  /**
   *
   * @param middlewares
   */


  set middlewares(middlewares) {
    const mdlwrs = this.middlewares;

    const concat = (key, a, b) => a[key] = a[key].concat(b[key]);

    Object.keys(middlewares).forEach(key => {
      concat(key, mdlwrs, middlewares);
    });
    this.store.set("middlewares", mdlwrs);
  }
  /**
   *
   * @returns {boolean}
   */


  hasChildren() {
    return !!this.children.length;
  }
  /**
   *
   * @returns {boolean}
   */


  hasParent() {
    return !!this.store.get("parentController");
  }

  getRouter() {
    return this.router;
  }

  setRouter(router) {
    this.router = router;
    return this;
  }

}

tslib.__decorate([core.NotEnumerable(), tslib.__metadata("design:type", schema.JsonEntityStore)], ControllerProvider.prototype, "entity", void 0);

tslib.__decorate([core.NotEnumerable(), tslib.__metadata("design:type", Object)], ControllerProvider.prototype, "router", void 0);

tslib.__decorate([core.Enumerable(), tslib.__metadata("design:type", String), tslib.__metadata("design:paramtypes", [String])], ControllerProvider.prototype, "path", null);

exports.PropertyMetadata = class PropertyMetadata extends schema.JsonEntityStore {
  static get(target, propertyKey) {
    return schema.JsonEntityStore.from(core.prototypeOf(target), propertyKey);
  }
  /**
   * @deprecated Since 2020-11-11. Use getProperties from @tsed/schema
   */


  static getProperties(target, options = {}) {
    return schema.getProperties(target, options);
  }

};
exports.PropertyMetadata = tslib.__decorate([schema.JsonEntityComponent(core.DecoratorTypes.PROP)], exports.PropertyMetadata);

function getControllerPath(basePath, provider) {
  return (basePath === provider.path ? provider.path : (basePath || "") + provider.path).replace(/\/\//gi, "/");
}

var _routes, _controllers;
/**
 * `Platform` is used to provide all routes collected by annotation `@Controller`.
 *
 * @platform
 */

exports.Platform = (_routes = /*#__PURE__*/_classPrivateFieldLooseKey("routes"), _controllers = /*#__PURE__*/_classPrivateFieldLooseKey("controllers"), class Platform {
  constructor(injector, platformApplication) {
    Object.defineProperty(this, _routes, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _controllers, {
      writable: true,
      value: void 0
    });
    this.injector = injector;
    this.platformApplication = platformApplication;
    _classPrivateFieldLooseBase(this, _routes)[_routes] = [];
    _classPrivateFieldLooseBase(this, _controllers)[_controllers] = [];
  }

  get app() {
    return this.platformApplication;
  }

  get routes() {
    return _classPrivateFieldLooseBase(this, _routes)[_routes];
  }

  addRoutes(routes) {
    routes.forEach(routeSettings => {
      this.addRoute(routeSettings.route, routeSettings.token);
    });
  }

  addRoute(endpoint, token) {
    const {
      injector
    } = this;

    if (injector.hasProvider(token)) {
      const provider = injector.getProvider(token);

      if (provider.type === di.ProviderType.CONTROLLER) {
        const route = getControllerPath(endpoint, provider);

        if (!provider.hasParent()) {
          const routes = this.buildRoutes(route, provider);

          _classPrivateFieldLooseBase(this, _routes)[_routes].push(...routes);

          _classPrivateFieldLooseBase(this, _controllers)[_controllers].push({
            route,
            provider
          });

          this.app.use(route, ...[].concat(provider.getRouter().callback()));
        }
      }
    }

    return this;
  }
  /**
   * Get all routes built by TsExpressDecorators and mounted on Express application.
   * @returns {PlatformRouteDetails[]}
   */


  getRoutes() {
    return _classPrivateFieldLooseBase(this, _routes)[_routes];
  }

  getMountedControllers() {
    return _classPrivateFieldLooseBase(this, _controllers)[_controllers];
  }
  /**
   *
   * @param ctrl
   * @param endpointUrl
   */


  buildRoutes(endpointUrl, ctrl) {
    const {
      injector
    } = this;
    let routes = [];
    routes = ctrl.children.map(ctrl => injector.getProvider(ctrl)).reduce((routes, provider) => {
      return routes.concat(this.buildRoutes(`${endpointUrl}${provider.path}`, provider));
    }, routes);
    ctrl.endpoints.forEach(endpoint => {
      endpoint.operationPaths.forEach(({
        path,
        method
      }) => {
        if (method) {
          routes.push(new PlatformRouteDetails({
            provider: ctrl,
            endpoint,
            method,
            url: `${endpointUrl}${path || ""}`.replace(/\/\//gi, "/")
          }));
        }
      });
    });
    return routes;
  }

});
exports.Platform = tslib.__decorate([di.Injectable({
  scope: di.ProviderScope.SINGLETON
}), tslib.__metadata("design:paramtypes", [di.InjectorService, exports.PlatformApplication])], exports.Platform);

/**
 * @ignore
 */

exports.PlatformModule = class PlatformModule {
  constructor(injector, platform) {
    this.injector = injector;
    this.platform = platform;
    this.createRoutersFromControllers();
  }
  /**
   * Create routers from the collected controllers
   */


  createRoutersFromControllers() {
    const {
      injector
    } = this;
    return injector.getProviders(di.ProviderType.CONTROLLER).map(provider => {
      provider.setRouter(exports.PlatformRouter.create(injector, provider.routerOptions));

      if (!provider.hasParent()) {
        return new PlatformControllerBuilder(provider).build(injector);
      }
    }).filter(Boolean);
  }

  $$loadRoutes() {
    const routes = this.injector.settings.get("routes");
    this.platform.addRoutes(routes);
  }

};
exports.PlatformModule = tslib.__decorate([di.Module({
  imports: [di.InjectorService, exports.ConverterService, exports.Platform]
}), tslib.__metadata("design:paramtypes", [di.InjectorService, exports.Platform])], exports.PlatformModule);

logger.$log.name = "TSED";
function createInjector(settings = {}) {
  const injector = new di.InjectorService();
  injector.settings = createSettingsService(injector);
  injector.logger = logger.$log;
  injector.settings.set(settings);
  di.setLoggerLevel(injector);
  return injector;
}

function createSettingsService(injector) {
  const provider = di.GlobalProviders.get(exports.PlatformConfiguration).clone();
  provider.instance = injector.invoke(provider.useClass);
  injector.addProvider(exports.PlatformConfiguration, provider);
  return provider.instance;
}

function createPlatformApplication(injector) {
  injector.forkProvider(exports.PlatformApplication);
}

/**
 * Inject the Http.Server instance.
 *
 * ### Example
 *
 * ```typescript
 * import {HttpServer, Service} from "@tsed/common";
 *
 * @Service()
 * export default class OtherService {
 *    constructor(@HttpServer httpServer: HttpServer) {}
 * }
 * ```
 *
 * > Note: TypeScript transform and store `HttpServer` as `Function` type in the metadata. So to inject a factory, you must use the `@Inject(type)` decorator.
 *
 * @param {Type<any>} target
 * @param {string} targetKey
 * @param {TypedPropertyDescriptor<Function> | number} descriptor
 * @returns {any}
 * @decorator
 */

function HttpServer(target, targetKey, descriptor) {
  return di.Inject(HttpServer)(target, targetKey, descriptor);
}

function listenServer(http, settings) {
  const {
    address,
    port
  } = settings;
  const promise = new Promise((resolve, reject) => {
    http.on("listening", resolve);
    http.on("error", reject);
  }).then(() => {
    const port = http.address().port;
    return {
      address: settings.address,
      port
    };
  });
  http.listen(port, address);
  return promise;
}

function createHttpServer(injector) {
  injector.forkProvider(HttpServer);
}
di.registerProvider({
  provide: HttpServer,
  deps: [exports.PlatformApplication],
  scope: di.ProviderScope.SINGLETON,
  global: true,

  useFactory(platformApplication) {
    return Http__default['default'].createServer(platformApplication.callback());
  }

});
async function listenHttpServer(injector) {
  const {
    settings
  } = injector;
  const server = injector.get(HttpServer);

  if (settings.httpPort !== false && server) {
    const {
      address,
      port
    } = settings.getHttpPort();
    injector.logger.debug(`Start server on http://${address}:${port}`);
    const options = await listenServer(server, {
      address,
      port
    });
    settings.setHttpPort(options);
    injector.logger.info(`Listen server on http://${options.address}:${options.port}`);
  }
}

/**
 * Inject the Https.Server instance.
 *
 * ### Example
 *
 * ```typescript
 * import {HttpsServer, Service} from "@tsed/common";
 *
 * @Service()
 * export default class OtherService {
 *    constructor(@HttpsServer httpServer: HttpServer) {}
 * }
 * ```
 *
 * > Note: TypeScript transform and store `HttpsServer` as `Function` type in the metadata. So to inject a factory, you must use the `@Inject(type)` decorator.
 *
 * @param {Type<any>} target
 * @param {string} targetKey
 * @param {TypedPropertyDescriptor<Function> | number} descriptor
 * @returns {any}
 * @decorator
 */

function HttpsServer(target, targetKey, descriptor) {
  return di.Inject(HttpsServer)(target, targetKey, descriptor);
}

function createHttpsServer(injector) {
  injector.forkProvider(HttpsServer);
}
di.registerProvider({
  provide: HttpsServer,
  deps: [exports.PlatformApplication, di.Configuration],
  scope: di.ProviderScope.SINGLETON,
  global: true,

  useFactory(platformApplication, settings) {
    const options = settings.httpsOptions;
    return Https__default['default'].createServer(options, platformApplication.callback());
  }

});
async function listenHttpsServer(injector) {
  const {
    settings
  } = injector;
  const server = injector.get(HttpsServer);

  if (settings.httpsPort !== false && server) {
    const {
      address,
      port
    } = settings.getHttpsPort();
    injector.logger.debug(`Start server on https://${address}:${port}`);
    const options = await listenServer(server, {
      address,
      port
    });
    settings.setHttpsPort(options);
    injector.logger.info(`Listen server on https://${options.address}:${options.port}`);
  }
}

/**
 * @ignore
 * @deprecated User injector.load(container, module) instead
 */

async function loadInjector(injector, container = di.createContainer()) {
  injector.bootstrap(container);
  return injector.load(container, exports.PlatformModule);
}

function printRoutes(routes) {
  const mapColor = {
    GET: "green",
    POST: "yellow",
    PUT: "blue",
    DELETE: "red",
    PATCH: "magenta",
    ALL: "cyan"
  };
  const list = routes.map(route => {
    const obj = route.toJSON();
    const method = obj.method.toUpperCase();
    obj.method = {
      length: method.length,
      toString: () => {
        return logger.colorize(method, mapColor[method]);
      }
    };
    return obj;
  });
  const str = logger.$log.drawTable(list, {
    padding: 1,
    header: {
      method: "Method",
      url: "Endpoint",
      name: "Class method"
    }
  });
  return "\n" + str.trim();
}

const uuidv4 = require("uuid").v4;

const defaultReqIdBuilder = req => req.get("x-request-id") || uuidv4().replace(/-/gi, "");
/**
 * Create the TsED context to wrap request, response, injector, etc...
 * @param injector
 * @param request
 * @param response
 * @ignore
 */


async function createContext(injector, request, response) {
  const {
    level,
    ignoreUrlPatterns,
    maxStackSize,
    reqIdBuilder = defaultReqIdBuilder
  } = injector.settings.logger;
  const req = request.getRequest();
  const id = reqIdBuilder(req);
  const ctx = new PlatformContext({
    id,
    logger: injector.logger,
    url: request.url,
    ignoreUrlPatterns,
    level,
    maxStackSize,
    injector,
    response,
    request
  });
  req.$ctx = ctx;
  response.setHeader("x-request-id", id);
  response.onEnd(async () => {
    await ctx.emit("$onResponse", ctx);
    await ctx.destroy();
    delete req.$ctx;
  });
  await ctx.emit("$onRequest", ctx);
  return ctx;
}

const SKIP_HOOKS = ["$beforeInit", "$afterInit", "$onInit", "$onMountingMiddlewares"];
const {
  bind,
  start,
  end,
  log
} = perf.PerfLogger.get("bootstrap");
/**
 * @platform
 */

var _rootModule = /*#__PURE__*/_classPrivateFieldLooseKey("rootModule");

var _injector = /*#__PURE__*/_classPrivateFieldLooseKey("injector");

var _providers = /*#__PURE__*/_classPrivateFieldLooseKey("providers");

class PlatformBuilder {
  constructor({
    name,
    providers
  }) {
    Object.defineProperty(this, _rootModule, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _injector, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _providers, {
      writable: true,
      value: void 0
    });
    this.name = "";
    this.startedAt = new Date();
    this.name = name;
    _classPrivateFieldLooseBase(this, _providers)[_providers] = core.toMap(providers, "provide");
    this.locals = new di.Container();
    this.useProvider(exports.PlatformHandler, _classPrivateFieldLooseBase(this, _providers)[_providers].get(exports.PlatformHandler)).useProvider(exports.PlatformResponse, _classPrivateFieldLooseBase(this, _providers)[_providers].get(exports.PlatformResponse)).useProvider(exports.PlatformRequest, _classPrivateFieldLooseBase(this, _providers)[_providers].get(exports.PlatformRequest)).useProvider(exports.PlatformRouter, _classPrivateFieldLooseBase(this, _providers)[_providers].get(exports.PlatformRouter)).useProvider(exports.PlatformApplication, _classPrivateFieldLooseBase(this, _providers)[_providers].get(exports.PlatformApplication)).useProvider(exports.Platform, _classPrivateFieldLooseBase(this, _providers)[_providers].get(exports.Platform));
  }

  get injector() {
    return _classPrivateFieldLooseBase(this, _injector)[_injector];
  }

  get rootModule() {
    return _classPrivateFieldLooseBase(this, _rootModule)[_rootModule];
  }

  get app() {
    return this.injector.get(exports.PlatformApplication);
  }

  get platform() {
    return this.injector.get(exports.Platform);
  }
  /**
   * Return the settings configured by the decorator @@Configuration@@.
   *
   * ```typescript
   * @Configuration({
   *    rootDir: Path.resolve(__dirname),
   *    port: 8000,
   *    httpsPort: 8080,
   *    mount: {
   *      "/rest": "${rootDir}/controllers/**\/*.js"
   *    }
   * })
   * export class Server {
   *     $onInit(){
   *         console.log(this.settings); // {rootDir, port, httpsPort,...}
   *     }
   * }
   * ```
   *
   * @returns {PlatformConfiguration}
   */


  get settings() {
    return this.injector.settings;
  }

  get logger() {
    return this.injector.logger;
  }

  get disableBootstrapLog() {
    return this.settings.logger.disableBootstrapLog;
  }

  static build(platformBuildClass) {
    return new platformBuildClass({
      name: core.nameOf(platformBuildClass).replace("Platform", "").toLowerCase(),
      providers: platformBuildClass.providers
    });
  }

  log(...data) {
    return this.disableBootstrapLog && this.logger.info(...data);
  }
  /**
   * Add classes to the components list
   * @param classes
   */


  addComponents(classes) {
    this.settings.componentsScan = this.settings.componentsScan.concat(classes);
    return this;
  }
  /**
   * Add classes decorated by @@Controller@@ to components container.
   *
   * ### Example
   *
   * ```typescript
   * @Controller('/ctrl')
   * class MyController{
   * }
   *
   * platform.addControllers('/rest', [MyController])
   * ```
   *
   * ::: tip
   * If the MyController class isn't decorated, the class will be ignored.
   * :::
   *
   * @param {string} endpoint
   * @param {any[]} controllers
   */


  addControllers(endpoint, controllers) {
    this.settings.mount[endpoint] = (this.settings.mount[endpoint] || []).concat(controllers);
  }

  async runLifecycle() {
    di.setLoggerLevel(this.injector);
    await this.importProviders();
    await this.loadInjector();
    this.useContext();
    this.useRouter();
    await this.loadRoutes();
    await this.logRoutes();
  }

  async loadInjector() {
    const {
      injector
    } = this;
    await this.callHook("$beforeInit");
    this.log("Build providers");
    const container = di.createContainer(core.constructorOf(this.rootModule));
    await injector.load(container, exports.PlatformModule);
    this.log("Settings and injector loaded");
    await this.callHook("$afterInit");
  }

  async listen() {
    await this.callHook("$beforeListen");
    await this.listenServers();
    await this.callHook("$afterListen");
    await this.ready();
    end();
  }

  async stop() {
    await this.callHook("$onDestroy");
    return this.injector.destroy();
  }

  async ready() {
    const {
      startedAt
    } = this;
    await this.callHook("$onReady");
    await this.injector.emit("$onServerReady");
    this.log(`Started in ${new Date().getTime() - startedAt.getTime()} ms`);
  }

  async callHook(hook, ...args) {
    const {
      injector,
      rootModule
    } = this;
    log(hook);

    if (!injector.settings.logger.disableBootstrapLog) {
      injector.logger.info(`\x1B[1mCall hook ${hook}\x1B[22m`);
    } // call hook for the Server


    if (hook in rootModule) {
      await rootModule[hook](...args);
    } // Load middlewares for the given hook


    this.loadMiddlewaresFor(hook); // call hooks added by providers

    if (!SKIP_HOOKS.includes(hook)) {
      await injector.emit(hook);
    }
  }

  async loadStatics() {
    const {
      settings
    } = this;

    if (settings.statics) {
      Object.entries(settings.statics).forEach(([path, items]) => {
        [].concat(items).forEach(options => {
          const opts = typeof options === "string" ? {
            root: options
          } : options;
          this.platform.app.statics(path, opts);
        });
      });
    }
  }

  useProvider(token, settings) {
    this.locals.addProvider(token, settings);
    return this;
  }

  async importProviders() {
    this.injector.logger.debug("Scan components");
    const providers = await di.importProviders(this.injector.settings, ["imports", "mount", "componentsScan"]);
    const routes = providers.filter(provider => !!provider.route).map(({
      route,
      token
    }) => ({
      route,
      token
    }));
    this.settings.set("routes", routes);
  }

  createRequest(req) {
    const Klass = _classPrivateFieldLooseBase(this, _providers)[_providers].get(exports.PlatformRequest).useClass;

    return new Klass(req);
  }

  createResponse(res) {
    const Klass = _classPrivateFieldLooseBase(this, _providers)[_providers].get(exports.PlatformResponse).useClass;

    const response = new Klass(res);
    response.platformViews = this.injector.get(platformViews.PlatformViews);
    return response;
  }
  /**
   * Load middlewares from configuration for the given hook
   * @param hook
   * @protected
   */


  loadMiddlewaresFor(hook) {
    return platformMiddlewares.getMiddlewaresForHook(hook, this.settings, "$beforeRoutesInit").forEach(({
      use
    }) => {
      this.app.use(use);
    });
  }

  useRouter() {
    return this;
  }

  useContext() {
    return this;
  }

  async bootstrap(module, settings = {}) {
    var _settings$logger;

    // istanbul ignore next
    if ((_settings$logger = settings.logger) != null && _settings$logger.perf) {
      start();
      bind(this);
      settings.logger = _extends({}, settings.logger, {
        level: "off"
      });
    }

    this.createInjector(module, _extends({}, settings, {
      PLATFORM_NAME: this.name
    }));
    this.createRootModule(module);
    await this.runLifecycle();
    return this;
  }

  async listenServers() {
    await Promise.all([listenHttpServer(this.injector), listenHttpsServer(this.injector)]);
  }

  async logRoutes() {
    const {
      logger,
      platform
    } = this;

    if (!this.settings.logger.disableRoutesSummary && !this.disableBootstrapLog) {
      logger.info("Routes mounted :");
      logger.info(printRoutes(await this.injector.alterAsync("$logRoutes", platform.getRoutes())));
    }
  }

  async loadRoutes() {
    var _this$settings$accept;

    // istanbul ignore next
    if (this.settings.logger.level !== "off") {
      this.app.use(exports.PlatformLogMiddleware);
    }

    if ((_this$settings$accept = this.settings.acceptMimes) != null && _this$settings$accept.length) {
      this.app.use(exports.GlobalAcceptMimesMiddleware);
    }

    this.log("Load routes");
    await this.callHook("$beforeRoutesInit");
    await this.callHook("$$loadRoutes");
    await this.callHook("$onRoutesInit");
    await this.loadStatics();
    await this.callHook("$afterRoutesInit");
  }

  createInjector(module, settings) {
    const configuration = di.getConfiguration(module, settings);
    _classPrivateFieldLooseBase(this, _injector)[_injector] = createInjector(configuration); // configure locals providers

    this.locals.forEach(provider => {
      this.injector.addProvider(provider.token, provider);
    });
    createPlatformApplication(this.injector);
    createHttpsServer(this.injector);
    createHttpServer(this.injector);
  }

  createRootModule(module) {
    _classPrivateFieldLooseBase(this, _rootModule)[_rootModule] = this.injector.invoke(module);
    this.injector.delete(core.constructorOf(_classPrivateFieldLooseBase(this, _rootModule)[_rootModule]));
    this.injector.delete(core.classOf(_classPrivateFieldLooseBase(this, _rootModule)[_rootModule]));
  }

}

/**
 * Define multer option for all MultipartFile
 *
 * ```typescript
 * import {Controller, Post, PlatformMulterFile, MultipartFile, MulterOptions} from "@tsed/common";
 *
 * @Controller('/')
 * class MyCtrl {
 *   @Post('/file')
 *   private uploadFile(@MultipartFile("file1") file: PlatformMulterFile) {
 *
 *   }
 *
 *   @Post('/file')
 *   @MulterOptions({dest: "/other-dir"})
 *   private uploadFile(@MultipartFile("file1") file: PlatformMulterFile) {
 *
 *   }
 *
 *   @Post('/file2')
 *   @MulterOptions({dest: "/other-dir"})
 *   private uploadFile(@MultipartFile("file1") file: PlatformMulterFile, @MultipartFile("file2") file2: PlatformMulterFile) {
 *
 *   }
 *
 *   @Post('/files')
 *   private uploadFile(@MultipartFile("file1") files: PlatformMulterFile[]) {
 *
 *   }
 * }
 * ```
 *
 * See the tutorial on the [multer configuration](/tutorials/multer.md).
 *
 * @param {multer.Options} options
 * @returns {(target: any, propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor}
 * @decorator
 * @multer
 */

function MulterOptions(options) {
  return (target, propertyKey, descriptor) => {
    core.StoreMerge(exports.PlatformMulterMiddleware, {
      options
    })(target, propertyKey, descriptor);
    return descriptor;
  };
}

/**
 * Define file size limit.
 *
 * ```typescript
 * import {Controller, Post} from "@tsed/common";
 * import {MulterOptions, MultipartFile} from "@tsed/common";
 * import {Multer} from "@types/multer";
 *
 * type MulterFile = Express.Multer.File;
 *
 * @Controller('/')
 * class MyCtrl {
 *   @Post('/file2')
 *   @MulterFileSize(1024) // (Ko). Applied for all fields
 *   private uploadFile(@MultipartFile("file1") file: MulterFile, @MultipartFile("file2") file2: MulterFile) {
 *
 *   }
 * }
 * ```
 *
 * > See the tutorial on the [multer configuration](/tutorials/multer.md).
 * @param fileSize
 * @returns {(target: any, propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor}
 * @decorator
 * @multer
 */

function MulterFileSize(fileSize) {
  return MulterOptions({
    limits: {
      fileSize
    }
  });
}

function mapOptions$1(name, maxCount) {
  return {
    fields: [{
      name,
      maxCount
    }]
  };
}
/**
 * Define a parameter as Multipart file.
 *
 * ```typescript
 * import {Controller, Post} from "@tsed/common";
 * import {MulterOptions, MultipartFile} from "@tsed/common";
 * import {Multer} from "@types/multer";
 *
 * type MulterFile = Express.Multer.File;
 *
 * @Controller('/')
 * class MyCtrl {
 *   @Post('/file')
 *   private uploadFile(@MultipartFile("file1") file: MulterFile) {
 *
 *   }
 *
 *   @Post('/file')
 *   @MulterOptions({dest: "/other-dir"})
 *   private uploadFile(@MultipartFile("file1") file: MulterFile) {
 *
 *   }
 *
 *   @Post('/file2')
 *   @MulterOptions({dest: "/other-dir"})
 *   private uploadFile(@MultipartFile("file1") file: MulterFile, @MultipartFile("file2") file2: MulterFile) {
 *
 *   }
 *
 *   @Post('/files')
 *   private uploadFile(@MultipartFile("file1") files: MulterFile[]) {
 *
 *   }
 * }
 * ```
 *
 * > See the tutorial on the [multer configuration](/tutorials/multer.md).
 *
 * @param name
 * @param maxCount
 * @returns Function
 * @decorator
 * @input
 */


function MultipartFile(name, maxCount) {
  return (...args) => {
    const [target, propertyKey, index] = args;
    const multiple = core.Metadata.getParamTypes(target, propertyKey)[index] === Array;
    name = typeof name === "object" ? undefined : name;
    const expression = [name, !multiple && "0"].filter(Boolean).join(".");
    const decorators = core.useDecorators(core.useMethodDecorators(schema.Returns(400).Description(`<File too long | Too many parts | Too many files | Field name too long | Field value too long | Too many fields | Unexpected field>  [fieldName] Example: File too long file1`), schema.Consumes("multipart/form-data"), core.StoreMerge(exports.PlatformMulterMiddleware, mapOptions$1(name, maxCount))), platformParams.UseParam({
      paramType: platformParams.ParamTypes.FILES,
      dataPath: "$ctx.request.files",
      expression,
      useValidation: true
    }));
    decorators(...args);
  };
}

/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping global logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function All(path = "/", ...args) {
  return platformMiddlewares.Use(...["all", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping global logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Get(path = "/", ...args) {
  return platformMiddlewares.Use(...["get", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping global logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Post(path = "/", ...args) {
  return platformMiddlewares.Use(...["post", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping global logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Put(path = "/", ...args) {
  return platformMiddlewares.Use(...["put", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping global logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Delete(path = "/", ...args) {
  return platformMiddlewares.Use(...["delete", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping global logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Head(path = "/", ...args) {
  return platformMiddlewares.Use(...["head", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping global logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Patch(path = "/", ...args) {
  return platformMiddlewares.Use(...["patch", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping global logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Options(path = "/", ...args) {
  return platformMiddlewares.Use(...["options", path].concat(args));
}

/**
 *
 * @param fn
 * @decorator
 */

function EndpointFn(fn) {
  return schema.JsonEntityFn(fn);
}

/**
 * Set a mime list which are acceptable and checks if the specified content types are acceptable, based on the requests Accept HTTP header field.
 *
 * ```typescript
 *  @Controller('/mypath')
 *  export class MyCtrl {
 *
 *    @Get('/')
 *    @AcceptMime('application/json')
 *    public getResource(){}
 *  }
 * ```
 *
 * @param mimes
 * @decorator
 * @operation
 * @response
 */

function AcceptMime(...mimes) {
  return core.useDecorators(schema.Produces(...mimes), EndpointFn(endpoint => {
    endpoint.acceptMimes = mimes;
  }));
}

/**
 * Sets the response Location HTTP header to the specified path parameter.
 *
 * ```typescript
 *  @Location('/foo/bar')
 *  @Location('http://example.com')
 *  @Location('back')
 *  private myMethod() {
 *
 *  }
 * ```
 *
 * A path value of back has a special meaning, it refers to the URL specified in the `Referer` header of the request. If the `Referer` header was not specified, it refers to /.
 *
 * @param location
 * @returns {Function}
 * @decorator
 * @operation
 */

function Location(location) {
  return EndpointFn(endpoint => {
    endpoint.location = location;
  });
}

function Redirect(status, url) {
  url = !url ? status : url;
  status = typeof status === "number" ? status : 302;
  return core.useDecorators(schema.Status(status), EndpointFn(endpoint => {
    endpoint.redirect = {
      status: +status,
      url: url
    };
  }));
}

const _excluded$1 = ["children"];

function mapOptions(options) {
  if (typeof options === "string" || options instanceof RegExp || core.isArrayOrArrayClass(options)) {
    return {
      path: options
    };
  }

  return options;
}
/**
 * Declare a new controller with his Rest path. His methods annotated will be collected to build the routing list.
 * This routing listing will be built with the `express.Router` object.
 *
 * ::: tip
 * See [Controllers](/docs/controllers.md) section for more details
 * :::
 *
 * ```typescript
 *  @Controller("/calendars")
 *  export provide CalendarCtrl {
 *
 *    @Get("/:id")
 *    public get(
 *      @Req() request: Req,
 *      @Res() response: Res,
 *      @Next() next: Next
 *    ): void {
 *
 *    }
 *  }
 * ```
 *
 * @param options
 * @controller
 * @decorator
 * @classDecorator
 */


function Controller(options) {
  const _mapOptions = mapOptions(options),
        {
    children = []
  } = _mapOptions,
        opts = _objectWithoutPropertiesLoose(_mapOptions, _excluded$1);

  return target => {
    di.registerController(_extends({
      provide: target
    }, opts));
    core.Store.from(target).set("childrenControllers", children);
    children.forEach(childToken => {
      core.Store.from(childToken).set("parentController", target);
    });
  };
}

/**
 * Return the current response data. Prefer the @@Context@@ decorator to get or set data.
 *
 * @decorator
 * @operation
 * @input
 * @deprecated Use `@Context() $ctx: Context` then $ctx.data.
 */

function ResponseData() {
  return platformParams.UseParam({
    paramType: platformParams.ParamTypes.$CTX,
    dataPath: "$ctx.data"
  });
}

function getParamType$1(target, propertyKey, parameterIndex) {
  const type = core.Metadata.getOwnParamTypes(target, propertyKey)[parameterIndex];

  if (core.isClass(type)) {
    if (core.nameOf(type) === "PlatformResponse") {
      return {
        paramType: platformParams.ParamTypes.PLATFORM_RESPONSE,
        dataPath: "$ctx.response"
      };
    }

    if (type === Http.ServerResponse) {
      return {
        paramType: platformParams.ParamTypes.NODE_RESPONSE,
        dataPath: "$ctx.response.res"
      };
    }
  }

  return {
    paramType: platformParams.ParamTypes.RESPONSE,
    dataPath: "$ctx.response.response"
  };
}

function Response() {
  return Res();
}
function Res() {
  return (target, propertyKey, parameterIndex) => {
    const {
      paramType,
      dataPath
    } = getParamType$1(target, propertyKey, parameterIndex);
    platformParams.UseParam({
      paramType,
      dataPath
    })(target, propertyKey, parameterIndex);
  };
}

function getParamType(target, propertyKey, parameterIndex) {
  const type = core.Metadata.getOwnParamTypes(target, propertyKey)[parameterIndex];

  if (core.isClass(type)) {
    if (core.nameOf(type) === "PlatformRequest") {
      return {
        paramType: platformParams.ParamTypes.PLATFORM_REQUEST,
        dataPath: "$ctx.request"
      };
    }

    if (type === Http.IncomingMessage) {
      return {
        paramType: platformParams.ParamTypes.NODE_REQUEST,
        dataPath: "$ctx.request.req"
      };
    }
  }

  return {
    paramType: platformParams.ParamTypes.REQUEST,
    dataPath: "$ctx.request.request"
  };
}

function Request(...args) {
  // @ts-ignore
  return Req(...args);
}
function Req(...args) {
  const {
    expression,
    useType,
    useConverter = false,
    useValidation = false
  } = platformParams.mapParamsOptions(args);
  return (target, propertyKey, parameterIndex) => {
    const {
      paramType,
      dataPath
    } = getParamType(target, propertyKey, parameterIndex);
    platformParams.UseParam({
      paramType,
      dataPath,
      expression,
      useType,
      useConverter,
      useValidation
    })(target, propertyKey, parameterIndex);
  };
}

/**
 * Get the Next function (for express application and middleware).
 *
 * @decorator
 * @operation
 * @input
 */

function Next() {
  return platformParams.UseParam({
    paramType: platformParams.ParamTypes.NEXT_FN,
    dataPath: "next",
    useConverter: false,
    useValidation: false
  });
}

/**
 * @returns {Function}
 * @decorator
 * @operation
 * @input
 */

function Err() {
  return platformParams.UseParam({
    paramType: platformParams.ParamTypes.ERR,
    dataPath: "err",
    useValidation: false,
    useConverter: false
  });
}

/**
 * Get the current endpoint metadata.
 * @decorator
 * @operation
 * @input
 * @deprecated Use `@Context() $ctx: Context` then `$ctx.endpoint` instead.
 */

function EndpointInfo() {
  return platformParams.UseParam({
    paramType: platformParams.ParamTypes.$CTX,
    dataPath: "$ctx.endpoint",
    useConverter: false,
    useValidation: false
  });
}

const _excluded = ["use", "collection"];

/**
 * @ignore
 */
function mapReturnedResponse(_ref) {
  let {
    use,
    collection
  } = _ref,
      options = _objectWithoutPropertiesLoose(_ref, _excluded);

  return _extends({}, options, {
    type: options.type || use,
    collectionType: options.collectionType || collection
  });
}

/**
 * @platform
 */

class PlatformTest extends di.DITest {
  static async create(options = {}) {
    di.DITest.injector = PlatformTest.createInjector(options);
    const container = di.createContainer();
    await di.DITest.injector.load(container, exports.PlatformModule);
  }
  /**
   * Create a new injector with the right default services
   */


  static createInjector(settings = {}) {
    return createInjector(di.DITest.configure(settings));
  }
  /**
   * Load the server silently without listening port and configure it on test profile.
   * @decorator
   * @param mod
   * @param settings
   * @returns {Promise<void>}
   */


  static bootstrap(mod, settings = {}) {
    return async function before() {
      let instance;
      const platform = settings.platform || PlatformTest.platformBuilder;
      /* istanbul ignore next */

      if (!platform) {
        throw new Error("Platform type is not specified. Have you added at least `import @tsed/platform-express` (or equivalent) on your Server.ts ?");
      } // @ts-ignore


      instance = await PlatformBuilder.build(platform).bootstrap(mod, di.DITest.configure(settings));

      if (!settings.listen) {
        await instance.callHook("$beforeListen");
        await instance.callHook("$afterListen");
        await instance.ready();
      } else {
        await instance.listen();
      } // used by inject method


      di.DITest.injector = instance.injector;
    };
  }
  /**
   * It injects services into the test function where you can alter, spy on, and manipulate them.
   *
   * The inject function has two parameters
   *
   * * an array of Service dependency injection tokens,
   * * a test function whose parameters correspond exactly to each item in the injection token array.
   *
   * @param targets
   * @param func
   */


  static inject(targets, func) {
    return async () => {
      if (!di.DITest.hasInjector()) {
        await PlatformTest.create();
      }

      const injector = di.DITest.injector;
      const deps = [];

      for (const target of targets) {
        deps.push(injector.has(target) ? injector.get(target) : await injector.invoke(target));
      }

      return await func(...deps);
    };
  }
  /**
   * Return the raw application (express or koa).
   * Use this callback with SuperTest.
   *
   * ```typescript
   * let request: SuperTest.SuperTest<SuperTest.Test>;
   * beforeEach(PlatformTest.bootstrap(Server, {
   *   mount: {
   *     "/rest": [ProductsController]
   *   }
   * }));
   * beforeEach(() => {
   *   request = SuperTest(PlatformTest.callback());
   * });
   * ```
   */


  static callback() {
    var _DITest$injector$get;

    return (_DITest$injector$get = di.DITest.injector.get(exports.PlatformApplication)) == null ? void 0 : _DITest$injector$get.callback();
  }

  static createRequestContext(options = {}) {
    options.request = options.request || new exports.PlatformRequest({});
    options.response = options.response || new exports.PlatformResponse({});
    return new PlatformContext(_extends({
      id: "id",
      injector: di.DITest.injector,
      logger: di.DITest.injector.logger,
      url: "/"
    }, options));
  }

}

di.GlobalProviders.createRegistry(di.ProviderType.CONTROLLER, ControllerProvider, {
  injectable: false,

  onInvoke(provider, locals) {
    locals.set(exports.PlatformRouter, provider.getRouter());
  }

});

Object.defineProperty(exports, '$log', {
  enumerable: true,
  get: function () {
    return logger.$log;
  }
});
Object.defineProperty(exports, 'Logger', {
  enumerable: true,
  get: function () {
    return logger.Logger;
  }
});
exports.AcceptMime = AcceptMime;
exports.All = All;
exports.Controller = Controller;
exports.ControllerProvider = ControllerProvider;
exports.Delete = Delete;
exports.EndpointFn = EndpointFn;
exports.EndpointInfo = EndpointInfo;
exports.Err = Err;
exports.Get = Get;
exports.HandlerContext = HandlerContext;
exports.HandlerMetadata = HandlerMetadata;
exports.Head = Head;
exports.HttpServer = HttpServer;
exports.HttpsServer = HttpsServer;
exports.Location = Location;
exports.MulterFileSize = MulterFileSize;
exports.MulterOptions = MulterOptions;
exports.MultipartFile = MultipartFile;
exports.Next = Next;
exports.Options = Options;
exports.PLATFORM_ROUTER_OPTIONS = PLATFORM_ROUTER_OPTIONS;
exports.Patch = Patch;
exports.PlatformBuilder = PlatformBuilder;
exports.PlatformContext = PlatformContext;
exports.PlatformControllerBuilder = PlatformControllerBuilder;
exports.PlatformRouteDetails = PlatformRouteDetails;
exports.PlatformTest = PlatformTest;
exports.Post = Post;
exports.Put = Put;
exports.ROUTER_OPTIONS = ROUTER_OPTIONS;
exports.Redirect = Redirect;
exports.Req = Req;
exports.Request = Request;
exports.Res = Res;
exports.Response = Response;
exports.ResponseData = ResponseData;
exports.bindEndpointMiddleware = bindEndpointMiddleware;
exports.createContext = createContext;
exports.createHttpServer = createHttpServer;
exports.createHttpsServer = createHttpsServer;
exports.createInjector = createInjector;
exports.createPlatformApplication = createPlatformApplication;
exports.listenHttpServer = listenHttpServer;
exports.listenHttpsServer = listenHttpsServer;
exports.listenServer = listenServer;
exports.loadInjector = loadInjector;
exports.mapReturnedResponse = mapReturnedResponse;
exports.printRoutes = printRoutes;
exports.useCtxHandler = useCtxHandler;
Object.keys(di).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return di[k];
    }
  });
});
Object.keys(platformParams).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return platformParams[k];
    }
  });
});
Object.keys(platformExceptions).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return platformExceptions[k];
    }
  });
});
Object.keys(platformResponseFilter).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return platformResponseFilter[k];
    }
  });
});
Object.keys(platformCache).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return platformCache[k];
    }
  });
});
Object.keys(platformMiddlewares).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return platformMiddlewares[k];
    }
  });
});
Object.keys(platformViews).forEach(function (k) {
  if (k !== 'default' && !exports.hasOwnProperty(k)) Object.defineProperty(exports, k, {
    enumerable: true,
    get: function () {
      return platformViews[k];
    }
  });
});
//# sourceMappingURL=index.js.map
