import { DIConfiguration, ProviderType, ProviderScope, Injectable, InjectorService, Configuration, Inject, Constant, Scope, Opts, DIContext, Provider, Module, setLoggerLevel, GlobalProviders, registerProvider, createContainer, Container, importProviders, getConfiguration, registerController, DITest } from '@tsed/di';
export * from '@tsed/di';
import { Context, ParamTypes, ParamMetadata, PlatformParams, UseParam, mapParamsOptions } from '@tsed/platform-params';
export * from '@tsed/platform-params';
export * from '@tsed/platform-exceptions';
import { PlatformResponseFilter } from '@tsed/platform-response-filter';
export * from '@tsed/platform-response-filter';
export * from '@tsed/platform-cache';
import { Middleware, getMiddlewaresForHook, Use } from '@tsed/platform-middlewares';
export * from '@tsed/platform-middlewares';
import { renderView, PlatformViews } from '@tsed/platform-views';
export * from '@tsed/platform-views';
import { $log, colorize } from '@tsed/logger';
export { $log, Logger } from '@tsed/logger';
import { __decorate, __metadata, __param } from 'tslib';
import { Env, isObservable, isStream, isPromise, nameOf, Store, descriptorOf, classOf, prototypeOf, deepMerge, isFunction, Enumerable, DecoratorTypes, isBoolean, isNumber, isString, uniq, NotEnumerable, toMap, constructorOf, StoreMerge, Metadata, useDecorators, useMethodDecorators, isArrayOrArrayClass, isClass } from '@tsed/core';
import { PerfLogger } from '@tsed/perf';
import { Exception, NotAcceptable } from '@tsed/exceptions';
import { JsonEntityStore, getOperationsStores, JsonEntityComponent, OperationMethods, getProperties, Returns, Consumes, JsonEntityFn, Produces, Status } from '@tsed/schema';
import { serialize, deserialize } from '@tsed/json-mapper';
import { promisify } from 'util';
import Http, { ServerResponse, IncomingMessage } from 'http';
import Https from 'https';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var id = 0;

function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}

function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }

  return receiver;
}

var PlatformConfiguration_1;
const rootDir = process.cwd();
/**
 * `PlatformConfiguration` contains all information about your Server configuration.
 */

let PlatformConfiguration = PlatformConfiguration_1 = class PlatformConfiguration extends DIConfiguration {
  constructor() {
    super({
      rootDir,
      env: process.env.NODE_ENV || Env.DEV,
      httpPort: 8080,
      httpsPort: false,
      scopes: {
        [ProviderType.CONTROLLER]: ProviderScope.SINGLETON
      },
      logger: {
        debug: false,
        level: "info",
        logRequest: true,
        jsonIndentation: process.env.NODE_ENV === Env.PROD ? 0 : 2
      },
      errors: {
        headerName: "errors"
      },
      mount: {
        "/rest": "${rootDir}/controllers/**/*.ts"
      },
      exclude: ["**/*.spec.ts", "**/*.spec.js"],
      componentsScan: ["${rootDir}/mvc/**/*.ts", "${rootDir}/services/**/*.ts", "${rootDir}/middlewares/**/*.ts"]
    });
  }

  get version() {
    return this.getRaw("version");
  }

  set version(v) {
    this.setRaw("version", v);
  }

  get rootDir() {
    return this.getRaw("rootDir");
  }

  set rootDir(value) {
    this.setRaw("rootDir", value);
  }

  get port() {
    return this.httpPort;
  }

  set port(value) {
    this.httpPort = value;
  }

  get httpsOptions() {
    return this.getRaw("httpsOptions");
  }

  set httpsOptions(value) {
    this.setRaw("httpsOptions", value);
  }

  get httpPort() {
    return this.getRaw("httpPort");
  }

  set httpPort(value) {
    this.setRaw("httpPort", value);
  }

  get httpsPort() {
    return this.getRaw("httpsPort");
  }

  set httpsPort(value) {
    this.setRaw("httpsPort", value);
  }

  get env() {
    return this.getRaw("env");
  }

  set env(value) {
    this.setRaw("env", value);
  }

  get mount() {
    return this.get("mount");
  }

  set mount(value) {
    this.setRaw("mount", value);
  }

  get componentsScan() {
    return this.resolve(this.getRaw("componentsScan"));
  }

  set componentsScan(value) {
    this.setRaw("componentsScan", value);
  }

  get statics() {
    return this.getRaw("statics") || this.getRaw("serveStatic") || {};
  }

  set statics(value) {
    this.setRaw("statics", value);
  }

  get acceptMimes() {
    return this.getRaw("acceptMimes");
  }

  set acceptMimes(value) {
    this.setRaw("acceptMimes", value || []);
  }

  get debug() {
    return this.logger.level === "debug";
  }

  set debug(debug) {
    this.logger = _extends({}, this.logger, {
      level: debug ? "debug" : "info"
    });
  }

  get converter() {
    return this.get("converter") || {};
  }

  set converter(options) {
    this.setRaw("converter", options);
  }

  get logger() {
    return this.get("logger");
  }

  set logger(value) {
    const logger = _extends({}, this.logger, value);

    logger.debug = logger.level === "debug";
    this.setRaw("logger", logger);
    this.setRaw("debug", logger.debug);

    if (logger.format) {
      $log.appenders.set("stdout", {
        type: "stdout",
        levels: ["info", "debug"],
        layout: {
          type: "pattern",
          pattern: logger.format
        }
      });
      $log.appenders.set("stderr", {
        levels: ["trace", "fatal", "error", "warn"],
        type: "stderr",
        layout: {
          type: "pattern",
          pattern: logger.format
        }
      });
    }
  }

  get exclude() {
    return this.get("exclude");
  }

  set exclude(exclude) {
    this.setRaw("exclude", exclude);
  }
  /**
   *
   * @param addressPort
   * @returns {{address: string, port: number}}
   */


  static buildAddressAndPort(addressPort) {
    let address = "0.0.0.0";
    let port = addressPort;

    if (typeof addressPort === "string" && addressPort.indexOf(":") > -1) {
      [address, port] = addressPort.split(":");
      port = +port;
    }

    return {
      address,
      port: port
    };
  }
  /**
   *
   * @returns {string|number}
   */


  getHttpPort() {
    return PlatformConfiguration_1.buildAddressAndPort(this.getRaw("httpPort"));
  }
  /**
   *
   * @param settings
   */


  setHttpPort(settings) {
    this.setRaw("httpPort", `${settings.address}:${settings.port}`);
  }
  /**
   *
   * @returns {string|number}
   */


  getHttpsPort() {
    return PlatformConfiguration_1.buildAddressAndPort(this.getRaw("httpsPort"));
  }
  /**
   *
   * @param settings
   */


  setHttpsPort(settings) {
    this.setRaw("httpsPort", `${settings.address}:${settings.port}`);
  }

};
PlatformConfiguration = PlatformConfiguration_1 = __decorate([Injectable({
  scope: ProviderScope.SINGLETON,
  global: true
}), __metadata("design:paramtypes", [])], PlatformConfiguration);

/**
 * @ignore
 */
function bindEndpointMiddleware(endpoint) {
  return ctx => {
    ctx.endpoint = endpoint;
  };
}

var PlatformLogMiddleware_1;
/**
 * @middleware
 * @platform
 */

let PlatformLogMiddleware = PlatformLogMiddleware_1 = class PlatformLogMiddleware {
  // tslint:disable-next-line: no-unused-variable
  constructor(injector) {
    this.settings = injector.settings.logger || {};
    this.settings.requestFields = this.settings.requestFields || PlatformLogMiddleware_1.DEFAULT_FIELDS;

    if (this.settings.level !== "off") {
      this.$onResponse = this.onLogEnd.bind(this);
    }
  }
  /**
   * Handle the request.
   */


  use(ctx) {
    this.configureRequest(ctx);
    this.onLogStart(ctx);
  }
  /**
   * The separate onLogStart() function will allow developer to overwrite the initial request log.
   * @param ctx
   */


  onLogStart(ctx) {
    const {
      debug,
      logRequest,
      logStart
    } = this.settings;

    if (logStart !== false) {
      if (debug) {
        ctx.logger.debug({
          event: "request.start"
        });
      } else if (logRequest) {
        ctx.logger.info({
          event: "request.start"
        });
      }
    }
  }
  /**
   * Called when the `$onResponse` is called by Ts.ED (through Express.end).
   */


  onLogEnd(ctx) {
    const {
      debug,
      logRequest,
      logEnd
    } = this.settings;

    if (logEnd !== false) {
      if (debug) {
        ctx.logger.debug({
          event: "request.end",
          status: ctx.response.statusCode,
          data: ctx.data
        });
      } else if (logRequest) {
        ctx.logger.info({
          event: "request.end",
          status: ctx.response.statusCode
        });
      }
    }

    ctx.logger.flush();
  }
  /**
   * Attach all information that will be necessary to log the request. Attach a new `request.log` object.
   */


  configureRequest(ctx) {
    ctx.logger.minimalRequestPicker = obj => _extends({}, this.minimalRequestPicker(ctx), obj);

    ctx.logger.completeRequestPicker = obj => _extends({}, this.requestToObject(ctx), obj);
  }
  /**
   * Return complete request info.
   * @returns {Object}
   * @param ctx
   */


  requestToObject(ctx) {
    const {
      request
    } = ctx;
    return {
      method: request.method,
      url: request.url,
      headers: request.headers,
      body: request.body,
      query: request.query,
      params: request.params
    };
  }
  /**
   * Return a filtered request from global configuration.
   * @returns {Object}
   * @param ctx
   */


  minimalRequestPicker(ctx) {
    const {
      requestFields
    } = this.settings;
    const info = this.requestToObject(ctx);
    return requestFields.reduce((acc, key) => {
      acc[key] = info[key];
      return acc;
    }, {});
  }

};
PlatformLogMiddleware.DEFAULT_FIELDS = ["reqId", "method", "url", "duration"];

__decorate([__param(0, Context()), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", void 0)], PlatformLogMiddleware.prototype, "use", null);

PlatformLogMiddleware = PlatformLogMiddleware_1 = __decorate([Middleware(), __metadata("design:paramtypes", [InjectorService])], PlatformLogMiddleware);

/**
 * @ignore
 */
const createFakeRawDriver = () => {
  // istanbul ignore next
  function FakeRawDriver() {} // istanbul ignore next


  function use() {
    return this;
  }

  FakeRawDriver.use = use;
  FakeRawDriver.all = use;
  FakeRawDriver.get = use;
  FakeRawDriver.patch = use;
  FakeRawDriver.post = use;
  FakeRawDriver.put = use;
  FakeRawDriver.head = use;
  FakeRawDriver.delete = use;
  FakeRawDriver.options = use;
  return FakeRawDriver;
};

/**
 * @ignore
 */

function isResponse(obj) {
  return obj.data && obj.headers && obj.status && obj.statusText;
}
/**
 * @ignore
 */


var HandlerContextStatus;

(function (HandlerContextStatus) {
  HandlerContextStatus["PENDING"] = "pending";
  HandlerContextStatus["CANCELED"] = "canceled";
  HandlerContextStatus["RESOLVED"] = "resolved";
  HandlerContextStatus["REJECTED"] = "rejected";
})(HandlerContextStatus || (HandlerContextStatus = {}));

var _resolves = /*#__PURE__*/_classPrivateFieldLooseKey("resolves");

var _rejects = /*#__PURE__*/_classPrivateFieldLooseKey("rejects");

var _promise = /*#__PURE__*/_classPrivateFieldLooseKey("promise");

class HandlerContext {
  constructor({
    $ctx,
    err,
    metadata,
    args
  }) {
    Object.defineProperty(this, _resolves, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _rejects, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _promise, {
      writable: true,
      value: void 0
    });
    this.status = HandlerContextStatus.PENDING;
    this.$ctx = $ctx;
    _classPrivateFieldLooseBase(this, _promise)[_promise] = new Promise((resolve, reject) => {
      _classPrivateFieldLooseBase(this, _resolves)[_resolves] = resolve;
      _classPrivateFieldLooseBase(this, _rejects)[_rejects] = reject;
    });
    err && (this.err = err);
    metadata && (this.metadata = metadata);
    args && (this.args = args || []);
    this.next = this.next.bind(this);
  }

  get request() {
    var _this$$ctx;

    return (_this$$ctx = this.$ctx) == null ? void 0 : _this$$ctx.getRequest();
  }

  get response() {
    var _this$$ctx2;

    return (_this$$ctx2 = this.$ctx) == null ? void 0 : _this$$ctx2.getResponse();
  }

  get isDone() {
    const {
      $ctx
    } = this;

    if (!$ctx || $ctx.isDone()) {
      return true;
    }

    if ($ctx.request.isAborted() || $ctx.response.isDone()) {
      this.destroy();

      if (this.status === HandlerContextStatus.PENDING) {
        this.status = HandlerContextStatus.RESOLVED;
      }
    }

    return this.status !== HandlerContextStatus.PENDING;
  }

  get handler() {
    const {
      metadata
    } = this;

    if (metadata.handler) {
      return metadata.handler;
    }

    if (this.metadata.scope === ProviderScope.SINGLETON) {
      if (!this.$ctx.injector.has(metadata.token)) {
        this.$ctx.injector.invoke(metadata.token);
      }

      const _instance = this.$ctx.injector.get(metadata.token);

      metadata.handler = _instance[metadata.propertyKey].bind(_instance);
      return metadata.handler;
    }

    const instance = this.$ctx.injector.invoke(metadata.token, this.$ctx.container);
    return instance[metadata.propertyKey].bind(instance);
  }
  /**
   *
   */


  async callHandler() {
    if (this.isDone) {
      return this;
    }

    try {
      this.handle(this.handler(...this.args, this.$ctx));
    } catch (er) {
      this.reject(er);
    }

    return _classPrivateFieldLooseBase(this, _promise)[_promise];
  }

  reject(er) {
    if (this.isDone) {
      return;
    }

    this.destroy();
    this.status = HandlerContextStatus.REJECTED;

    _classPrivateFieldLooseBase(this, _rejects)[_rejects](er);
  }

  resolve(data) {
    if (this.isDone) {
      return;
    }

    if (this.$ctx && data !== undefined) {
      this.$ctx.data = data;
    }

    this.destroy();
    this.status = HandlerContextStatus.RESOLVED;

    _classPrivateFieldLooseBase(this, _resolves)[_resolves](data);
  }

  next(error) {
    if (this.isDone) {
      return;
    }

    return error ? this.reject(error) : this.resolve();
  }

  destroy() {
    // @ts-ignore
    delete this.$ctx; // @ts-ignore

    delete this.args; // @ts-ignore

    delete this.metadata; // @ts-ignore

    delete this.err;
  }

  cancel() {
    if (this.isDone) {
      return;
    }

    this.destroy();
    this.status = HandlerContextStatus.CANCELED;
    return _classPrivateFieldLooseBase(this, _resolves)[_resolves]();
  }

  handle(process) {
    if (this.isDone) {
      return;
    }

    const {
      metadata: {
        hasNextFunction
      },
      $ctx
    } = this;

    if (process) {
      if (process === $ctx.getResponse()) {
        // ABANDON
        return this.cancel();
      }

      if (isObservable(process)) {
        process = process.toPromise();
      }

      if (isResponse(process)) {
        $ctx.response.setHeaders(process.headers);
        $ctx.response.status(process.status);
        return this.handle(process.data);
      }

      if (isStream(process) || Buffer.isBuffer(process)) {
        return this.resolve(process);
      }

      if (isPromise(process)) {
        return process.then(result => this.handle(result)).catch(error => {
          if (error.response && isResponse(error.response)) {
            return this.handle(error.response);
          }

          return this.reject(error);
        });
      }
    }

    if (!hasNextFunction) {
      // no next function and empty response
      return this.resolve(process);
    }
  }

}

/**
 * @ignore
 */
var HandlerType;

(function (HandlerType) {
  HandlerType["CUSTOM"] = "custom";
  HandlerType["ENDPOINT"] = "endpoint";
  HandlerType["MIDDLEWARE"] = "middleware";
  HandlerType["ERR_MIDDLEWARE"] = "err:middleware";
  HandlerType["CTX_FN"] = "context";
  HandlerType["RAW_FN"] = "raw:middleware";
  HandlerType["RAW_ERR_FN"] = "raw:err:middleware";
})(HandlerType || (HandlerType = {}));

class HandlerMetadata {
  constructor(options) {
    this.injectable = false;
    this.type = HandlerType.RAW_FN;
    this.hasNextFunction = false;
    const {
      target,
      token,
      propertyKey,
      type,
      scope,
      routeOptions
    } = options;
    this.type = type || target.type || HandlerType.RAW_FN;
    this.scope = scope || ProviderScope.SINGLETON;
    this.routeOptions = routeOptions || {};
    const handler = propertyKey ? target.prototype[propertyKey] : target;

    if (propertyKey) {
      this.target = target;
      this.token = token;
      this.propertyKey = propertyKey;
      this.hasNextFunction = this.hasParamType(ParamTypes.NEXT_FN);

      if (this.hasParamType(ParamTypes.ERR)) {
        this.type = HandlerType.ERR_MIDDLEWARE;
      }

      this.injectable = ParamMetadata.getParams(target, propertyKey).length > 0;
    } else {
      this.handler = handler;
    }

    if (!this.injectable) {
      if (handler.length === 4) {
        this.type = HandlerType.RAW_ERR_FN;
      }

      this.hasNextFunction = handler.length >= 3;
    }
  }

  get hasErrorParam() {
    return this.type === HandlerType.ERR_MIDDLEWARE || this.type === HandlerType.RAW_ERR_FN;
  }

  get parameters() {
    return this.injectable ? this.getParams() : [];
  }

  getParams() {
    return ParamMetadata.getParams(this.target, this.propertyKey) || [];
  }

  hasParamType(paramType) {
    return this.getParams().findIndex(p => p.paramType === paramType) > -1;
  }

  isFinal() {
    var _this$routeOptions;

    return ((_this$routeOptions = this.routeOptions) == null ? void 0 : _this$routeOptions.isFinal) || false;
  }

  toString() {
    return [this.target && nameOf(this.target), this.propertyKey].filter(Boolean).join(".");
  }

}

var EndpointMetadata_1;
/**
 * EndpointMetadata contains metadata about a controller and his method.
 * Each annotation (@Get, @Body...) attached to a method are stored in a endpoint.
 * EndpointMetadata convert this metadata to an array which contain arguments to call an Express method.
 *
 * Example :
 *
 *    @Controller("/my-path")
 *    provide MyClass {
 *
 *        @Get("/")
 *        @Authenticated()
 *        public myMethod(){}
 *    }
 *
 */

let EndpointMetadata = EndpointMetadata_1 = class EndpointMetadata extends JsonEntityStore {
  constructor(options) {
    super(_extends({
      store: Store.fromMethod(options.target, options.propertyKey),
      descriptor: descriptorOf(options.target, options.propertyKey)
    }, options)); // LIFECYCLE

    this.beforeMiddlewares = [];
    this.middlewares = [];
    this.afterMiddlewares = [];
    this.statusCode = 200;
    const {
      beforeMiddlewares = [],
      middlewares = [],
      afterMiddlewares = []
    } = options;
    this.after(afterMiddlewares);
    this.before(beforeMiddlewares);
    this.use(middlewares);
  }

  get targetName() {
    return nameOf(this.token);
  }

  get params() {
    return Array.from(this.children.values());
  }
  /**
   * Return the JsonOperation
   */


  get operation() {
    return this._operation;
  }

  get operationPaths() {
    return this.operation.operationPaths;
  }

  get view() {
    return this.store.get("view");
  }

  set view(view) {
    this.store.set("view", view);
  }

  get location() {
    return this.store.get("location");
  }

  set location(url) {
    this.store.set("location", url);
  }

  get acceptMimes() {
    return this.store.get("acceptMimes", []);
  }

  set acceptMimes(mimes) {
    this.store.set("acceptMimes", mimes);
  }

  get redirect() {
    return this.store.get("redirect");
  }

  set redirect(options) {
    this.store.set("redirect", _extends({
      status: 302
    }, options));
  }
  /**
   * Get all endpoints from a given class and his parents.
   * @param {Type<any>} target
   * @returns {EndpointMetadata[]}
   */


  static getEndpoints(target) {
    const operations = getOperationsStores(target);
    return Array.from(operations.values()).map(endpoint => {
      endpoint = endpoint.clone();
      endpoint.token = classOf(target);
      return endpoint;
    });
  }
  /**
   * Get an endpoint.
   * @param target
   * @param propertyKey
   * @param descriptor
   */


  static get(target, propertyKey, descriptor) {
    descriptor = descriptor || descriptorOf(prototypeOf(target), propertyKey);
    return JsonEntityStore.from(prototypeOf(target), propertyKey, descriptor);
  }

  addOperationPath(method, path, options = {}) {
    return this.operation.addOperationPath(method, path, options);
  }
  /**
   * Find the a value at the controller level. Let this value be extended or overridden by the endpoint itself.
   *
   * @param key
   * @returns {any}
   */


  get(key) {
    const ctrlValue = Store.from(this.target).get(key);
    return deepMerge(ctrlValue, this.store.get(key));
  }
  /**
   * Append middlewares to the beforeMiddlewares list.
   * @param args
   * @returns {EndpointMetadata}
   */


  before(args) {
    this.beforeMiddlewares = this.beforeMiddlewares.concat(args).filter(isFunction);
    return this;
  }
  /**
   * Append middlewares to the afterMiddlewares list.
   * @param args
   * @returns {EndpointMetadata}
   */


  after(args) {
    this.afterMiddlewares = this.afterMiddlewares.concat(args).filter(isFunction);
    return this;
  }
  /**
   * Store all arguments collected via Annotation.
   * @param args
   */


  use(args) {
    this.middlewares = this.middlewares.concat(args).filter(isFunction);
    return this;
  }

  clone() {
    const endpoint = new EndpointMetadata_1(_extends({}, this, {
      target: this.target,
      propertyKey: this.propertyKey,
      descriptor: this.descriptor,
      store: this.store,
      children: this.children
    }));
    endpoint.collectionType = this.collectionType;
    endpoint._type = this._type;
    endpoint._operation = this.operation;
    endpoint._schema = this._schema;
    endpoint.middlewares = [...this.middlewares];
    endpoint.afterMiddlewares = [...this.afterMiddlewares];
    endpoint.beforeMiddlewares = [...this.beforeMiddlewares];
    return endpoint;
  }

};

__decorate([Enumerable(), __metadata("design:type", Array)], EndpointMetadata.prototype, "beforeMiddlewares", void 0);

__decorate([Enumerable(), __metadata("design:type", Array)], EndpointMetadata.prototype, "middlewares", void 0);

__decorate([Enumerable(), __metadata("design:type", Array)], EndpointMetadata.prototype, "afterMiddlewares", void 0);

__decorate([Enumerable(), __metadata("design:type", Number)], EndpointMetadata.prototype, "statusCode", void 0);

EndpointMetadata = EndpointMetadata_1 = __decorate([JsonEntityComponent(DecoratorTypes.METHOD), __metadata("design:paramtypes", [Object])], EndpointMetadata);

function isMetadata(input) {
  return input instanceof HandlerMetadata;
}
/**
 * @ignore
 */


function createHandlerMetadata(injector, obj, routeOptions = {}) {
  if (isMetadata(obj)) {
    return obj;
  }

  let options;

  if (obj instanceof EndpointMetadata) {
    const provider = injector.getProvider(obj.token);
    options = {
      token: provider.token,
      target: provider.useClass,
      scope: provider.scope,
      type: HandlerType.ENDPOINT,
      propertyKey: obj.propertyKey
    };
  } else {
    const provider = injector.getProvider(obj);

    if (provider) {
      options = {
        token: provider.token,
        target: provider.useClass,
        scope: provider.scope,
        type: HandlerType.MIDDLEWARE,
        propertyKey: "use"
      };
    } else {
      options = {
        target: obj
      };
    }
  }

  options.routeOptions = routeOptions;
  return new HandlerMetadata(options);
}

function toHeaders(headers) {
  return Object.entries(headers).reduce((headers, [key, item]) => {
    return _extends({}, headers, {
      [key]: String(item.example)
    });
  }, {});
}
/**
 * @ignore
 */


function setResponseHeaders(ctx) {
  const {
    response,
    endpoint
  } = ctx;
  const {
    operation
  } = endpoint;

  if (response.isDone()) {
    return;
  }

  if (!response.hasStatus()) {
    // apply status only if the isn't already modified
    response.status(operation.getStatus());
  }

  const headers = operation.getHeadersOf(response.statusCode);
  response.setHeaders(toHeaders(headers));

  if (endpoint.redirect) {
    response.redirect(endpoint.redirect.status || 302, endpoint.redirect.url);
  }

  if (endpoint.location) {
    response.location(endpoint.location);
  }
}

var _converterSettings;
let ConverterService = (_converterSettings = /*#__PURE__*/_classPrivateFieldLooseKey("converterSettings"), class ConverterService {
  constructor(injectorService, configuration) {
    Object.defineProperty(this, _converterSettings, {
      writable: true,
      value: void 0
    });
    this.injectorService = injectorService;
    _classPrivateFieldLooseBase(this, _converterSettings)[_converterSettings] = configuration.get("converter") || {};
  }

  /**
   * Convert instance to plainObject.
   *
   * @param obj
   * @param options
   */
  serialize(obj, options = {}) {
    return serialize(obj, _extends({
      useAlias: true,
      additionalProperties: _classPrivateFieldLooseBase(this, _converterSettings)[_converterSettings].additionalProperties === "accept"
    }, options));
  }
  /**
   * Convert a plainObject to targetType.
   *
   * ### Options
   *
   * - `ignoreCallback`: callback called for each object which will be deserialized. The callback can return a boolean to avoid the default converter behavior.
   * - `checkRequiredValue`: Disable the required check condition.
   *
   * @param obj Object source that will be deserialized
   * @param options Mapping options
   * @returns {any}
   */


  deserialize(obj, options = {}) {
    return deserialize(obj, _extends({
      useAlias: true,
      additionalProperties: _classPrivateFieldLooseBase(this, _converterSettings)[_converterSettings].additionalProperties === "accept"
    }, options));
  }

});
ConverterService = __decorate([Injectable(), __param(1, Configuration()), __metadata("design:paramtypes", [InjectorService, Object])], ConverterService);

function shouldBeSent(data) {
  return Buffer.isBuffer(data) || isBoolean(data) || isNumber(data) || isString(data) || data === null;
}

function shouldBeSerialized(data) {
  return !(isStream(data) || shouldBeSent(data) || data === undefined);
}
/**
 * Platform Handler abstraction layer. Wrap original class method to a pure platform handler (Express, Koa, etc...).
 * @platform
 */


let PlatformHandler = class PlatformHandler {
  constructor(injector, params) {
    this.injector = injector;
    this.params = params;
  }
  /**
   * Create a native middleware based on the given metadata and return an instance of HandlerContext
   * @param input
   * @param options
   */


  createHandler(input, options = {}) {
    const metadata = this.createHandlerMetadata(input, options);
    this.buildPipe(metadata);
    return this.createRawHandler(metadata);
  }

  createCustomHandler(provider, propertyKey) {
    const metadata = new HandlerMetadata({
      token: provider.provide,
      target: provider.useClass,
      type: HandlerType.CUSTOM,
      scope: provider.scope,
      propertyKey
    });
    this.buildPipe(metadata);
    return this.createRawHandler(metadata);
  }
  /**
   * Create handler metadata
   * @param obj
   * @param routeOptions
   */


  createHandlerMetadata(obj, routeOptions = {}) {
    return createHandlerMetadata(this.injector, obj, routeOptions);
  }
  /**
   * Send the response to the consumer.
   * @param data
   * @param ctx
   * @protected
   */


  async flush(data, ctx) {
    const {
      response,
      endpoint
    } = ctx;

    if (endpoint) {
      if (endpoint.view) {
        data = await this.render(data, ctx);
      } else if (shouldBeSerialized(data)) {
        data = this.injector.get(ConverterService).serialize(data, _extends({}, endpoint.getResponseOptions(), {
          endpoint: true
        }));
      }
    }

    if (!response.isDone()) {
      const responseFilter = this.injector.get(PlatformResponseFilter);
      response.body(responseFilter.transform(data, ctx));
    }
  }

  async onCtxRequest(requestOptions) {
    const {
      metadata,
      $ctx
    } = requestOptions;
    await metadata.handler($ctx);
    return this.next(requestOptions);
  }
  /**
   * Call handler when a request his handle
   * @param requestOptions
   */


  async onRequest(requestOptions) {
    var _this = this;

    // istanbul ignore next
    if (!requestOptions.$ctx) {
      $log.error(`Endpoint ${requestOptions.metadata.toString()} is called but the response is already send to your consumer. Check your code and his middlewares please!`);
      return;
    }

    const h = new HandlerContext(_extends({}, requestOptions, {
      args: []
    }));
    const {
      $ctx
    } = h;
    return this.injector.runInContext($ctx, async function () {
      try {
        h.args = await _this.getArgs(h);
        await h.callHandler();

        if (h.status === HandlerContextStatus.RESOLVED) {
          // Can be canceled by the handler itself
          return await _this.onSuccess($ctx.data, requestOptions);
        }
      } catch (er) {
        return _this.onError(er, requestOptions);
      }
    });
  }

  async onError(er, requestOptions) {
    const {
      next,
      $ctx
    } = requestOptions;
    $ctx.data = er;

    if (!next) {
      throw er;
    }

    return !$ctx.response.isHeadersSent() && next && next(er);
  }
  /**
   * Manage success scenario
   * @param data
   * @param requestOptions
   * @protected
   */


  async onSuccess(data, requestOptions) {
    const {
      metadata,
      $ctx,
      next
    } = requestOptions;

    if ($ctx.request.isAborted() || $ctx.response.isDone()) {
      return;
    } // set headers each times that an endpoint is called


    if (metadata.type === HandlerType.ENDPOINT) {
      this.setHeaders($ctx);
    } // call returned middleware


    if (isFunction(data) && !isStream(data)) {
      return this.callReturnedMiddleware(data, $ctx, next);
    }

    if (metadata.isFinal()) {
      return this.flush(data, $ctx);
    }

    return this.next(requestOptions);
  }
  /**
   * Call the returned middleware by the handler.
   * @param middleware
   * @param ctx
   * @param next
   * @protected
   */


  callReturnedMiddleware(middleware, ctx, next) {
    return middleware(ctx.getRequest(), ctx.getResponse(), next);
  }
  /**
   * Render the view if the endpoint has a configured view.
   * @param data
   * @param ctx
   * @protected
   */


  async render(data, ctx) {
    return renderView(data, ctx);
  }
  /**
   * create Raw handler
   * @param metadata
   */


  createRawHandler(metadata) {
    switch (metadata.type) {
      case HandlerType.CUSTOM:
        return (ctx, next) => this.onRequest({
          metadata,
          next,
          $ctx: ctx
        });

      case HandlerType.RAW_ERR_FN:
      case HandlerType.RAW_FN:
        return metadata.handler;

      default:
      case HandlerType.ENDPOINT:
      case HandlerType.MIDDLEWARE:
        return (request, response, next) => this.onRequest({
          metadata,
          next,
          $ctx: request.$ctx
        });
    }
  }
  /**
   * Set response headers
   * @param ctx
   * @protected
   */


  setHeaders(ctx) {
    return setResponseHeaders(ctx);
  }

  next(requestOptions) {
    const {
      $ctx,
      next
    } = requestOptions;
    return !$ctx.response.isDone() && next && next();
  }

  buildPipe(metadata) {
    if (metadata.injectable) {
      return metadata.parameters.forEach(param => {
        this.params.build(param);
      });
    }
  }

  getArgs(h) {
    const {
      metadata
    } = h;

    if (metadata.injectable) {
      return this.params.getArgs(h, metadata.parameters);
    }

    return [metadata.hasErrorParam && h.err, h.$ctx.request.request, h.$ctx.response.response, metadata.hasNextFunction && h.next].filter(Boolean);
  }

};
PlatformHandler = __decorate([Injectable({
  scope: ProviderScope.SINGLETON
}), __metadata("design:paramtypes", [InjectorService, PlatformParams])], PlatformHandler);

var PlatformRouter_1;
/**
 * @ignore
 */

const PLATFORM_ROUTER_OPTIONS = Symbol.for("PlatformRouterOptions");
/**
 * Platform Router abstraction layer.
 * @platform
 */

let PlatformRouter = PlatformRouter_1 = class PlatformRouter {
  constructor(platformHandler) {
    this.platformHandler = platformHandler;
    this.rawRouter = this.raw = PlatformRouter_1.createRawRouter();
  }
  /**
   * Create a new instance of PlatformRouter
   * @param injector
   * @param routerOptions
   */


  static create(injector, routerOptions = {}) {
    const locals = new Map();
    locals.set(PLATFORM_ROUTER_OPTIONS, routerOptions);
    return injector.invoke(PlatformRouter_1, locals);
  }

  static createRawRouter() {
    return createFakeRawDriver();
  }

  callback() {
    return this.raw;
  }

  getRouter() {
    return this.rawRouter;
  }

  use(...handlers) {
    // @ts-ignore
    this.getRouter().use(...this.mapHandlers(handlers));
    return this;
  }

  addRoute(options) {
    const {
      method,
      path,
      handlers,
      isFinal
    } = options; // @ts-ignore

    this.getRouter()[method](path, ...this.mapHandlers(handlers, {
      method,
      path,
      isFinal
    }));
    return this;
  }

  all(path, ...handlers) {
    return this.addRoute({
      method: "all",
      path,
      handlers,
      isFinal: true
    });
  }

  get(path, ...handlers) {
    return this.addRoute({
      method: "get",
      path,
      handlers,
      isFinal: true
    });
  }

  post(path, ...handlers) {
    return this.addRoute({
      method: "post",
      path,
      handlers,
      isFinal: true
    });
  }

  put(path, ...handlers) {
    return this.addRoute({
      method: "put",
      path,
      handlers,
      isFinal: true
    });
  }

  delete(path, ...handlers) {
    return this.addRoute({
      method: "delete",
      path,
      handlers,
      isFinal: true
    });
  }

  patch(path, ...handlers) {
    return this.addRoute({
      method: "patch",
      path,
      handlers,
      isFinal: true
    });
  }

  head(path, ...handlers) {
    return this.addRoute({
      method: "head",
      path,
      handlers,
      isFinal: true
    });
  }

  options(path, ...handlers) {
    return this.addRoute({
      method: "options",
      path,
      handlers,
      isFinal: true
    });
  }

  statics(path, options) {
    return this;
  }

  multer(options) {
    const m = require("multer")(options);

    const makePromise = (multer, name) => {
      // istanbul ignore next
      if (!multer[name]) return;
      const fn = multer[name];

      multer[name] = function apply(...args) {
        const middleware = Reflect.apply(fn, this, args);
        return (req, res) => promisify(middleware)(req, res);
      };
    };

    makePromise(m, "any");
    makePromise(m, "array");
    makePromise(m, "fields");
    makePromise(m, "none");
    makePromise(m, "single");
    return m;
  }

  mapHandlers(handlers, options = {}) {
    return handlers.reduce((list, handler, index) => {
      if (typeof handler === "string") {
        return list.concat(handler);
      }

      if (handler instanceof PlatformRouter_1) {
        return list.concat(handler.callback());
      }

      return list.concat(this.platformHandler.createHandler(handler, _extends({}, options, {
        isFinal: options.isFinal ? index === handlers.length - 1 : false
      })));
    }, []);
  }

};

__decorate([Inject(), __metadata("design:type", InjectorService)], PlatformRouter.prototype, "injector", void 0);

PlatformRouter = PlatformRouter_1 = __decorate([Injectable({
  scope: ProviderScope.INSTANCE
}), __metadata("design:paramtypes", [PlatformHandler])], PlatformRouter);

var PlatformApplication_1;
/**
 * `PlatformApplication` is used to provide all routes collected by annotation `@Controller`.
 *
 * @platform
 */

let PlatformApplication = PlatformApplication_1 = class PlatformApplication extends PlatformRouter {
  constructor(platformHandler) {
    super(platformHandler);
    this.rawApp = this.raw = PlatformApplication_1.createRawApp();
  }

  static createRawApp() {
    return createFakeRawDriver();
  }

  getApp() {
    return this.raw;
  }

};
PlatformApplication = PlatformApplication_1 = __decorate([Injectable({
  scope: ProviderScope.SINGLETON
}), __metadata("design:paramtypes", [PlatformHandler])], PlatformApplication);

var PlatformMulterMiddleware_1;
/**
 * @middleware
 */

let PlatformMulterMiddleware = PlatformMulterMiddleware_1 = class PlatformMulterMiddleware {
  async use(ctx) {
    try {
      const {
        fields,
        options = {}
      } = ctx.endpoint.get(PlatformMulterMiddleware_1);

      const settings = _extends({}, this.settings, options);
      /* istanbul ignore next */


      if (settings.storage) {
        delete settings.dest;
      }

      const middleware = this.app.multer(settings).fields(this.getFields({
        fields
      }));
      return await middleware(ctx.getRequest(), ctx.getResponse());
    } catch (er) {
      throw er.code ? new Exception(er.code, `${er.message} ${er.field || ""}`.trim()) : er;
    }
  }

  getFields(conf) {
    return conf.fields.map(({
      name,
      maxCount
    }) => ({
      name,
      maxCount
    }));
  }

};

__decorate([Constant("multer", {}), __metadata("design:type", Object)], PlatformMulterMiddleware.prototype, "settings", void 0);

__decorate([Inject(), __metadata("design:type", PlatformApplication)], PlatformMulterMiddleware.prototype, "app", void 0);

__decorate([__param(0, Context()), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", Promise)], PlatformMulterMiddleware.prototype, "use", null);

PlatformMulterMiddleware = PlatformMulterMiddleware_1 = __decorate([Middleware()], PlatformMulterMiddleware);

/**
 * @deprecated Since 2020-11-30. Use PlatformAcceptMimesMiddleware.
 * @ignore
 */

let GlobalAcceptMimesMiddleware = class GlobalAcceptMimesMiddleware {
  use(ctx) {
    return;
  }

};

__decorate([__param(0, Context()), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", void 0)], GlobalAcceptMimesMiddleware.prototype, "use", null);

GlobalAcceptMimesMiddleware = __decorate([Middleware()], GlobalAcceptMimesMiddleware);

/**
 * @middleware
 * @platform
 */

let PlatformAcceptMimesMiddleware = class PlatformAcceptMimesMiddleware {
  use(ctx) {
    const {
      endpoint,
      request
    } = ctx;
    const mimes = uniq(((endpoint == null ? void 0 : endpoint.get("acceptMimes")) || []).concat(this.acceptMimes));

    if (mimes.length && !request.accepts(mimes)) {
      throw new NotAcceptable(mimes.join(", "));
    }
  }

};

__decorate([Constant("acceptMimes", []), __metadata("design:type", Array)], PlatformAcceptMimesMiddleware.prototype, "acceptMimes", void 0);

__decorate([__param(0, Context()), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", void 0)], PlatformAcceptMimesMiddleware.prototype, "use", null);

PlatformAcceptMimesMiddleware = __decorate([Middleware()], PlatformAcceptMimesMiddleware);

/**
 * @middleware
 * @deprecated Since 2020-11-30. Use PlatformAcceptMimesMiddleware.
 * @ignore
 */

let AcceptMimesMiddleware = class AcceptMimesMiddleware {
  use(ctx) {
    return;
  }

};

__decorate([__param(0, Context()), __metadata("design:type", Function), __metadata("design:paramtypes", [Object]), __metadata("design:returntype", void 0)], AcceptMimesMiddleware.prototype, "use", null);

AcceptMimesMiddleware = __decorate([Middleware()], AcceptMimesMiddleware);

/**
 * Create Ts.ED context handler
 * @param fn
 * @ignore
 */

function useCtxHandler(fn) {
  fn.type = HandlerType.CTX_FN;
  return fn;
}

/**
 * @ignore
 */

function formatMethod(method) {
  return (method === OperationMethods.CUSTOM ? "use" : method || "use").toLowerCase();
}
/**
 * @ignore
 */


class PlatformControllerBuilder {
  constructor(provider) {
    this.provider = provider;
  }
  /**
   *
   * @returns {any}
   */


  build(injector) {
    const {
      middlewares: {
        useBefore
      }
    } = this.provider; // Controller lifecycle

    this.buildMiddlewares(useBefore) // Controller before-middleware
    .buildEndpoints() // All endpoints and his middlewares
    .buildChildrenCtrls(injector); // Children controllers

    return this.provider.getRouter();
  }

  buildEndpoints() {
    const {
      endpoints
    } = this.provider;
    const operationPaths = new Map();

    const getKey = (method, path) => `${method}-${path}`;

    const updateFinalRouteState = key => {
      if (operationPaths.has(key)) {
        operationPaths.get(key).isFinal = false;
      }
    };

    const setFinalRoute = (key, operationPath) => {
      operationPaths.set(key, operationPath);
      operationPath.isFinal = true;
    };

    endpoints.forEach(({
      operation
    }) => {
      operation == null ? void 0 : operation.operationPaths.forEach(operationPath => {
        if (operationPath.method !== OperationMethods.CUSTOM) {
          const key = getKey(operationPath.method, operationPath.path);
          updateFinalRouteState(key);
          updateFinalRouteState(getKey(OperationMethods.ALL, operationPath.path));
          setFinalRoute(key, operationPath);
        }
      });
    });
    endpoints.forEach(endpoint => {
      this.buildEndpoint(endpoint);
    });
    return this;
  }

  buildEndpoint(endpoint) {
    const {
      beforeMiddlewares,
      middlewares: mldwrs,
      afterMiddlewares,
      operation
    } = endpoint;
    const {
      middlewares: {
        use,
        useAfter
      }
    } = this.provider;
    const router = this.provider.getRouter(); // Endpoint lifecycle

    let handlers = [];
    const hasFiles = [...endpoint.children.values()].find(item => item.paramType === ParamTypes.FILES);
    handlers = handlers.concat(useCtxHandler(bindEndpointMiddleware(endpoint))).concat(PlatformAcceptMimesMiddleware).concat(hasFiles && PlatformMulterMiddleware).concat(use) // Controller use-middlewares
    .concat(beforeMiddlewares) // Endpoint before-middlewares
    // .concat(endpoint.cache && PlatformCacheMiddleware)
    .concat(mldwrs) // Endpoint middlewares
    .concat(endpoint) // Endpoint metadata
    .concat(afterMiddlewares) // Endpoint after-middlewares
    .concat(useAfter) // Controller after middlewares (equivalent to afterEach)
    .filter(item => !!item); // Add handlers to the router

    operation == null ? void 0 : operation.operationPaths.forEach(({
      path,
      method,
      isFinal
    }) => {
      router.addRoute({
        method: formatMethod(method),
        path,
        handlers,
        isFinal
      });
    });

    if (!(operation != null && operation.operationPaths.size)) {
      router.use(...handlers);
    }
  }

  buildChildrenCtrls(injector) {
    const {
      children
    } = this.provider;
    const router = this.provider.getRouter();
    children.forEach(child => {
      const provider = injector.getProvider(child);
      /* istanbul ignore next */

      if (!provider) {
        throw new Error("Controller component not found in the ControllerRegistry");
      }

      new PlatformControllerBuilder(provider).build(injector);
      router.use(provider.path, provider.getRouter());
    });
  }

  buildMiddlewares(middlewares) {
    const router = this.provider.getRouter();
    middlewares.filter(o => typeof o === "function").forEach(middleware => {
      router.use(middleware);
    });
    return this;
  }

}

/**
 * Platform Request abstraction layer.
 * @platform
 */

let PlatformRequest = class PlatformRequest {
  constructor(raw) {
    this.raw = raw;
  }

  get secure() {
    return this.raw.secure;
  }

  get host() {
    return this.get("host");
  }

  get protocol() {
    return this.raw.protocol;
  }
  /**
   * Get the url of the request.
   *
   * Is equivalent of `express.response.originalUrl || express.response.url`.
   */


  get url() {
    return this.raw.originalUrl || this.raw.url;
  }

  get headers() {
    return this.raw.headers;
  }

  get method() {
    return this.raw.method;
  }
  /**
   * Contains key-value pairs of data submitted in the request body. By default, it is `undefined`, and is populated when you use
   * `body-parsing` middleware such as `express.json()` or `express.urlencoded()`.
   */


  get body() {
    return this.raw.body;
  }

  get rawBody() {
    return this.raw.rawBody;
  }
  /**
   * When using `cookie-parser` middleware, this property is an object that contains cookies sent by the request.
   * If the request contains no cookies, it defaults to `{}`.
   */


  get cookies() {
    return this.raw.cookies;
  }
  /**
   * This property is an object containing properties mapped to the named route `parameters`.
   * For example, if you have the route `/user/:name`, then the `name` property is available as `req.params.name`.
   * This object defaults to `{}`.
   */


  get params() {
    return this.raw.params;
  }
  /**
   * This property is an object containing a property for each query string parameter in the route.
   * When query parser is set to disabled, it is an empty object `{}`, otherwise it is the result of the configured query parser.
   */


  get query() {
    return this.raw.query;
  }
  /**
   * This property is an object containing a property for each session attributes set by any code.
   * It require to install a middleware like express-session to work.
   */


  get session() {
    return this.raw.session;
  }

  get files() {
    return this.raw.files;
  }
  /**
   * Return the original request framework instance
   */


  get request() {
    return this.getRequest();
  }
  /**
   * Return the original request node.js instance
   */


  get req() {
    return this.getReq();
  }
  /**
   * Returns the HTTP request header specified by field. The match is case-insensitive.
   *
   * ```typescript
   * request.get('Content-Type') // => "text/plain"
   * ```
   *
   * @param name
   */


  get(name) {
    return this.raw.get(name);
  }

  accepts(mime) {
    // @ts-ignore
    return this.raw.accepts(mime);
  }

  isAborted() {
    return this.raw.aborted;
  }

  destroy() {
    // @ts-ignore
    delete this.raw;
  }
  /**
   * Return the Framework response object (express, koa, etc...)
   */


  getRequest() {
    return this.raw;
  }
  /**
   * Return the Node.js response object
   */


  getReq() {
    return this.raw;
  }

};
PlatformRequest = __decorate([Injectable(), Scope(ProviderScope.INSTANCE), __param(0, Opts), __metadata("design:paramtypes", [Object])], PlatformRequest);

var PlatformResponse_1;

const onFinished = require("on-finished");
/**
 * Platform Response abstraction layer.
 * @platform
 */


let PlatformResponse = PlatformResponse_1 = class PlatformResponse {
  constructor(raw) {
    this.raw = raw;
  }
  /**
   * Get the current statusCode
   */


  get statusCode() {
    return this.raw.statusCode;
  }
  /**
   * An object that contains response local variables scoped to the request, and therefore available only to the view(s) rendered during that request / response cycle (if any). Otherwise, this property is identical to app.locals.
   *
   * This property is useful for exposing request-level information such as the request path name, authenticated user, user settings, and so on.
   */


  get locals() {
    return this.raw.locals;
  }
  /**
   * Return the original response framework instance
   */


  get response() {
    return this.getResponse();
  }
  /**
   * Return the original response node.js instance
   */


  get res() {
    return this.getRes();
  }

  static onFinished(res, cb) {
    onFinished(res, cb);
  }
  /**
   * Returns the HTTP response header specified by field. The match is case-insensitive.
   *
   * ```typescript
   * response.get('Content-Type') // => "text/plain"
   * ```
   *
   * @param name
   */


  get(name) {
    return this.raw.get(name);
  }

  getHeaders() {
    return this.raw.getHeaders();
  }
  /**
   * Return the Framework response object (express, koa, etc...)
   */


  getResponse() {
    return this.raw;
  }
  /**
   * Return the Node.js response object
   */


  getRes() {
    return this.raw;
  }

  hasStatus() {
    return this.statusCode !== 200;
  }
  /**
   * Sets the HTTP status for the response.
   *
   * @param status
   */


  status(status) {
    this.raw.status(status);
    return this;
  }
  /**
   * Set header `field` to `val`, or pass
   * an object of header fields.
   *
   * Examples:
   * ```typescript
   * response.setHeaders({ Accept: 'text/plain', 'X-API-Key': 'tobi' });
   * ```
   *
   * Aliased as `res.header()`.
   */


  setHeaders(headers) {
    // apply headers
    Object.entries(headers).forEach(([key, item]) => {
      this.setHeader(key, item);
    });
    return this;
  }

  setHeader(key, item) {
    this.raw.set(key, String(item));
    return this;
  }
  /**
   * Set `Content-Type` response header with `type` through `mime.lookup()`
   * when it does not contain "/", or set the Content-Type to `type` otherwise.
   *
   * Examples:
   *
   *     res.type('.html');
   *     res.type('html');
   *     res.type('json');
   *     res.type('application/json');
   *     res.type('png');
   */


  contentType(contentType) {
    this.raw.contentType(contentType);
    return this;
  }

  contentLength(length) {
    this.setHeader("Content-Length", length);
    return this;
  }

  getContentLength() {
    if (this.get("Content-Length")) {
      return parseInt(this.get("Content-Length"), 10) || 0;
    }
  }

  getContentType() {
    return (this.get("Content-Type") || "").split(";")[0];
  }
  /**
   * Sets the HTTP response Content-Disposition header field to “attachment”.
   * If a filename is given, then it sets the Content-Type based on the extension name via res.type(), and sets the Content-Disposition “filename=” parameter.
   *
   * ```typescript
   * res.attachment()
   * // Content-Disposition: attachment
   *
   * res.attachment('path/to/logo.png')
   * // Content-Disposition: attachment; filename="logo.png"
   * // Content-Type: image/png
   * ```
   *
   * @param filename
   */


  attachment(filename) {
    this.raw.attachment(filename);
    return this;
  }
  /**
   * Redirects to the URL derived from the specified path, with specified status, a positive integer that corresponds to an [HTTP status code](http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html).
   * If not specified, status defaults to `302 Found`.
   *
   * @param status
   * @param url
   */


  redirect(status, url) {
    this.raw.redirect(status, url);
    return this;
  }
  /**
   * Sets the response Location HTTP header to the specified path parameter.
   *
   * @param location
   */


  location(location) {
    this.raw.location(location);
    return this;
  }
  /**
   * Stream the given data.
   *
   * @param data
   */


  stream(data) {
    data.pipe(this.raw);
    return this;
  }
  /**
   * Renders a view and sends the rendered HTML string to the client.
   *
   * @param path
   * @param options
   */


  async render(path, options = {}) {
    return this.platformViews.render(path, _extends({}, this.locals, options));
  }
  /**
   * Send any data to your consumer.
   *
   * This method accept a ReadableStream, a plain object, boolean, string, number, null and undefined data.
   * It choose the better way to send the data.
   *
   * @param data
   */


  body(data) {
    this.data = data;

    if (data === undefined) {
      this.raw.send();
      return this;
    }

    if (isStream(data)) {
      this.stream(data);
      return this;
    }

    if (Buffer.isBuffer(data)) {
      if (!this.getContentType()) {
        this.contentType("application/octet-stream");
      }

      this.contentLength(data.length);
      this.raw.send(data);
      return this;
    }

    if (isBoolean(data) || isNumber(data) || isString(data) || data === null) {
      this.raw.send(data);
      return this;
    }

    this.raw.json(data);
    return this;
  }

  getBody() {
    return this.data;
  }
  /**
   * Add a listener to handler the end of the request/response.
   * @param cb
   */


  onEnd(cb) {
    PlatformResponse_1.onFinished(this.getRes(), cb);
    return this;
  }

  isDone() {
    if (!this.raw) {
      return true;
    }

    const res = this.getRes();
    return Boolean(this.isHeadersSent() || res.writableEnded || res.writableFinished);
  }

  destroy() {
    // @ts-ignore
    delete this.raw;
    delete this.data;
  }

  isHeadersSent() {
    return this.getRes().headersSent;
  }

};

__decorate([Inject(), __metadata("design:type", PlatformViews)], PlatformResponse.prototype, "platformViews", void 0);

PlatformResponse = PlatformResponse_1 = __decorate([Injectable(), Scope(ProviderScope.INSTANCE), __param(0, Opts), __metadata("design:paramtypes", [Object])], PlatformResponse);

const _excluded$2 = ["response", "request", "endpoint", "url", "ignoreUrlPatterns"];

var _ignoreUrlPatterns = /*#__PURE__*/_classPrivateFieldLooseKey("ignoreUrlPatterns");

class PlatformContext extends DIContext {
  constructor(_ref) {
    let {
      response,
      request,
      endpoint,
      url,
      ignoreUrlPatterns = []
    } = _ref,
        options = _objectWithoutPropertiesLoose(_ref, _excluded$2);

    super(_extends({}, options, {
      ignoreLog: () => {
        return _classPrivateFieldLooseBase(this, _ignoreUrlPatterns)[_ignoreUrlPatterns].find(reg => !!this.url.match(reg));
      }
    }));
    Object.defineProperty(this, _ignoreUrlPatterns, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _ignoreUrlPatterns)[_ignoreUrlPatterns] = [];
    this.url = url;
    endpoint && (this.endpoint = endpoint);
    _classPrivateFieldLooseBase(this, _ignoreUrlPatterns)[_ignoreUrlPatterns] = ignoreUrlPatterns.map(pattern => typeof pattern === "string" ? new RegExp(pattern, "gi") : pattern);

    if (response) {
      this.response = response;
      this.container.set(PlatformResponse, response);
    }

    if (request) {
      this.request = request;
      this.container.set(PlatformRequest, request);
    }

    this.container.set(PlatformContext, this);
  }

  get app() {
    return this.injector.get(PlatformApplication);
  }

  async destroy() {
    await super.destroy();
    this.response.destroy();
    this.request.destroy(); // @ts-ignore

    delete this.endpoint; // @ts-ignore

    delete this.response; // @ts-ignore

    delete this.request;
  }

  isDone() {
    return !this.request || !this.response;
  }
  /**
   * Return the framework request instance (Express, Koa, etc...)
   */


  getRequest() {
    return this.request.getRequest();
  }
  /**
   * Return the framework response instance (Express, Koa, etc...)
   */


  getResponse() {
    return this.response.getResponse();
  }
  /**
   * Get Node.js request
   */


  getReq() {
    return this.request.getReq();
  }
  /**
   * Get Node.js response
   */


  getRes() {
    return this.response.getRes();
  }
  /**
   * Return the original application instance.
   */


  getApp() {
    return this.app.getApp();
  }

}

class PlatformRouteDetails {
  constructor({
    provider,
    endpoint,
    method,
    url
  }) {
    this.provider = provider;
    this.endpoint = endpoint;
    this.method = method;
    this.url = url;
    this.rawBody = !!endpoint.params.find(param => param.paramType === ParamTypes.RAW_BODY);
  }

  get name() {
    return `${this.endpoint.targetName}.${this.methodClassName}()`;
  }

  get className() {
    return this.endpoint.targetName;
  }

  get methodClassName() {
    return String(this.endpoint.propertyKey);
  }

  get parameters() {
    return this.endpoint.params;
  }

  toJSON() {
    return {
      method: this.method,
      name: this.name,
      url: this.url,
      className: this.className,
      methodClassName: this.methodClassName,
      parameters: this.parameters,
      rawBody: this.rawBody
    };
  }

}

const ROUTER_OPTIONS = Symbol.for("ROUTER_OPTIONS");

class ControllerProvider extends Provider {
  constructor(provide) {
    super(provide);
    this.type = ProviderType.CONTROLLER;
    this.entity = JsonEntityStore.from(provide);
  }

  get path() {
    return this.entity.path;
  }

  set path(path) {
    this.entity.path = path;
  }
  /**
   *
   * @returns {EndpointMetadata[]}
   */


  get endpoints() {
    return EndpointMetadata.getEndpoints(this.provide);
  }

  get children() {
    return this.store.get("childrenControllers", []);
  }
  /**
   *
   * @returns {ControllerProvider}
   */


  get parent() {
    return this.store.get("parentController");
  }
  /**
   *
   */


  get routerOptions() {
    return this.store.get(ROUTER_OPTIONS) || {};
  }
  /**
   *
   * @param value
   */


  set routerOptions(value) {
    this.store.set(ROUTER_OPTIONS, value);
  }
  /**
   *
   * @returns {any[]}
   */


  get middlewares() {
    return Object.assign({
      use: [],
      useAfter: [],
      useBefore: []
    }, this.store.get("middlewares", {}));
  }
  /**
   *
   * @param middlewares
   */


  set middlewares(middlewares) {
    const mdlwrs = this.middlewares;

    const concat = (key, a, b) => a[key] = a[key].concat(b[key]);

    Object.keys(middlewares).forEach(key => {
      concat(key, mdlwrs, middlewares);
    });
    this.store.set("middlewares", mdlwrs);
  }
  /**
   *
   * @returns {boolean}
   */


  hasChildren() {
    return !!this.children.length;
  }
  /**
   *
   * @returns {boolean}
   */


  hasParent() {
    return !!this.store.get("parentController");
  }

  getRouter() {
    return this.router;
  }

  setRouter(router) {
    this.router = router;
    return this;
  }

}

__decorate([NotEnumerable(), __metadata("design:type", JsonEntityStore)], ControllerProvider.prototype, "entity", void 0);

__decorate([NotEnumerable(), __metadata("design:type", Object)], ControllerProvider.prototype, "router", void 0);

__decorate([Enumerable(), __metadata("design:type", String), __metadata("design:paramtypes", [String])], ControllerProvider.prototype, "path", null);

let PropertyMetadata = class PropertyMetadata extends JsonEntityStore {
  static get(target, propertyKey) {
    return JsonEntityStore.from(prototypeOf(target), propertyKey);
  }
  /**
   * @deprecated Since 2020-11-11. Use getProperties from @tsed/schema
   */


  static getProperties(target, options = {}) {
    return getProperties(target, options);
  }

};
PropertyMetadata = __decorate([JsonEntityComponent(DecoratorTypes.PROP)], PropertyMetadata);

function getControllerPath(basePath, provider) {
  return (basePath === provider.path ? provider.path : (basePath || "") + provider.path).replace(/\/\//gi, "/");
}

var _routes, _controllers;
/**
 * `Platform` is used to provide all routes collected by annotation `@Controller`.
 *
 * @platform
 */

let Platform = (_routes = /*#__PURE__*/_classPrivateFieldLooseKey("routes"), _controllers = /*#__PURE__*/_classPrivateFieldLooseKey("controllers"), class Platform {
  constructor(injector, platformApplication) {
    Object.defineProperty(this, _routes, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _controllers, {
      writable: true,
      value: void 0
    });
    this.injector = injector;
    this.platformApplication = platformApplication;
    _classPrivateFieldLooseBase(this, _routes)[_routes] = [];
    _classPrivateFieldLooseBase(this, _controllers)[_controllers] = [];
  }

  get app() {
    return this.platformApplication;
  }

  get routes() {
    return _classPrivateFieldLooseBase(this, _routes)[_routes];
  }

  addRoutes(routes) {
    routes.forEach(routeSettings => {
      this.addRoute(routeSettings.route, routeSettings.token);
    });
  }

  addRoute(endpoint, token) {
    const {
      injector
    } = this;

    if (injector.hasProvider(token)) {
      const provider = injector.getProvider(token);

      if (provider.type === ProviderType.CONTROLLER) {
        const route = getControllerPath(endpoint, provider);

        if (!provider.hasParent()) {
          const routes = this.buildRoutes(route, provider);

          _classPrivateFieldLooseBase(this, _routes)[_routes].push(...routes);

          _classPrivateFieldLooseBase(this, _controllers)[_controllers].push({
            route,
            provider
          });

          this.app.use(route, ...[].concat(provider.getRouter().callback()));
        }
      }
    }

    return this;
  }
  /**
   * Get all routes built by TsExpressDecorators and mounted on Express application.
   * @returns {PlatformRouteDetails[]}
   */


  getRoutes() {
    return _classPrivateFieldLooseBase(this, _routes)[_routes];
  }

  getMountedControllers() {
    return _classPrivateFieldLooseBase(this, _controllers)[_controllers];
  }
  /**
   *
   * @param ctrl
   * @param endpointUrl
   */


  buildRoutes(endpointUrl, ctrl) {
    const {
      injector
    } = this;
    let routes = [];
    routes = ctrl.children.map(ctrl => injector.getProvider(ctrl)).reduce((routes, provider) => {
      return routes.concat(this.buildRoutes(`${endpointUrl}${provider.path}`, provider));
    }, routes);
    ctrl.endpoints.forEach(endpoint => {
      endpoint.operationPaths.forEach(({
        path,
        method
      }) => {
        if (method) {
          routes.push(new PlatformRouteDetails({
            provider: ctrl,
            endpoint,
            method,
            url: `${endpointUrl}${path || ""}`.replace(/\/\//gi, "/")
          }));
        }
      });
    });
    return routes;
  }

});
Platform = __decorate([Injectable({
  scope: ProviderScope.SINGLETON
}), __metadata("design:paramtypes", [InjectorService, PlatformApplication])], Platform);

/**
 * @ignore
 */

let PlatformModule = class PlatformModule {
  constructor(injector, platform) {
    this.injector = injector;
    this.platform = platform;
    this.createRoutersFromControllers();
  }
  /**
   * Create routers from the collected controllers
   */


  createRoutersFromControllers() {
    const {
      injector
    } = this;
    return injector.getProviders(ProviderType.CONTROLLER).map(provider => {
      provider.setRouter(PlatformRouter.create(injector, provider.routerOptions));

      if (!provider.hasParent()) {
        return new PlatformControllerBuilder(provider).build(injector);
      }
    }).filter(Boolean);
  }

  $$loadRoutes() {
    const routes = this.injector.settings.get("routes");
    this.platform.addRoutes(routes);
  }

};
PlatformModule = __decorate([Module({
  imports: [InjectorService, ConverterService, Platform]
}), __metadata("design:paramtypes", [InjectorService, Platform])], PlatformModule);

$log.name = "TSED";
function createInjector(settings = {}) {
  const injector = new InjectorService();
  injector.settings = createSettingsService(injector);
  injector.logger = $log;
  injector.settings.set(settings);
  setLoggerLevel(injector);
  return injector;
}

function createSettingsService(injector) {
  const provider = GlobalProviders.get(PlatformConfiguration).clone();
  provider.instance = injector.invoke(provider.useClass);
  injector.addProvider(PlatformConfiguration, provider);
  return provider.instance;
}

function createPlatformApplication(injector) {
  injector.forkProvider(PlatformApplication);
}

/**
 * Inject the Http.Server instance.
 *
 * ### Example
 *
 * ```typescript
 * import {HttpServer, Service} from "@tsed/common";
 *
 * @Service()
 * export default class OtherService {
 *    constructor(@HttpServer httpServer: HttpServer) {}
 * }
 * ```
 *
 * > Note: TypeScript transform and store `HttpServer` as `Function` type in the metadata. So to inject a factory, you must use the `@Inject(type)` decorator.
 *
 * @param {Type<any>} target
 * @param {string} targetKey
 * @param {TypedPropertyDescriptor<Function> | number} descriptor
 * @returns {any}
 * @decorator
 */

function HttpServer(target, targetKey, descriptor) {
  return Inject(HttpServer)(target, targetKey, descriptor);
}

function listenServer(http, settings) {
  const {
    address,
    port
  } = settings;
  const promise = new Promise((resolve, reject) => {
    http.on("listening", resolve);
    http.on("error", reject);
  }).then(() => {
    const port = http.address().port;
    return {
      address: settings.address,
      port
    };
  });
  http.listen(port, address);
  return promise;
}

function createHttpServer(injector) {
  injector.forkProvider(HttpServer);
}
registerProvider({
  provide: HttpServer,
  deps: [PlatformApplication],
  scope: ProviderScope.SINGLETON,
  global: true,

  useFactory(platformApplication) {
    return Http.createServer(platformApplication.callback());
  }

});
async function listenHttpServer(injector) {
  const {
    settings
  } = injector;
  const server = injector.get(HttpServer);

  if (settings.httpPort !== false && server) {
    const {
      address,
      port
    } = settings.getHttpPort();
    injector.logger.debug(`Start server on http://${address}:${port}`);
    const options = await listenServer(server, {
      address,
      port
    });
    settings.setHttpPort(options);
    injector.logger.info(`Listen server on http://${options.address}:${options.port}`);
  }
}

/**
 * Inject the Https.Server instance.
 *
 * ### Example
 *
 * ```typescript
 * import {HttpsServer, Service} from "@tsed/common";
 *
 * @Service()
 * export default class OtherService {
 *    constructor(@HttpsServer httpServer: HttpServer) {}
 * }
 * ```
 *
 * > Note: TypeScript transform and store `HttpsServer` as `Function` type in the metadata. So to inject a factory, you must use the `@Inject(type)` decorator.
 *
 * @param {Type<any>} target
 * @param {string} targetKey
 * @param {TypedPropertyDescriptor<Function> | number} descriptor
 * @returns {any}
 * @decorator
 */

function HttpsServer(target, targetKey, descriptor) {
  return Inject(HttpsServer)(target, targetKey, descriptor);
}

function createHttpsServer(injector) {
  injector.forkProvider(HttpsServer);
}
registerProvider({
  provide: HttpsServer,
  deps: [PlatformApplication, Configuration],
  scope: ProviderScope.SINGLETON,
  global: true,

  useFactory(platformApplication, settings) {
    const options = settings.httpsOptions;
    return Https.createServer(options, platformApplication.callback());
  }

});
async function listenHttpsServer(injector) {
  const {
    settings
  } = injector;
  const server = injector.get(HttpsServer);

  if (settings.httpsPort !== false && server) {
    const {
      address,
      port
    } = settings.getHttpsPort();
    injector.logger.debug(`Start server on https://${address}:${port}`);
    const options = await listenServer(server, {
      address,
      port
    });
    settings.setHttpsPort(options);
    injector.logger.info(`Listen server on https://${options.address}:${options.port}`);
  }
}

/**
 * @ignore
 * @deprecated User injector.load(container, module) instead
 */

async function loadInjector(injector, container = createContainer()) {
  injector.bootstrap(container);
  return injector.load(container, PlatformModule);
}

function printRoutes(routes) {
  const mapColor = {
    GET: "green",
    POST: "yellow",
    PUT: "blue",
    DELETE: "red",
    PATCH: "magenta",
    ALL: "cyan"
  };
  const list = routes.map(route => {
    const obj = route.toJSON();
    const method = obj.method.toUpperCase();
    obj.method = {
      length: method.length,
      toString: () => {
        return colorize(method, mapColor[method]);
      }
    };
    return obj;
  });
  const str = $log.drawTable(list, {
    padding: 1,
    header: {
      method: "Method",
      url: "Endpoint",
      name: "Class method"
    }
  });
  return "\n" + str.trim();
}

const uuidv4 = require("uuid").v4;

const defaultReqIdBuilder = req => req.get("x-request-id") || uuidv4().replace(/-/gi, "");
/**
 * Create the TsED context to wrap request, response, injector, etc...
 * @param injector
 * @param request
 * @param response
 * @ignore
 */


async function createContext(injector, request, response) {
  const {
    level,
    ignoreUrlPatterns,
    maxStackSize,
    reqIdBuilder = defaultReqIdBuilder
  } = injector.settings.logger;
  const req = request.getRequest();
  const id = reqIdBuilder(req);
  const ctx = new PlatformContext({
    id,
    logger: injector.logger,
    url: request.url,
    ignoreUrlPatterns,
    level,
    maxStackSize,
    injector,
    response,
    request
  });
  req.$ctx = ctx;
  response.setHeader("x-request-id", id);
  response.onEnd(async () => {
    await ctx.emit("$onResponse", ctx);
    await ctx.destroy();
    delete req.$ctx;
  });
  await ctx.emit("$onRequest", ctx);
  return ctx;
}

const SKIP_HOOKS = ["$beforeInit", "$afterInit", "$onInit", "$onMountingMiddlewares"];
const {
  bind,
  start,
  end,
  log
} = PerfLogger.get("bootstrap");
/**
 * @platform
 */

var _rootModule = /*#__PURE__*/_classPrivateFieldLooseKey("rootModule");

var _injector = /*#__PURE__*/_classPrivateFieldLooseKey("injector");

var _providers = /*#__PURE__*/_classPrivateFieldLooseKey("providers");

class PlatformBuilder {
  constructor({
    name,
    providers
  }) {
    Object.defineProperty(this, _rootModule, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _injector, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _providers, {
      writable: true,
      value: void 0
    });
    this.name = "";
    this.startedAt = new Date();
    this.name = name;
    _classPrivateFieldLooseBase(this, _providers)[_providers] = toMap(providers, "provide");
    this.locals = new Container();
    this.useProvider(PlatformHandler, _classPrivateFieldLooseBase(this, _providers)[_providers].get(PlatformHandler)).useProvider(PlatformResponse, _classPrivateFieldLooseBase(this, _providers)[_providers].get(PlatformResponse)).useProvider(PlatformRequest, _classPrivateFieldLooseBase(this, _providers)[_providers].get(PlatformRequest)).useProvider(PlatformRouter, _classPrivateFieldLooseBase(this, _providers)[_providers].get(PlatformRouter)).useProvider(PlatformApplication, _classPrivateFieldLooseBase(this, _providers)[_providers].get(PlatformApplication)).useProvider(Platform, _classPrivateFieldLooseBase(this, _providers)[_providers].get(Platform));
  }

  get injector() {
    return _classPrivateFieldLooseBase(this, _injector)[_injector];
  }

  get rootModule() {
    return _classPrivateFieldLooseBase(this, _rootModule)[_rootModule];
  }

  get app() {
    return this.injector.get(PlatformApplication);
  }

  get platform() {
    return this.injector.get(Platform);
  }
  /**
   * Return the settings configured by the decorator @@Configuration@@.
   *
   * ```typescript
   * @Configuration({
   *    rootDir: Path.resolve(__dirname),
   *    port: 8000,
   *    httpsPort: 8080,
   *    mount: {
   *      "/rest": "${rootDir}/controllers/**\/*.js"
   *    }
   * })
   * export class Server {
   *     $onInit(){
   *         console.log(this.settings); // {rootDir, port, httpsPort,...}
   *     }
   * }
   * ```
   *
   * @returns {PlatformConfiguration}
   */


  get settings() {
    return this.injector.settings;
  }

  get logger() {
    return this.injector.logger;
  }

  get disableBootstrapLog() {
    return this.settings.logger.disableBootstrapLog;
  }

  static build(platformBuildClass) {
    return new platformBuildClass({
      name: nameOf(platformBuildClass).replace("Platform", "").toLowerCase(),
      providers: platformBuildClass.providers
    });
  }

  log(...data) {
    return this.disableBootstrapLog && this.logger.info(...data);
  }
  /**
   * Add classes to the components list
   * @param classes
   */


  addComponents(classes) {
    this.settings.componentsScan = this.settings.componentsScan.concat(classes);
    return this;
  }
  /**
   * Add classes decorated by @@Controller@@ to components container.
   *
   * ### Example
   *
   * ```typescript
   * @Controller('/ctrl')
   * class MyController{
   * }
   *
   * platform.addControllers('/rest', [MyController])
   * ```
   *
   * ::: tip
   * If the MyController class isn't decorated, the class will be ignored.
   * :::
   *
   * @param {string} endpoint
   * @param {any[]} controllers
   */


  addControllers(endpoint, controllers) {
    this.settings.mount[endpoint] = (this.settings.mount[endpoint] || []).concat(controllers);
  }

  async runLifecycle() {
    setLoggerLevel(this.injector);
    await this.importProviders();
    await this.loadInjector();
    this.useContext();
    this.useRouter();
    await this.loadRoutes();
    await this.logRoutes();
  }

  async loadInjector() {
    const {
      injector
    } = this;
    await this.callHook("$beforeInit");
    this.log("Build providers");
    const container = createContainer(constructorOf(this.rootModule));
    await injector.load(container, PlatformModule);
    this.log("Settings and injector loaded");
    await this.callHook("$afterInit");
  }

  async listen() {
    await this.callHook("$beforeListen");
    await this.listenServers();
    await this.callHook("$afterListen");
    await this.ready();
    end();
  }

  async stop() {
    await this.callHook("$onDestroy");
    return this.injector.destroy();
  }

  async ready() {
    const {
      startedAt
    } = this;
    await this.callHook("$onReady");
    await this.injector.emit("$onServerReady");
    this.log(`Started in ${new Date().getTime() - startedAt.getTime()} ms`);
  }

  async callHook(hook, ...args) {
    const {
      injector,
      rootModule
    } = this;
    log(hook);

    if (!injector.settings.logger.disableBootstrapLog) {
      injector.logger.info(`\x1B[1mCall hook ${hook}\x1B[22m`);
    } // call hook for the Server


    if (hook in rootModule) {
      await rootModule[hook](...args);
    } // Load middlewares for the given hook


    this.loadMiddlewaresFor(hook); // call hooks added by providers

    if (!SKIP_HOOKS.includes(hook)) {
      await injector.emit(hook);
    }
  }

  async loadStatics() {
    const {
      settings
    } = this;

    if (settings.statics) {
      Object.entries(settings.statics).forEach(([path, items]) => {
        [].concat(items).forEach(options => {
          const opts = typeof options === "string" ? {
            root: options
          } : options;
          this.platform.app.statics(path, opts);
        });
      });
    }
  }

  useProvider(token, settings) {
    this.locals.addProvider(token, settings);
    return this;
  }

  async importProviders() {
    this.injector.logger.debug("Scan components");
    const providers = await importProviders(this.injector.settings, ["imports", "mount", "componentsScan"]);
    const routes = providers.filter(provider => !!provider.route).map(({
      route,
      token
    }) => ({
      route,
      token
    }));
    this.settings.set("routes", routes);
  }

  createRequest(req) {
    const Klass = _classPrivateFieldLooseBase(this, _providers)[_providers].get(PlatformRequest).useClass;

    return new Klass(req);
  }

  createResponse(res) {
    const Klass = _classPrivateFieldLooseBase(this, _providers)[_providers].get(PlatformResponse).useClass;

    const response = new Klass(res);
    response.platformViews = this.injector.get(PlatformViews);
    return response;
  }
  /**
   * Load middlewares from configuration for the given hook
   * @param hook
   * @protected
   */


  loadMiddlewaresFor(hook) {
    return getMiddlewaresForHook(hook, this.settings, "$beforeRoutesInit").forEach(({
      use
    }) => {
      this.app.use(use);
    });
  }

  useRouter() {
    return this;
  }

  useContext() {
    return this;
  }

  async bootstrap(module, settings = {}) {
    var _settings$logger;

    // istanbul ignore next
    if ((_settings$logger = settings.logger) != null && _settings$logger.perf) {
      start();
      bind(this);
      settings.logger = _extends({}, settings.logger, {
        level: "off"
      });
    }

    this.createInjector(module, _extends({}, settings, {
      PLATFORM_NAME: this.name
    }));
    this.createRootModule(module);
    await this.runLifecycle();
    return this;
  }

  async listenServers() {
    await Promise.all([listenHttpServer(this.injector), listenHttpsServer(this.injector)]);
  }

  async logRoutes() {
    const {
      logger,
      platform
    } = this;

    if (!this.settings.logger.disableRoutesSummary && !this.disableBootstrapLog) {
      logger.info("Routes mounted :");
      logger.info(printRoutes(await this.injector.alterAsync("$logRoutes", platform.getRoutes())));
    }
  }

  async loadRoutes() {
    var _this$settings$accept;

    // istanbul ignore next
    if (this.settings.logger.level !== "off") {
      this.app.use(PlatformLogMiddleware);
    }

    if ((_this$settings$accept = this.settings.acceptMimes) != null && _this$settings$accept.length) {
      this.app.use(GlobalAcceptMimesMiddleware);
    }

    this.log("Load routes");
    await this.callHook("$beforeRoutesInit");
    await this.callHook("$$loadRoutes");
    await this.callHook("$onRoutesInit");
    await this.loadStatics();
    await this.callHook("$afterRoutesInit");
  }

  createInjector(module, settings) {
    const configuration = getConfiguration(module, settings);
    _classPrivateFieldLooseBase(this, _injector)[_injector] = createInjector(configuration); // configure locals providers

    this.locals.forEach(provider => {
      this.injector.addProvider(provider.token, provider);
    });
    createPlatformApplication(this.injector);
    createHttpsServer(this.injector);
    createHttpServer(this.injector);
  }

  createRootModule(module) {
    _classPrivateFieldLooseBase(this, _rootModule)[_rootModule] = this.injector.invoke(module);
    this.injector.delete(constructorOf(_classPrivateFieldLooseBase(this, _rootModule)[_rootModule]));
    this.injector.delete(classOf(_classPrivateFieldLooseBase(this, _rootModule)[_rootModule]));
  }

}

/**
 * Define multer option for all MultipartFile
 *
 * ```typescript
 * import {Controller, Post, PlatformMulterFile, MultipartFile, MulterOptions} from "@tsed/common";
 *
 * @Controller('/')
 * class MyCtrl {
 *   @Post('/file')
 *   private uploadFile(@MultipartFile("file1") file: PlatformMulterFile) {
 *
 *   }
 *
 *   @Post('/file')
 *   @MulterOptions({dest: "/other-dir"})
 *   private uploadFile(@MultipartFile("file1") file: PlatformMulterFile) {
 *
 *   }
 *
 *   @Post('/file2')
 *   @MulterOptions({dest: "/other-dir"})
 *   private uploadFile(@MultipartFile("file1") file: PlatformMulterFile, @MultipartFile("file2") file2: PlatformMulterFile) {
 *
 *   }
 *
 *   @Post('/files')
 *   private uploadFile(@MultipartFile("file1") files: PlatformMulterFile[]) {
 *
 *   }
 * }
 * ```
 *
 * See the tutorial on the [multer configuration](/tutorials/multer.md).
 *
 * @param {multer.Options} options
 * @returns {(target: any, propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor}
 * @decorator
 * @multer
 */

function MulterOptions(options) {
  return (target, propertyKey, descriptor) => {
    StoreMerge(PlatformMulterMiddleware, {
      options
    })(target, propertyKey, descriptor);
    return descriptor;
  };
}

/**
 * Define file size limit.
 *
 * ```typescript
 * import {Controller, Post} from "@tsed/common";
 * import {MulterOptions, MultipartFile} from "@tsed/common";
 * import {Multer} from "@types/multer";
 *
 * type MulterFile = Express.Multer.File;
 *
 * @Controller('/')
 * class MyCtrl {
 *   @Post('/file2')
 *   @MulterFileSize(1024) // (Ko). Applied for all fields
 *   private uploadFile(@MultipartFile("file1") file: MulterFile, @MultipartFile("file2") file2: MulterFile) {
 *
 *   }
 * }
 * ```
 *
 * > See the tutorial on the [multer configuration](/tutorials/multer.md).
 * @param fileSize
 * @returns {(target: any, propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor}
 * @decorator
 * @multer
 */

function MulterFileSize(fileSize) {
  return MulterOptions({
    limits: {
      fileSize
    }
  });
}

function mapOptions$1(name, maxCount) {
  return {
    fields: [{
      name,
      maxCount
    }]
  };
}
/**
 * Define a parameter as Multipart file.
 *
 * ```typescript
 * import {Controller, Post} from "@tsed/common";
 * import {MulterOptions, MultipartFile} from "@tsed/common";
 * import {Multer} from "@types/multer";
 *
 * type MulterFile = Express.Multer.File;
 *
 * @Controller('/')
 * class MyCtrl {
 *   @Post('/file')
 *   private uploadFile(@MultipartFile("file1") file: MulterFile) {
 *
 *   }
 *
 *   @Post('/file')
 *   @MulterOptions({dest: "/other-dir"})
 *   private uploadFile(@MultipartFile("file1") file: MulterFile) {
 *
 *   }
 *
 *   @Post('/file2')
 *   @MulterOptions({dest: "/other-dir"})
 *   private uploadFile(@MultipartFile("file1") file: MulterFile, @MultipartFile("file2") file2: MulterFile) {
 *
 *   }
 *
 *   @Post('/files')
 *   private uploadFile(@MultipartFile("file1") files: MulterFile[]) {
 *
 *   }
 * }
 * ```
 *
 * > See the tutorial on the [multer configuration](/tutorials/multer.md).
 *
 * @param name
 * @param maxCount
 * @returns Function
 * @decorator
 * @input
 */


function MultipartFile(name, maxCount) {
  return (...args) => {
    const [target, propertyKey, index] = args;
    const multiple = Metadata.getParamTypes(target, propertyKey)[index] === Array;
    name = typeof name === "object" ? undefined : name;
    const expression = [name, !multiple && "0"].filter(Boolean).join(".");
    const decorators = useDecorators(useMethodDecorators(Returns(400).Description(`<File too long | Too many parts | Too many files | Field name too long | Field value too long | Too many fields | Unexpected field>  [fieldName] Example: File too long file1`), Consumes("multipart/form-data"), StoreMerge(PlatformMulterMiddleware, mapOptions$1(name, maxCount))), UseParam({
      paramType: ParamTypes.FILES,
      dataPath: "$ctx.request.files",
      expression,
      useValidation: true
    }));
    decorators(...args);
  };
}

/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function All(path = "/", ...args) {
  return Use(...["all", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Get(path = "/", ...args) {
  return Use(...["get", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Post(path = "/", ...args) {
  return Use(...["post", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Put(path = "/", ...args) {
  return Use(...["put", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Delete(path = "/", ...args) {
  return Use(...["delete", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Head(path = "/", ...args) {
  return Use(...["head", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Patch(path = "/", ...args) {
  return Use(...["patch", path].concat(args));
}
/**
 * This method is just like the `router.METHOD()` methods, except that it matches all HTTP methods (verbs).
 *
 * This method is extremely useful for mapping “global” logic for specific path prefixes or arbitrary matches.
 * For example, if you placed the following route at the top of all other route definitions, it would require that
 * all routes from that point on would require authentication, and automatically load a user.
 * Keep in mind that these callbacks do not have to act as end points; loadUser can perform a task, then call next()
 * to continue matching subsequent routes.
 * @param path
 * @param args
 * @returns {Function}
 * @decorator
 * @operation
 * @httpMethod
 */

function Options(path = "/", ...args) {
  return Use(...["options", path].concat(args));
}

/**
 *
 * @param fn
 * @decorator
 */

function EndpointFn(fn) {
  return JsonEntityFn(fn);
}

/**
 * Set a mime list which are acceptable and checks if the specified content types are acceptable, based on the request’s Accept HTTP header field.
 *
 * ```typescript
 *  @Controller('/mypath')
 *  export class MyCtrl {
 *
 *    @Get('/')
 *    @AcceptMime('application/json')
 *    public getResource(){}
 *  }
 * ```
 *
 * @param mimes
 * @decorator
 * @operation
 * @response
 */

function AcceptMime(...mimes) {
  return useDecorators(Produces(...mimes), EndpointFn(endpoint => {
    endpoint.acceptMimes = mimes;
  }));
}

/**
 * Sets the response Location HTTP header to the specified path parameter.
 *
 * ```typescript
 *  @Location('/foo/bar')
 *  @Location('http://example.com')
 *  @Location('back')
 *  private myMethod() {
 *
 *  }
 * ```
 *
 * A path value of “back” has a special meaning, it refers to the URL specified in the `Referer` header of the request. If the `Referer` header was not specified, it refers to “/”.
 *
 * @param location
 * @returns {Function}
 * @decorator
 * @operation
 */

function Location(location) {
  return EndpointFn(endpoint => {
    endpoint.location = location;
  });
}

function Redirect(status, url) {
  url = !url ? status : url;
  status = typeof status === "number" ? status : 302;
  return useDecorators(Status(status), EndpointFn(endpoint => {
    endpoint.redirect = {
      status: +status,
      url: url
    };
  }));
}

const _excluded$1 = ["children"];

function mapOptions(options) {
  if (typeof options === "string" || options instanceof RegExp || isArrayOrArrayClass(options)) {
    return {
      path: options
    };
  }

  return options;
}
/**
 * Declare a new controller with his Rest path. His methods annotated will be collected to build the routing list.
 * This routing listing will be built with the `express.Router` object.
 *
 * ::: tip
 * See [Controllers](/docs/controllers.md) section for more details
 * :::
 *
 * ```typescript
 *  @Controller("/calendars")
 *  export provide CalendarCtrl {
 *
 *    @Get("/:id")
 *    public get(
 *      @Req() request: Req,
 *      @Res() response: Res,
 *      @Next() next: Next
 *    ): void {
 *
 *    }
 *  }
 * ```
 *
 * @param options
 * @controller
 * @decorator
 * @classDecorator
 */


function Controller(options) {
  const _mapOptions = mapOptions(options),
        {
    children = []
  } = _mapOptions,
        opts = _objectWithoutPropertiesLoose(_mapOptions, _excluded$1);

  return target => {
    registerController(_extends({
      provide: target
    }, opts));
    Store.from(target).set("childrenControllers", children);
    children.forEach(childToken => {
      Store.from(childToken).set("parentController", target);
    });
  };
}

/**
 * Return the current response data. Prefer the @@Context@@ decorator to get or set data.
 *
 * @decorator
 * @operation
 * @input
 * @deprecated Use `@Context() $ctx: Context` then $ctx.data.
 */

function ResponseData() {
  return UseParam({
    paramType: ParamTypes.$CTX,
    dataPath: "$ctx.data"
  });
}

function getParamType$1(target, propertyKey, parameterIndex) {
  const type = Metadata.getOwnParamTypes(target, propertyKey)[parameterIndex];

  if (isClass(type)) {
    if (nameOf(type) === "PlatformResponse") {
      return {
        paramType: ParamTypes.PLATFORM_RESPONSE,
        dataPath: "$ctx.response"
      };
    }

    if (type === ServerResponse) {
      return {
        paramType: ParamTypes.NODE_RESPONSE,
        dataPath: "$ctx.response.res"
      };
    }
  }

  return {
    paramType: ParamTypes.RESPONSE,
    dataPath: "$ctx.response.response"
  };
}

function Response() {
  return Res();
}
function Res() {
  return (target, propertyKey, parameterIndex) => {
    const {
      paramType,
      dataPath
    } = getParamType$1(target, propertyKey, parameterIndex);
    UseParam({
      paramType,
      dataPath
    })(target, propertyKey, parameterIndex);
  };
}

function getParamType(target, propertyKey, parameterIndex) {
  const type = Metadata.getOwnParamTypes(target, propertyKey)[parameterIndex];

  if (isClass(type)) {
    if (nameOf(type) === "PlatformRequest") {
      return {
        paramType: ParamTypes.PLATFORM_REQUEST,
        dataPath: "$ctx.request"
      };
    }

    if (type === IncomingMessage) {
      return {
        paramType: ParamTypes.NODE_REQUEST,
        dataPath: "$ctx.request.req"
      };
    }
  }

  return {
    paramType: ParamTypes.REQUEST,
    dataPath: "$ctx.request.request"
  };
}

function Request(...args) {
  // @ts-ignore
  return Req(...args);
}
function Req(...args) {
  const {
    expression,
    useType,
    useConverter = false,
    useValidation = false
  } = mapParamsOptions(args);
  return (target, propertyKey, parameterIndex) => {
    const {
      paramType,
      dataPath
    } = getParamType(target, propertyKey, parameterIndex);
    UseParam({
      paramType,
      dataPath,
      expression,
      useType,
      useConverter,
      useValidation
    })(target, propertyKey, parameterIndex);
  };
}

/**
 * Get the Next function (for express application and middleware).
 *
 * @decorator
 * @operation
 * @input
 */

function Next() {
  return UseParam({
    paramType: ParamTypes.NEXT_FN,
    dataPath: "next",
    useConverter: false,
    useValidation: false
  });
}

/**
 * @returns {Function}
 * @decorator
 * @operation
 * @input
 */

function Err() {
  return UseParam({
    paramType: ParamTypes.ERR,
    dataPath: "err",
    useValidation: false,
    useConverter: false
  });
}

/**
 * Get the current endpoint metadata.
 * @decorator
 * @operation
 * @input
 * @deprecated Use `@Context() $ctx: Context` then `$ctx.endpoint` instead.
 */

function EndpointInfo() {
  return UseParam({
    paramType: ParamTypes.$CTX,
    dataPath: "$ctx.endpoint",
    useConverter: false,
    useValidation: false
  });
}

const _excluded = ["use", "collection"];

/**
 * @ignore
 */
function mapReturnedResponse(_ref) {
  let {
    use,
    collection
  } = _ref,
      options = _objectWithoutPropertiesLoose(_ref, _excluded);

  return _extends({}, options, {
    type: options.type || use,
    collectionType: options.collectionType || collection
  });
}

/**
 * @platform
 */

class PlatformTest extends DITest {
  static async create(options = {}) {
    DITest.injector = PlatformTest.createInjector(options);
    const container = createContainer();
    await DITest.injector.load(container, PlatformModule);
  }
  /**
   * Create a new injector with the right default services
   */


  static createInjector(settings = {}) {
    return createInjector(DITest.configure(settings));
  }
  /**
   * Load the server silently without listening port and configure it on test profile.
   * @decorator
   * @param mod
   * @param settings
   * @returns {Promise<void>}
   */


  static bootstrap(mod, settings = {}) {
    return async function before() {
      let instance;
      const platform = settings.platform || PlatformTest.platformBuilder;
      /* istanbul ignore next */

      if (!platform) {
        throw new Error("Platform type is not specified. Have you added at least `import @tsed/platform-express` (or equivalent) on your Server.ts ?");
      } // @ts-ignore


      instance = await PlatformBuilder.build(platform).bootstrap(mod, DITest.configure(settings));

      if (!settings.listen) {
        await instance.callHook("$beforeListen");
        await instance.callHook("$afterListen");
        await instance.ready();
      } else {
        await instance.listen();
      } // used by inject method


      DITest.injector = instance.injector;
    };
  }
  /**
   * It injects services into the test function where you can alter, spy on, and manipulate them.
   *
   * The inject function has two parameters
   *
   * * an array of Service dependency injection tokens,
   * * a test function whose parameters correspond exactly to each item in the injection token array.
   *
   * @param targets
   * @param func
   */


  static inject(targets, func) {
    return async function () {
      if (!DITest.hasInjector()) {
        await PlatformTest.create();
      }

      const injector = DITest.injector;
      const deps = [];

      for (const target of targets) {
        deps.push(injector.has(target) ? injector.get(target) : await injector.invoke(target));
      }

      return await func(...deps);
    };
  }
  /**
   * Return the raw application (express or koa).
   * Use this callback with SuperTest.
   *
   * ```typescript
   * let request: SuperTest.SuperTest<SuperTest.Test>;
   * beforeEach(PlatformTest.bootstrap(Server, {
   *   mount: {
   *     "/rest": [ProductsController]
   *   }
   * }));
   * beforeEach(() => {
   *   request = SuperTest(PlatformTest.callback());
   * });
   * ```
   */


  static callback() {
    var _DITest$injector$get;

    return (_DITest$injector$get = DITest.injector.get(PlatformApplication)) == null ? void 0 : _DITest$injector$get.callback();
  }

  static createRequestContext(options = {}) {
    options.request = options.request || new PlatformRequest({});
    options.response = options.response || new PlatformResponse({});
    return new PlatformContext(_extends({
      id: "id",
      injector: DITest.injector,
      logger: DITest.injector.logger,
      url: "/"
    }, options));
  }

}

GlobalProviders.createRegistry(ProviderType.CONTROLLER, ControllerProvider, {
  injectable: false,

  onInvoke(provider, locals) {
    locals.set(PlatformRouter, provider.getRouter());
  }

});

export { AcceptMime, AcceptMimesMiddleware, All, Controller, ControllerProvider, ConverterService, Delete, EndpointFn, EndpointInfo, EndpointMetadata, Err, Get, GlobalAcceptMimesMiddleware, HandlerContext, HandlerContextStatus, HandlerMetadata, HandlerType, Head, HttpServer, HttpsServer, Location, MulterFileSize, MulterOptions, MultipartFile, Next, Options, PLATFORM_ROUTER_OPTIONS, Patch, Platform, PlatformAcceptMimesMiddleware, PlatformApplication, PlatformBuilder, PlatformConfiguration, PlatformContext, PlatformControllerBuilder, PlatformHandler, PlatformLogMiddleware, PlatformModule, PlatformMulterMiddleware, PlatformRequest, PlatformResponse, PlatformRouteDetails, PlatformRouter, PlatformTest, Post, PropertyMetadata, Put, ROUTER_OPTIONS, Redirect, Req, Request, Res, Response, ResponseData, bindEndpointMiddleware, createContext, createHttpServer, createHttpsServer, createInjector, createPlatformApplication, listenHttpServer, listenHttpsServer, listenServer, loadInjector, mapReturnedResponse, printRoutes, useCtxHandler };
//# sourceMappingURL=index.modern.js.map
