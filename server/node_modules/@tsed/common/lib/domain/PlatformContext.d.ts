/// <reference types="node" />
import { ContextMethods, DIContext, DIContextOptions } from "@tsed/di";
import { IncomingMessage, ServerResponse } from "http";
import { EndpointMetadata } from "./EndpointMetadata";
import { PlatformApplication } from "../services/PlatformApplication";
import { PlatformRequest } from "../services/PlatformRequest";
import { PlatformResponse } from "../services/PlatformResponse";
declare global {
    namespace TsED {
        interface Context extends PlatformContext {
        }
    }
}
export interface PlatformContextOptions extends DIContextOptions {
    url: string;
    ignoreUrlPatterns?: any[];
    response?: PlatformResponse;
    request?: PlatformRequest;
    endpoint?: EndpointMetadata;
}
export declare class PlatformContext extends DIContext implements ContextMethods {
    #private;
    /**
     * The current @@EndpointMetadata@@ resolved by Ts.ED during the request.
     */
    endpoint: EndpointMetadata;
    /**
     * The data return by the previous endpoint if you use multiple handler on the same route. By default data is empty.
     */
    data: any;
    /**
     * The current @@PlatformResponse@@.
     */
    response: PlatformResponse;
    /**
     * The current @@PlatformRequest@@.
     */
    request: PlatformRequest;
    /**
     *
     */
    readonly url: string;
    constructor({ response, request, endpoint, url, ignoreUrlPatterns, ...options }: PlatformContextOptions);
    get app(): PlatformApplication<TsED.Application, TsED.Router>;
    destroy(): Promise<void>;
    isDone(): boolean;
    /**
     * Return the framework request instance (Express, Koa, etc...)
     */
    getRequest<Req = any>(): Req;
    /**
     * Return the framework response instance (Express, Koa, etc...)
     */
    getResponse<Res = any>(): Res;
    /**
     * Get Node.js request
     */
    getReq(): IncomingMessage;
    /**
     * Get Node.js response
     */
    getRes(): ServerResponse;
    /**
     * Return the original application instance.
     */
    getApp<T = any>(): T;
}
