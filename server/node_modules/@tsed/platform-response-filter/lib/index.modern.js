import { registerProvider, Inject, InjectorService, Constant, Injectable } from '@tsed/di';
import { __decorate, __metadata } from 'tslib';
import { isObject } from '@tsed/core';

/**
 * @ignore
 */
// tslint:disable-next-line:variable-name
const ResponseFiltersContainer = new Map();
/**
 * @ignore
 */

function registerResponseFilter(type, token) {
  ResponseFiltersContainer.set(type, token);
}

/**
 * Register a response filter service.
 * @param contentTypes
 * @decorator
 */

function ResponseFilter(...contentTypes) {
  return target => {
    contentTypes.forEach(contentType => {
      registerResponseFilter(contentType, target);
    });
    registerProvider({
      provide: target,
      useClass: target
    });
  };
}

const ANY_CONTENT_TYPE = "*/*";
/**
 * @ignore
 */

function getContentType(data, ctx) {
  const {
    endpoint,
    response
  } = ctx;
  const {
    operation
  } = endpoint;
  const contentType = response.getContentType() || operation.getContentTypeOf(response.statusCode) || "";

  if (contentType && contentType !== ANY_CONTENT_TYPE) {
    if (contentType === "application/json") {
      if (isObject(data)) {
        return contentType;
      }
    } else {
      return contentType;
    }
  }

  if (typeof data === "string" && endpoint.view) {
    return "text/html";
  }
}

/**
 * @platform
 */

let PlatformResponseFilter = class PlatformResponseFilter {
  constructor() {
    this.types = new Map();
  }

  get contentTypes() {
    return [...this.types.keys()];
  }

  $onInit() {
    ResponseFiltersContainer.forEach((token, type) => {
      if (this.responseFilters.includes(token)) {
        this.types.set(type, this.injector.get(token));
      }
    });
  }

  getBestContentType(data, ctx) {
    const contentType = getContentType(data, ctx);

    if (ctx.request.get("Accept")) {
      const bestContentType = ctx.request.accepts([contentType].concat(this.contentTypes).filter(Boolean));

      if (bestContentType) {
        return [].concat(bestContentType).filter(type => type !== "*/*")[0];
      }
    }

    return contentType;
  }

  transform(data, ctx) {
    const {
      response
    } = ctx;
    const bestContentType = this.getBestContentType(data, ctx);
    bestContentType && response.contentType(bestContentType);

    if (this.types.has(bestContentType)) {
      return this.types.get(bestContentType).transform(data, ctx);
    }

    if (this.types.has(ANY_CONTENT_TYPE)) {
      return this.types.get(ANY_CONTENT_TYPE).transform(data, ctx);
    }

    return data;
  }

};

__decorate([Inject(), __metadata("design:type", InjectorService)], PlatformResponseFilter.prototype, "injector", void 0);

__decorate([Constant("responseFilters", []), __metadata("design:type", Array)], PlatformResponseFilter.prototype, "responseFilters", void 0);

PlatformResponseFilter = __decorate([Injectable()], PlatformResponseFilter);

export { ANY_CONTENT_TYPE, PlatformResponseFilter, ResponseFilter, ResponseFiltersContainer, getContentType, registerResponseFilter };
//# sourceMappingURL=index.modern.js.map
