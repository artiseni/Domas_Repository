var di = require('@tsed/di');
var tslib = require('tslib');
var core = require('@tsed/core');

/**
 * @ignore
 */
// tslint:disable-next-line:variable-name
const ResponseFiltersContainer = new Map();
/**
 * @ignore
 */

function registerResponseFilter(type, token) {
  ResponseFiltersContainer.set(type, token);
}

/**
 * Register a response filter service.
 * @param contentTypes
 * @decorator
 */

function ResponseFilter(...contentTypes) {
  return target => {
    contentTypes.forEach(contentType => {
      registerResponseFilter(contentType, target);
    });
    di.registerProvider({
      provide: target,
      useClass: target
    });
  };
}

const ANY_CONTENT_TYPE = "*/*";
/**
 * @ignore
 */

function getContentType(data, ctx) {
  const {
    endpoint,
    response
  } = ctx;
  const {
    operation
  } = endpoint;
  const contentType = response.getContentType() || operation.getContentTypeOf(response.statusCode) || "";

  if (contentType && contentType !== ANY_CONTENT_TYPE) {
    if (contentType === "application/json") {
      if (core.isObject(data)) {
        return contentType;
      }
    } else {
      return contentType;
    }
  }

  if (typeof data === "string" && endpoint.view) {
    return "text/html";
  }
}

/**
 * @platform
 */

exports.PlatformResponseFilter = class PlatformResponseFilter {
  constructor() {
    this.types = new Map();
  }

  get contentTypes() {
    return [...this.types.keys()];
  }

  $onInit() {
    ResponseFiltersContainer.forEach((token, type) => {
      if (this.responseFilters.includes(token)) {
        this.types.set(type, this.injector.get(token));
      }
    });
  }

  getBestContentType(data, ctx) {
    const contentType = getContentType(data, ctx);

    if (ctx.request.get("Accept")) {
      const bestContentType = ctx.request.accepts([contentType].concat(this.contentTypes).filter(Boolean));

      if (bestContentType) {
        return [].concat(bestContentType).filter(type => type !== "*/*")[0];
      }
    }

    return contentType;
  }

  transform(data, ctx) {
    const {
      response
    } = ctx;
    const bestContentType = this.getBestContentType(data, ctx);
    bestContentType && response.contentType(bestContentType);

    if (this.types.has(bestContentType)) {
      return this.types.get(bestContentType).transform(data, ctx);
    }

    if (this.types.has(ANY_CONTENT_TYPE)) {
      return this.types.get(ANY_CONTENT_TYPE).transform(data, ctx);
    }

    return data;
  }

};

tslib.__decorate([di.Inject(), tslib.__metadata("design:type", di.InjectorService)], exports.PlatformResponseFilter.prototype, "injector", void 0);

tslib.__decorate([di.Constant("responseFilters", []), tslib.__metadata("design:type", Array)], exports.PlatformResponseFilter.prototype, "responseFilters", void 0);

exports.PlatformResponseFilter = tslib.__decorate([di.Injectable()], exports.PlatformResponseFilter);

exports.ANY_CONTENT_TYPE = ANY_CONTENT_TYPE;
exports.ResponseFilter = ResponseFilter;
exports.ResponseFiltersContainer = ResponseFiltersContainer;
exports.getContentType = getContentType;
exports.registerResponseFilter = registerResponseFilter;
//# sourceMappingURL=index.js.map
