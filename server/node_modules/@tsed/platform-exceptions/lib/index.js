var tslib = require('tslib');
var di = require('@tsed/di');
var Exceptions = require('@tsed/exceptions');
var core = require('@tsed/core');
var schema = require('@tsed/schema');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n['default'] = e;
  return n;
}

var Exceptions__namespace = /*#__PURE__*/_interopNamespace(Exceptions);

/**
 * @ignore
 */
// tslint:disable-next-line:variable-name
const ExceptionFiltersContainer = new Map();
/**
 * @ignore
 */

function registerExceptionType(type, token) {
  ExceptionFiltersContainer.set(type, token);
}

/**
 * Register a new class to handle an specific exception.
 * @decorator
 * @param types
 */

function Catch(...types) {
  return target => {
    types.forEach(type => {
      registerExceptionType(type, target);
    });
    di.registerProvider({
      provide: target,
      useClass: target
    });
  };
}

const toHTML = (message = "") => message.replace(/\n/gi, "<br />");

exports.StringErrorFilter = class StringErrorFilter {
  catch(error, ctx) {
    ctx.response.status(404).body(toHTML(error));
  }

};
exports.StringErrorFilter = tslib.__decorate([Catch(String)], exports.StringErrorFilter);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

exports.ErrorFilter = class ErrorFilter {
  catch(error, ctx) {
    const {
      response,
      logger,
      env
    } = ctx;
    const err = this.mapError(error, env);
    logger.error({
      error: _extends({}, err, {
        stack: error.stack
      })
    });
    response.onEnd(() => {
      env === "development" && ctx.injector.logger.error(error);
    }).setHeaders(this.getHeaders(error)).status(err.status).contentType("application/json").body(env === core.Env.PROD ? "InternalServerError" : err);
  }

  mapError(error, env) {
    var _error$origin;

    return {
      name: ((_error$origin = error.origin) == null ? void 0 : _error$origin.name) || error.name,
      message: error.message,
      status: error.status || 500,
      errors: this.getErrors(error),
      stack: env === core.Env.DEV ? error.stack : undefined
    };
  }

  getErrors(error) {
    return [error, error.origin].filter(Boolean).reduce((errs, {
      errors
    }) => {
      return errs.concat(errors).filter(Boolean);
    }, []);
  }

  getHeaders(error) {
    return [error, error.origin].filter(Boolean).reduce((obj, {
      headers
    }) => {
      return _extends({}, obj, headers || {});
    }, {});
  }

};
exports.ErrorFilter = tslib.__decorate([Catch(Error)], exports.ErrorFilter);

exports.ExceptionFilter = class ExceptionFilter extends exports.ErrorFilter {
  catch(error, ctx) {
    const {
      response,
      logger,
      env
    } = ctx;
    const err = this.mapError(error, env);
    logger.error({
      error: err,
      stack: error.stack
    });
    response.setHeaders(this.getHeaders(error)).contentType("application/json").status(error.status).body(err);
  }

};
exports.ExceptionFilter = tslib.__decorate([Catch(Exceptions.Exception)], exports.ExceptionFilter);

exports.MongooseErrorFilter = class MongooseErrorFilter extends exports.ErrorFilter {
  catch(error, ctx) {
    return super.catch(new Exceptions.BadRequest(error.message, error), ctx);
  }

};
exports.MongooseErrorFilter = tslib.__decorate([Catch("MongooseError", "MongoError")], exports.MongooseErrorFilter);

/**
 * @ignore
 */

const ErrorSchema = schema.object({
  name: schema.string().required().description("The error name"),
  message: schema.string().required().description("An error message")
}).label("GenericError").unknown();
schema.from(Exceptions.Exception).properties({
  name: schema.string().required().description("The error name"),
  message: schema.string().required().description("An error message"),
  status: schema.number().required().description("The status code of the exception"),
  errors: schema.array().items(ErrorSchema).description("A list of related errors"),
  stack: schema.string().description("The stack trace (only in development mode)")
}); // Auto load models for all Exceptions

Object.values(Exceptions__namespace).forEach(target => {
  if (target !== Exceptions.Exception && target.STATUS) {
    const instance = new target("message");
    schema.from(target).properties({
      name: schema.string().required().example(instance.name).default(instance.name).description("The error name"),
      status: schema.number().required().example(instance.status).default(instance.status).description("The status code of the exception")
    });
    schema.defineStatusModel(target.STATUS, target);
  }
});

class ResourceNotFound extends Exceptions.NotFound {
  constructor(url) {
    super(`Resource "${url}" not found`);
    this.url = url;
  }

}

/**
 * Catch all errors and return the json error with the right status code when it's possible.
 *
 * @platform
 */

exports.PlatformExceptions = class PlatformExceptions {
  constructor() {
    this.types = new Map();
  }

  $onInit() {
    ExceptionFiltersContainer.forEach((token, type) => {
      this.types.set(type, this.injector.get(token));
    });
  }

  catch(error, ctx) {
    const name = core.nameOf(core.classOf(error));

    if (name && this.types.has(name)) {
      return this.types.get(name).catch(error, ctx);
    }

    const target = core.ancestorsOf(error).reverse().find(target => this.types.has(target));

    if (target) {
      return this.types.get(target).catch(error, ctx);
    } // default


    return this.types.get(Error).catch(error, ctx);
  }

  resourceNotFound(ctx) {
    return this.catch(new ResourceNotFound(ctx.request.url), ctx);
  }

};

tslib.__decorate([di.Inject(), tslib.__metadata("design:type", di.InjectorService)], exports.PlatformExceptions.prototype, "injector", void 0);

exports.PlatformExceptions = tslib.__decorate([di.Injectable()], exports.PlatformExceptions);

exports.Catch = Catch;
exports.ExceptionFiltersContainer = ExceptionFiltersContainer;
exports.ResourceNotFound = ResourceNotFound;
exports.registerExceptionType = registerExceptionType;
//# sourceMappingURL=index.js.map
