import { __decorate, __metadata } from 'tslib';
import { registerProvider, Inject, InjectorService, Injectable } from '@tsed/di';
import * as Exceptions from '@tsed/exceptions';
import { Exception, BadRequest, NotFound } from '@tsed/exceptions';
import { Env, nameOf, classOf, ancestorsOf } from '@tsed/core';
import { object, string, from, number, array, defineStatusModel } from '@tsed/schema';

/**
 * @ignore
 */
// tslint:disable-next-line:variable-name
const ExceptionFiltersContainer = new Map();
/**
 * @ignore
 */

function registerExceptionType(type, token) {
  ExceptionFiltersContainer.set(type, token);
}

/**
 * Register a new class to handle an specific exception.
 * @decorator
 * @param types
 */

function Catch(...types) {
  return target => {
    types.forEach(type => {
      registerExceptionType(type, target);
    });
    registerProvider({
      provide: target,
      useClass: target
    });
  };
}

const toHTML = (message = "") => message.replace(/\n/gi, "<br />");

let StringErrorFilter = class StringErrorFilter {
  catch(error, ctx) {
    ctx.response.status(404).body(toHTML(error));
  }

};
StringErrorFilter = __decorate([Catch(String)], StringErrorFilter);

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

let ErrorFilter = class ErrorFilter {
  catch(error, ctx) {
    const {
      response,
      logger,
      env
    } = ctx;
    const err = this.mapError(error, env);
    logger.error({
      error: _extends({}, err, {
        stack: error.stack
      })
    });
    response.onEnd(() => {
      env === "development" && ctx.injector.logger.error(error);
    }).setHeaders(this.getHeaders(error)).status(err.status).contentType("application/json").body(env === Env.PROD ? "InternalServerError" : err);
  }

  mapError(error, env) {
    var _error$origin;

    return {
      name: ((_error$origin = error.origin) == null ? void 0 : _error$origin.name) || error.name,
      message: error.message,
      status: error.status || 500,
      errors: this.getErrors(error),
      stack: env === Env.DEV ? error.stack : undefined
    };
  }

  getErrors(error) {
    return [error, error.origin].filter(Boolean).reduce((errs, {
      errors
    }) => {
      return errs.concat(errors).filter(Boolean);
    }, []);
  }

  getHeaders(error) {
    return [error, error.origin].filter(Boolean).reduce((obj, {
      headers
    }) => {
      return _extends({}, obj, headers || {});
    }, {});
  }

};
ErrorFilter = __decorate([Catch(Error)], ErrorFilter);

let ExceptionFilter = class ExceptionFilter extends ErrorFilter {
  catch(error, ctx) {
    const {
      response,
      logger,
      env
    } = ctx;
    const err = this.mapError(error, env);
    logger.error({
      error: err,
      stack: error.stack
    });
    response.setHeaders(this.getHeaders(error)).contentType("application/json").status(error.status).body(err);
  }

};
ExceptionFilter = __decorate([Catch(Exception)], ExceptionFilter);

let MongooseErrorFilter = class MongooseErrorFilter extends ErrorFilter {
  catch(error, ctx) {
    return super.catch(new BadRequest(error.message, error), ctx);
  }

};
MongooseErrorFilter = __decorate([Catch("MongooseError", "MongoError")], MongooseErrorFilter);

/**
 * @ignore
 */

const ErrorSchema = object({
  name: string().required().description("The error name"),
  message: string().required().description("An error message")
}).label("GenericError").unknown();
from(Exception).properties({
  name: string().required().description("The error name"),
  message: string().required().description("An error message"),
  status: number().required().description("The status code of the exception"),
  errors: array().items(ErrorSchema).description("A list of related errors"),
  stack: string().description("The stack trace (only in development mode)")
}); // Auto load models for all Exceptions

Object.values(Exceptions).forEach(target => {
  if (target !== Exception && target.STATUS) {
    const instance = new target("message");
    from(target).properties({
      name: string().required().example(instance.name).default(instance.name).description("The error name"),
      status: number().required().example(instance.status).default(instance.status).description("The status code of the exception")
    });
    defineStatusModel(target.STATUS, target);
  }
});

class ResourceNotFound extends NotFound {
  constructor(url) {
    super(`Resource "${url}" not found`);
    this.url = url;
  }

}

/**
 * Catch all errors and return the json error with the right status code when it's possible.
 *
 * @platform
 */

let PlatformExceptions = class PlatformExceptions {
  constructor() {
    this.types = new Map();
  }

  $onInit() {
    ExceptionFiltersContainer.forEach((token, type) => {
      this.types.set(type, this.injector.get(token));
    });
  }

  catch(error, ctx) {
    const name = nameOf(classOf(error));

    if (name && this.types.has(name)) {
      return this.types.get(name).catch(error, ctx);
    }

    const target = ancestorsOf(error).reverse().find(target => this.types.has(target));

    if (target) {
      return this.types.get(target).catch(error, ctx);
    } // default


    return this.types.get(Error).catch(error, ctx);
  }

  resourceNotFound(ctx) {
    return this.catch(new ResourceNotFound(ctx.request.url), ctx);
  }

};

__decorate([Inject(), __metadata("design:type", InjectorService)], PlatformExceptions.prototype, "injector", void 0);

PlatformExceptions = __decorate([Injectable()], PlatformExceptions);

export { Catch, ErrorFilter, ExceptionFilter, ExceptionFiltersContainer, MongooseErrorFilter, PlatformExceptions, ResourceNotFound, StringErrorFilter, registerExceptionType };
//# sourceMappingURL=index.modern.js.map
