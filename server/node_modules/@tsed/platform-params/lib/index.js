var core = require('@tsed/core');
var tslib = require('tslib');
var schema = require('@tsed/schema');
var di = require('@tsed/di');
var jsonMapper = require('@tsed/json-mapper');
var exceptions = require('@tsed/exceptions');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

var id = 0;

function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}

function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }

  return receiver;
}

/**
 * @ignore
 */

function mapParamsOptions(args) {
  if (args.length === 1) {
    if (typeof args[0] === "string") {
      return {
        expression: args[0]
      };
    }

    if (!core.isObject(args[0])) {
      return {
        useType: args[0]
      };
    }

    return _extends({}, args[0]);
  }

  return {
    expression: args[0],
    useType: args[1]
  };
}

exports.ParamTypes = void 0;

(function (ParamTypes) {
  ParamTypes["$CTX"] = "$CTX";
  ParamTypes["BODY"] = "BODY";
  ParamTypes["PATH"] = "PATH";
  ParamTypes["QUERY"] = "QUERY";
  ParamTypes["HEADER"] = "HEADER";
  ParamTypes["RAW_BODY"] = "RAW_BODY";
  ParamTypes["COOKIES"] = "COOKIES";
  ParamTypes["LOCALS"] = "LOCALS";
  ParamTypes["SESSION"] = "SESSION";
  ParamTypes["FILES"] = "FILES"; /// NOT STD

  ParamTypes["NEXT_FN"] = "NEXT_FN";
  ParamTypes["ERR"] = "ERR";
  ParamTypes["REQUEST"] = "REQUEST";
  ParamTypes["PLATFORM_REQUEST"] = "PLATFORM_REQUEST";
  ParamTypes["NODE_REQUEST"] = "NODE_REQUEST";
  ParamTypes["RESPONSE"] = "RESPONSE";
  ParamTypes["PLATFORM_RESPONSE"] = "PLATFORM_RESPONSE";
  ParamTypes["NODE_RESPONSE"] = "NODE_RESPONSE";
  ParamTypes["RESPONSE_DATA"] = "RESPONSE_DATA";
  ParamTypes["ENDPOINT_INFO"] = "ENDPOINT_INFO";
  ParamTypes["RES"] = "RES";
  ParamTypes["REQ"] = "REQ";
})(exports.ParamTypes || (exports.ParamTypes = {}));

exports.ParamMetadata = class ParamMetadata extends schema.JsonEntityStore {
  constructor(options) {
    super(options);
    this.paramType = "$ctx";
    this.pipes = [];
    const {
      paramType,
      pipes,
      dataPath
    } = options;
    this.expression = options.expression || this.expression;
    this.paramType = paramType || this.paramType;
    this.dataPath = dataPath || this.dataPath;
    this.pipes = pipes || [];
  }

  get key() {
    let {
      expression,
      paramType,
      dataPath
    } = this;

    if (expression && paramType === exports.ParamTypes.HEADER) {
      expression = String(expression).toLowerCase();
    }

    return [dataPath, expression].filter(Boolean).join(".");
  }
  /**
   * Return the JsonOperation
   */


  get parameter() {
    return this._parameter;
  }

  static get(target, propertyKey, index) {
    return schema.JsonEntityStore.from(core.prototypeOf(target), propertyKey, index);
  }

  static getParams(target, propertyKey) {
    const params = [];
    const klass = core.ancestorsOf(target).reverse().find(target => schema.JsonEntityStore.fromMethod(target, propertyKey).children.size);

    if (!klass) {
      return [];
    }

    schema.JsonEntityStore.fromMethod(klass, propertyKey).children.forEach((param, index) => {
      params[+index] = param;
    });
    return params;
  }

};
exports.ParamMetadata = tslib.__decorate([schema.JsonEntityComponent(core.DecoratorTypes.PARAM), tslib.__metadata("design:paramtypes", [Object])], exports.ParamMetadata);

exports.ParseExpressionPipe = class ParseExpressionPipe {
  transform(scope, param) {
    const {
      paramType,
      type
    } = param;
    const value = core.getValue(scope, param.key);

    if ([exports.ParamTypes.QUERY, exports.ParamTypes.PATH].includes(paramType) && value === "" && type !== String) {
      return undefined;
    }

    return value;
  }

};
exports.ParseExpressionPipe = tslib.__decorate([di.Injectable({
  priority: -1000
})], exports.ParseExpressionPipe);

var _settings;

var DeserializerPipe_1;
exports.DeserializerPipe = DeserializerPipe_1 = (_settings = /*#__PURE__*/_classPrivateFieldLooseKey("settings"), class DeserializerPipe {
  constructor(configuration) {
    Object.defineProperty(this, _settings, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _settings)[_settings] = configuration.get("jsonMapper", configuration.get("converter", {}));
  }

  transform(value, param) {
    return jsonMapper.deserialize(value, _extends({
      useAlias: true,
      additionalProperties: _classPrivateFieldLooseBase(this, _settings)[_settings].additionalProperties === "accept",
      type: param.type,
      collectionType: param.collectionType,
      groups: param.parameter.groups,
      genericTypes: param.nestedGenerics[0],
      nestedGenerics: param.nestedGenerics
    }, param.store.get(DeserializerPipe_1) || {}));
  }

});
exports.DeserializerPipe = DeserializerPipe_1 = tslib.__decorate([di.Injectable(), tslib.__param(0, di.Configuration()), tslib.__metadata("design:paramtypes", [Object])], exports.DeserializerPipe);

class ValidationError extends exceptions.BadRequest {
  constructor(message, errors = []) {
    super(message);
    this.name = "VALIDATION_ERROR";
    this.errors = errors;
  }

}

class RequiredValidationError extends ValidationError {
  constructor() {
    super(...arguments);
    this.name = "REQUIRED_VALIDATION_ERROR";
  }

  static from(metadata) {
    const name = core.nameOf(metadata.paramType);
    const expression = metadata.expression;
    const type = name.toLowerCase().replace(/parse|params|filter/gi, "");
    const message = `It should have required parameter '${expression}'`;
    const errors = [{
      dataPath: "",
      keyword: "required",
      message,
      modelName: type,
      params: {
        missingProperty: expression
      },
      schemaPath: "#/required"
    }];
    return new RequiredValidationError(message, errors);
  }

}

exports.ValidationPipe = class ValidationPipe {
  constructor(injector) {
    const provider = injector.getProviders().find(provider => core.nameOf(provider.token) === "AjvService");

    if (provider) {
      this.validator = injector.invoke(provider.token);
    }
  }

  coerceTypes(value, metadata) {
    if (value === undefined) {
      return value;
    }

    if (value === "null") {
      return null;
    }

    if (metadata.isPrimitive) {
      try {
        return jsonMapper.deserialize(value, {
          type: metadata.type
        });
      } catch (er) {
        return value;
      }
    }

    if (metadata.isArray) {
      return [].concat(value);
    }

    return value;
  }

  skip(value, metadata) {
    return metadata.paramType === exports.ParamTypes.PATH && !metadata.isPrimitive;
  }

  async transform(value, metadata) {
    if (!this.validator) {
      this.checkIsRequired(value, metadata);
      return value;
    }

    if (this.skip(value, metadata)) {
      return value;
    }

    value = this.coerceTypes(value, metadata);
    this.checkIsRequired(value, metadata);

    if (value === undefined) {
      return value;
    }

    const schema$1 = schema.getJsonSchema(metadata, {
      customKeys: true
    });
    await this.validator.validate(value, {
      schema: schema$1,
      type: metadata.isClass ? metadata.type : undefined,
      collectionType: metadata.collectionType
    });
    return value;
  }

  checkIsRequired(value, metadata) {
    if (metadata.isRequired(value)) {
      throw RequiredValidationError.from(metadata);
    }

    return true;
  }

};
exports.ValidationPipe = tslib.__decorate([di.Injectable({
  type: "validator"
}), tslib.__metadata("design:paramtypes", [di.InjectorService])], exports.ValidationPipe);

class ParamValidationError extends exceptions.BadRequest {
  constructor() {
    super(...arguments);
    this.name = "PARAM_VALIDATION_ERROR";
  }

  static from(metadata, origin = {}) {
    if (origin instanceof ValidationError || origin instanceof exceptions.BadRequest) {
      const name = core.nameOf(metadata.paramType).toLowerCase().replace(/parse|params|filter/gi, "");
      const expression = metadata.expression;
      const message = `Bad request on parameter "request.${name}${expression ? "." + expression : ""}".\n${origin.message}`.trim();
      const error = new ParamValidationError(message);
      error.dataPath = String(metadata.expression) || "";
      error.requestType = core.nameOf(metadata.paramType);
      error.origin = origin.origin || origin;
      return error;
    }

    return origin;
  }

}

var _caches;
/**
 * Platform Params abstraction layer.
 * @platform
 */

exports.PlatformParams = (_caches = /*#__PURE__*/_classPrivateFieldLooseKey("caches"), class PlatformParams {
  constructor() {
    Object.defineProperty(this, _caches, {
      writable: true,
      value: void 0
    });
    _classPrivateFieldLooseBase(this, _caches)[_caches] = new WeakMap();
  }

  async build(param) {
    const get = pipe => {
      return this.injector.getProvider(pipe).priority || 0;
    };

    const sort = (p1, p2) => get(p1) < get(p2) ? -1 : get(p1) > get(p2) ? 1 : 0;

    const map = token => this.injector.invoke(token);

    const promises = await Promise.all([exports.ParseExpressionPipe, ...param.pipes.sort(sort)].map(map));
    const pipes = promises.filter(Boolean);

    _classPrivateFieldLooseBase(this, _caches)[_caches].set(param, pipes);

    return pipes;
  }

  getPipes(param) {
    return _classPrivateFieldLooseBase(this, _caches)[_caches].get(param) || [];
  }

  async runPipes(scope, param) {
    return this.getPipes(param).reduce(async (value, pipe) => {
      value = await value;

      try {
        return await pipe.transform(value, param);
      } catch (er) {
        throw ParamValidationError.from(param, er);
      }
    }, scope);
  }
  /**
   * Return arguments to call handler
   */


  async getArgs(scope, parameters) {
    return Promise.all(parameters.map(param => this.runPipes(scope, param)));
  }

});

tslib.__decorate([di.Inject(), tslib.__metadata("design:type", di.InjectorService)], exports.PlatformParams.prototype, "injector", void 0);

exports.PlatformParams = tslib.__decorate([di.Injectable({
  scope: di.ProviderScope.SINGLETON
})], exports.PlatformParams);

/**
 * Get the Param metadata. Use this decorator to compose your own decorator.
 *
 * @param fn
 * @decorator
 * @operation
 * @input
 */

function ParamFn(fn) {
  return (target, propertyKey, index) => {
    if (core.decoratorTypeOf([target, propertyKey, index]) === core.DecoratorTypes.PARAM) {
      fn(exports.ParamMetadata.get(target, propertyKey, index), [target, propertyKey, index]);
    }
  };
}

/**
 * Register a Pipe to be used with the current decorated param.
 *
 * @param token
 * @param options
 * @decorator
 * @operation
 * @input
 * @pipe
 */

function UsePipe(token, options = {}) {
  return ParamFn(param => {
    param.store.set(token, options);
    param.pipes.push(token);
  });
}

/**
 * Use JsonMapper to deserialize the data.
 *
 * @decorator
 * @operation
 * @input
 * @pipe
 */

function UseDeserialization(options = {}) {
  return UsePipe(exports.DeserializerPipe, options);
}

/**
 * Get data from a path inside the given object
 *
 * @param expression
 * @decorator
 * @operation
 * @input
 * @pipe
 */

function UseParamExpression(expression) {
  return ParamFn(param => {
    param.expression = expression || "";
  });
}

/**
 * Get the object from request (like body, params, query, etc...).
 *
 * @decorator
 * @operation
 * @input
 * @pipe
 */

function UseParamType(options) {
  return core.useDecorators(ParamFn(param => {
    if (schema.isParameterType(options.paramType)) {
      param.parameter.in(options.paramType);
    }

    param.paramType = options.paramType;
    param.dataPath = options.dataPath;
  }), UseParamExpression(options.expression), options.expression && schema.Name(options.expression));
}

/**
 * Set the type of the item colllection.
 *
 * Prefer @@CollectionOf@@ usage.
 *
 * @param type
 * @decorator
 * @operation
 * @input
 * @alias CollectionOf
 */

function UseType(type) {
  return schema.CollectionOf(type);
}

/**
 * Enable validation on the decoratored parameter.
 *
 * @decorator
 * @operation
 * @input
 * @pipe
 */

function UseValidation() {
  return ParamFn(param => {
    if (param.type || param.collectionType) {
      param.pipes.push(exports.ValidationPipe);
    }
  });
}

const _excluded = ["paramType", "useType", "expression", "useValidation", "useConverter"];
/**
 * @ignore
 * @param options
 */

function mapPipes(options) {
  const {
    useType,
    useValidation,
    useConverter
  } = options,
        props = _objectWithoutPropertiesLoose(options, _excluded);

  return [useType ? UseType(useType) : ParamFn((entity, parameters) => {
    if (entity.isCollection && entity.type === Object) {
      schema.Any()(...parameters);
    }
  }), useValidation && UseValidation(), useConverter && UseDeserialization(props)];
}

function UseParam(...args) {
  const options = _extends({
    dataPath: "$ctx"
  }, (core.isString(args[0]) ? args[1] : args[0]) || {}, {
    paramType: core.isString(args[0]) ? args[0] : args[0].paramType
  });

  return core.useDecorators(UseParamType(options), ...mapPipes(options));
}

function Context(...args) {
  const {
    expression,
    useType,
    useConverter = false,
    useValidation = false
  } = mapParamsOptions(args);
  return UseParam({
    paramType: exports.ParamTypes.$CTX,
    dataPath: "$ctx",
    expression,
    useType,
    useConverter,
    useValidation
  });
}

function BodyParams(...args) {
  const {
    expression,
    useType,
    useConverter = true,
    useValidation = true
  } = mapParamsOptions(args);
  return UseParam({
    paramType: exports.ParamTypes.BODY,
    dataPath: "$ctx.request.body",
    expression,
    useType,
    useConverter,
    useValidation
  });
}
/**
 * RawBodyParams return the value from [request.body](http://expressjs.com/en/4x/api.html#req.body) as a Buffer.
 *
 * #### Example
 *
 * ```typescript
 * @Controller('/')
 * class MyCtrl {
 *    @Post('/')
 *    create(@RawBodyParams() body: Buffer) {
 *       console.log('Entire body', body.toString('utf8'));
 *    }
 * }
 * ```
 *
 * @decorator
 * @operation
 * @input
 */

function RawBodyParams() {
  return core.useDecorators(UseParam({
    paramType: exports.ParamTypes.RAW_BODY,
    dataPath: "$ctx.request.rawBody",
    useType: Object,
    useConverter: false,
    useValidation: false
  }));
}

function HeaderParams(...args) {
  const {
    expression,
    useType,
    useConverter = false,
    useValidation = false
  } = mapParamsOptions(args);
  return UseParam({
    paramType: exports.ParamTypes.HEADER,
    dataPath: "$ctx.request.headers",
    expression,
    useType,
    useConverter,
    useValidation
  });
}

function CookiesParams(...args) {
  const {
    expression,
    useType,
    useConverter = false,
    useValidation = false
  } = mapParamsOptions(args);
  return UseParam({
    paramType: exports.ParamTypes.COOKIES,
    dataPath: "$ctx.request.cookies",
    expression,
    useType,
    useConverter,
    useValidation
  });
}
function Cookies(...args) {
  // @ts-ignore
  return CookiesParams(...args);
}

function Locals(...args) {
  const {
    expression,
    useType,
    useConverter = false,
    useValidation = false
  } = mapParamsOptions(args);
  return UseParam({
    paramType: exports.ParamTypes.LOCALS,
    dataPath: "$ctx.response.locals",
    expression,
    useType,
    useConverter,
    useValidation
  });
}

function PathParams(...args) {
  const {
    expression,
    useType,
    useConverter = true,
    useValidation = true
  } = mapParamsOptions(args);
  return UseParam({
    paramType: exports.ParamTypes.PATH,
    dataPath: "$ctx.request.params",
    expression,
    useType,
    useConverter,
    useValidation
  });
}
/**
 * RawPathParams return the raw value from [request.params](http://expressjs.com/en/4x/api.html#req.params) object.
 *
 * Any validation and transformation are performed on the value. Use [pipes](/docs/pipes.html) to validate and/or transform the value.
 *
 * #### Example
 *
 * ```typescript
 * @Controller('/')
 * class MyCtrl {
 *    @Get('/')
 *    get(@RawPathParams() params: string) {
 *       console.log('Entire params', params);
 *    }
 *
 *    @Get('/')
 *    get(@RawPathParams('id') id: string) {
 *       console.log('ID', id);
 *    }
 * }
 * ```
 * > For more information on deserialization see [converters](/docs/converters.md) page.
 *
 * @param expression The path of the property to get.
 * @decorator
 * @operation
 * @input
 */

function RawPathParams(expression) {
  return UseParam({
    paramType: exports.ParamTypes.PATH,
    dataPath: "$ctx.request.params",
    expression
  });
}

function QueryParams(...args) {
  const {
    expression,
    useType,
    useConverter = true,
    useValidation = true
  } = mapParamsOptions(args);
  return UseParam({
    paramType: exports.ParamTypes.QUERY,
    dataPath: "$ctx.request.query",
    expression,
    useType,
    useConverter,
    useValidation
  });
}
/**
 * RawQueryParams return the value from [request.query](http://expressjs.com/en/4x/api.html#req.query) object.
 *
 * Any validation and transformation are performed on the value. Use [pipes](/docs/pipes.html) to validate and/or transform the value.
 *
 * #### Example
 *
 * ```typescript
 * @Controller('/')
 * class MyCtrl {
 *    @Get('/')
 *    get(@RawPathParams() params: any) {
 *       console.log('Entire params', params);
 *    }
 *
 *    @Get('/')
 *    get(@RawPathParams('id') id: string) {
 *       console.log('ID', id);
 *    }
 * }
 * ```
 * > For more information on deserialization see [converters](/docs/converters.md) page.
 *
 * @param expression The path of the property to get.
 * @decorator
 * @operation
 * @input
 */

function RawQueryParams(expression) {
  return UseParam({
    paramType: exports.ParamTypes.QUERY,
    dataPath: "$ctx.request.query",
    expression
  });
}

function Session(...args) {
  const {
    expression,
    useType,
    useConverter = false,
    useValidation = false
  } = mapParamsOptions(args);
  return UseParam({
    paramType: exports.ParamTypes.SESSION,
    dataPath: "$ctx.request.session",
    expression,
    useType,
    useConverter,
    useValidation
  });
}

exports.BodyParams = BodyParams;
exports.Context = Context;
exports.Cookies = Cookies;
exports.CookiesParams = CookiesParams;
exports.HeaderParams = HeaderParams;
exports.Locals = Locals;
exports.ParamFn = ParamFn;
exports.ParamValidationError = ParamValidationError;
exports.PathParams = PathParams;
exports.QueryParams = QueryParams;
exports.RawBodyParams = RawBodyParams;
exports.RawPathParams = RawPathParams;
exports.RawQueryParams = RawQueryParams;
exports.RequiredValidationError = RequiredValidationError;
exports.Session = Session;
exports.UseDeserialization = UseDeserialization;
exports.UseParam = UseParam;
exports.UseParamExpression = UseParamExpression;
exports.UseParamType = UseParamType;
exports.UsePipe = UsePipe;
exports.UseType = UseType;
exports.UseValidation = UseValidation;
exports.ValidationError = ValidationError;
exports.mapParamsOptions = mapParamsOptions;
//# sourceMappingURL=index.js.map
