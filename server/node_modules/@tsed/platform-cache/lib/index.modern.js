import { __decorate, __metadata } from 'tslib';
import { isFunction, isClass, isString, Store, nameOf, useDecorators } from '@tsed/core';
import { Configuration, Injectable, Inject, Interceptor, DIContext, Intercept, Module } from '@tsed/di';
import { deserialize, serialize } from '@tsed/json-mapper';
import cacheManager from 'cache-manager';
import micromatch from 'micromatch';
import { JsonEntityStore } from '@tsed/schema';
import { IncomingMessage, ServerResponse } from 'http';

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

const _excluded = ["caches", "store", "ttl"];

const defaultKeyResolver = args => {
  return args.map(arg => isClass(arg) ? JSON.stringify(serialize(arg)) : arg).join(":");
};
/**
 * @platform
 */


let PlatformCache = class PlatformCache {
  disabled() {
    return !this.settings.get("cache");
  }

  $onInit() {
    const settings = this.settings.get("cache");

    if (settings) {
      const {
        caches,
        store = "memory",
        ttl
      } = settings,
            props = _objectWithoutPropertiesLoose(settings, _excluded); // eslint-disable-next-line @typescript-eslint/no-unused-vars


      this.cache = caches != null && caches.length ? cacheManager.multiCaching(caches, _extends({}, props)) : cacheManager.caching(_extends({}, props, {
        ttl,
        store
      }));
    }
  }

  defaultKeyResolver() {
    return this.settings.get("cache.keyResolver", defaultKeyResolver);
  }

  defaultTtl() {
    return this.settings.get("cache.ttl");
  }

  ttl(result, currentTtl) {
    const ttl = currentTtl === undefined ? this.defaultTtl() : currentTtl;
    return isFunction(ttl) ? ttl(result) : ttl;
  }

  wrap(key, fetch, options) {
    var _this$cache;

    if (!this.cache) {
      return fetch();
    }

    return (_this$cache = this.cache) == null ? void 0 : _this$cache.wrap(key, fetch, options);
  }

  async get(key, options = {}) {
    var _this$cache2;

    return deserialize((_this$cache2 = this.cache) == null ? void 0 : _this$cache2.get(key), options);
  }

  async set(key, value, options) {
    var _this$cache3;

    return (_this$cache3 = this.cache) == null ? void 0 : _this$cache3.set(key, value, options);
  }

  async del(key) {
    var _this$cache4;

    await ((_this$cache4 = this.cache) == null ? void 0 : _this$cache4.del(key));
  }

  async reset() {
    var _this$cache5;

    // @ts-ignore
    await ((_this$cache5 = this.cache) == null ? void 0 : _this$cache5.reset());
  }

  async keys() {
    var _this$cache6;

    if ((_this$cache6 = this.cache) != null && _this$cache6.keys) {
      return this.cache.keys();
    } // istanbul ignore next


    return [];
  }

  async getMatchingKeys(patterns) {
    const keys = await this.keys();
    return micromatch(keys, patterns);
  }

  async deleteMatchingKeys(patterns) {
    const keys = await this.getMatchingKeys(patterns);
    await Promise.all(keys.map(key => this.del(key)));
    return keys;
  }

};

__decorate([Configuration(), __metadata("design:type", Object)], PlatformCache.prototype, "settings", void 0);

PlatformCache = __decorate([Injectable()], PlatformCache);

const cleanHeaders = headers => {
  return Object.entries(headers).filter(([key]) => !["content-length", "x-request-id", "cache-control"].includes(key)).reduce((headers, [key, value]) => {
    return _extends({}, headers, {
      [key]: value
    });
  }, {});
};
/**
 * @platform
 */


let PlatformCacheInterceptor = class PlatformCacheInterceptor {
  async intercept(context, next) {
    if (this.cache.disabled()) {
      return next();
    }

    if (!this.isEndpoint(context)) {
      return this.cacheMethod(context, next);
    }

    return this.cacheResponse(context, next);
  }

  getArgs(context) {
    return context.args.reduce((args, arg) => {
      if (arg instanceof DIContext || arg instanceof IncomingMessage || arg instanceof ServerResponse) {
        return args;
      }

      if (isClass(arg)) {
        return args.concat(serialize(arg));
      }

      return args.concat(arg);
    }, []);
  }

  getOptions(context) {
    const {
      ttl,
      type,
      collectionType,
      key: k = this.cache.defaultKeyResolver()
    } = context.options || {};
    const args = this.getArgs(context);
    const keyArgs = isString(k) ? k : k(args);
    return {
      ttl,
      type,
      args,
      collectionType,
      keyArgs
    };
  }

  isEndpoint({
    target,
    propertyKey
  }) {
    return Store.fromMethod(target, propertyKey).has(JsonEntityStore);
  }

  async cacheMethod(context, next) {
    const {
      ttl,
      type,
      collectionType,
      keyArgs,
      args
    } = this.getOptions(context);
    const key = [nameOf(context.target), context.propertyKey, keyArgs].join(":");
    const cachedObject = await this.cache.get(key);

    if (cachedObject) {
      const {
        data
      } = cachedObject;
      return deserialize(JSON.parse(data), {
        collectionType,
        type
      });
    }

    const result = await next();
    const calculatedTtl = this.cache.ttl(result, ttl);
    await this.cache.set(key, {
      ttl: calculatedTtl,
      args,
      data: JSON.stringify(serialize(result, {
        type,
        collectionType
      }))
    }, {
      ttl: calculatedTtl
    });
    return result;
  }

  async cacheResponse(context, next) {
    var _this = this;

    const $ctx = context.args[context.args.length - 1];
    const {
      request,
      response
    } = $ctx;

    if (request.method !== "GET") {
      return next();
    }

    const {
      ttl,
      args,
      keyArgs
    } = this.getOptions(context);
    const key = [request.method, request.url, keyArgs].join(":");
    const cachedObject = await this.cache.get(key);

    if (cachedObject && !(response.get("cache-control") === "no-cache")) {
      return this.sendResponse(cachedObject, $ctx);
    }

    const result = await next();
    const calculatedTtl = this.cache.ttl(result, ttl);
    const expires = calculatedTtl + Date.now() / 1000;
    $ctx.response.setHeaders({
      "cache-control": `max-age=${calculatedTtl}`
    }); // cache final response with his headers and body

    response.onEnd(async function () {
      const data = JSON.stringify(response.getBody());
      const headers = cleanHeaders(response.getHeaders());
      await _this.cache.set(key, {
        ttl: calculatedTtl,
        args,
        data,
        expires,
        headers
      }, {
        ttl: calculatedTtl
      });
    });
    return result;
  }

  sendResponse(cachedObject, $ctx) {
    const {
      headers,
      ttl
    } = cachedObject;
    const {
      request,
      response
    } = $ctx;
    const requestEtag = request.get("if-none-match");

    if (requestEtag && headers.etag === requestEtag) {
      response.status(304).setHeaders(headers).body(undefined);
      return undefined;
    }

    const data = JSON.parse(cachedObject.data);
    $ctx.response.setHeaders(_extends({}, headers, {
      "x-cached": "true",
      "cache-control": `max-age=${ttl}`
    })).body(data);
    return data;
  }

};

__decorate([Inject(), __metadata("design:type", PlatformCache)], PlatformCacheInterceptor.prototype, "cache", void 0);

PlatformCacheInterceptor = __decorate([Interceptor()], PlatformCacheInterceptor);

function UseCache(options = {}) {
  return useDecorators(Intercept(PlatformCacheInterceptor, options));
}

/**
 * @ignore
 */

let PlatformCacheModule = class PlatformCacheModule {};
PlatformCacheModule = __decorate([Module({
  imports: [PlatformCache]
})], PlatformCacheModule);

export { PlatformCache, PlatformCacheModule, UseCache };
//# sourceMappingURL=index.modern.js.map
