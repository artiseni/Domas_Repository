var di = require('@tsed/di');
var core = require('@tsed/core');
var schema = require('@tsed/schema');

/**
 * Register a new Middleware class.
 *
 * @decorator
 * @classDecorator
 */

function Middleware() {
  return di.Injectable({
    type: di.ProviderType.MIDDLEWARE
  });
}

/**
 * Change authentication options.
 *
 * ```typescript
 * @Controller('/mypath')
 * @UseAuth(MyAuthStrategy, {role: ''})
 * class MyCtrl {
 *
 *   @Get('/')
 *   @AuthOptions(MyAuthStrategy, {role: 'admin'})
 *   public getResource(){}
 * }
 * ```
 *
 * @param guardAuth
 * @param options {Object} Object passed to the customer auth strategy
 * @returns {Function}
 * @decorator
 * @decorator
 * @operation
 */

function AuthOptions(guardAuth, options = {}) {
  return (...args) => {
    switch (core.decoratorTypeOf(args)) {
      case core.DecoratorTypes.METHOD:
        return schema.JsonEntityFn(entity => {
          const store = entity.store;

          if (options.responses) {
            const {
              responses
            } = options;
            store.merge("responses", responses, true);
            delete options.responses;
          }

          if (options.security) {
            const {
              security
            } = options;
            [].concat(security).forEach(security => {
              Object.entries(security).forEach(([name, scopes]) => {
                entity.operation.addSecurityScopes(name, scopes);
              });
            });
            delete options.security;
          }

          store.merge(guardAuth, options, true);
        })(...args);

      case core.DecoratorTypes.CLASS:
        core.decorateMethodsOf(args[0], AuthOptions(guardAuth, options));
        break;

      default:
        throw new core.UnsupportedDecoratorType(AuthOptions, args);
    }
  };
}

const HTTP_METHODS = ["all", "checkout", "connect", "copy", "delete", "get", "head", "lock", "merge", "mkactivity", "mkcol", "move", "m-search", "notify", "options", "param", "patch", "post", "propfind", "propatch", "purge", "put", "report", "search", "subscribe", "trace", "unlock", "unsuscribe"];

function mapUseOptions(args) {
  let method = undefined;
  let path = undefined;
  const middlewares = args.filter(arg => {
    if (typeof arg === "string" && HTTP_METHODS.includes(arg)) {
      method = arg;
      return false;
    }

    if (typeof arg === "string" || arg instanceof RegExp) {
      path = arg ? arg : "/";
      return false;
    }

    return !!arg;
  });
  return {
    path,
    method,
    middlewares
  };
}

/**
 * Mounts the specified middleware function or functions at the specified path: the middleware function is executed when
 * the base of the requested path matches `path.
 *
 * ```typescript
 * @Controller('/')
 * @Use(Middleware1)
 * export class Ctrl {
 *
 *    @Get('/')
 *    @Use(Middleware2)
 *    get() { }
 * }
 *
 * ```
 *
 * @returns {Function}
 * @param args
 * @decorator
 * @operation
 */

function Use(...args) {
  return schema.JsonEntityFn((entity, parameters) => {
    switch (entity.decoratorType) {
      case core.DecoratorTypes.METHOD:
        const options = mapUseOptions(args);
        options.path && schema.OperationPath(options.method || schema.OperationMethods.CUSTOM, options.path)(...parameters);
        entity.use(args);
        break;

      case core.DecoratorTypes.CLASS:
        entity.store.merge("middlewares", {
          use: args
        });
        break;

      default:
        throw new core.UnsupportedDecoratorType(Use, parameters);
    }
  });
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

/**
 * Mounts the specified middleware function or functions at the specified path: the middleware function is executed when
 * the base of the requested path matches `path.
 *
 * ```typescript
 * @Controller('/')
 * @UseAfter(Middleware1)
 * export class Ctrl {
 *
 *    @Get('/')
 *    @UseAfter(Middleware2)
 *    get() { }
 * }
 * ```
 *
 * @returns {function(any, any, any): *}
 * @param args
 * @decorator
 * @operation
 */

function UseAfter(...args) {
  return schema.JsonEntityFn((entity, parameters) => {
    switch (entity.decoratorType) {
      case core.DecoratorTypes.METHOD:
        const endpoint = entity;
        endpoint.afterMiddlewares = args.concat(endpoint.afterMiddlewares);
        break;

      case core.DecoratorTypes.CLASS:
        const middlewares = entity.store.get("middlewares") || {};
        entity.store.set("middlewares", _extends({}, middlewares, {
          useAfter: [...args, ...(middlewares.useAfter || [])]
        }));
        break;

      default:
        throw new core.UnsupportedDecoratorType(UseAfter, parameters);
    }
  });
}

/**
 * Mounts the specified middleware function or functions at the specified path: the middleware function is executed when
 * the base of the requested path matches `path.
 *
 * ```typescript
 * @Controller('/')
 * @UseBefore(Middleware1) // called only one time before all endpoint
 * export class Ctrl {
 *
 *    @Get('/')
 *    @UseBefore(Middleware2)
 *    get() { }
 * }
 * ```
 *
 * @returns {function(any, any, any): *}
 * @param args
 * @decorator
 * @operation
 */

function UseBefore(...args) {
  return schema.JsonEntityFn((entity, parameters) => {
    switch (entity.decoratorType) {
      case core.DecoratorTypes.METHOD:
        entity.beforeMiddlewares = args.concat(entity.beforeMiddlewares);
        break;

      case core.DecoratorTypes.CLASS:
        const middlewares = entity.store.get("middlewares") || {};
        entity.store.set("middlewares", _extends({}, middlewares, {
          useBefore: [...args, ...(middlewares.useBefore || [])]
        }));
        break;

      default:
        throw new core.UnsupportedDecoratorType(UseBefore, parameters);
    }
  });
}

/**
 * Use custom authentication strategy on your endpoint.
 *
 * ```typescript
 * @Controller('/mypath')
 * @UseAuth(MyAuthStrategy)
 * class MyCtrl {
 *
 *   @Get('/')
 *   @UseAuth(MyAuthStrategy, {role: 'admin'})
 *   public getResource(){}
 * }
 * ```
 *
 * @param guardAuth {Type<any>} A middleware which implement a custom auth strategy
 * @param options {Object} Object passed to the customer auth strategy
 * @returns {Function}
 * @decorator
 * @operation
 */

function UseAuth(guardAuth, options = {}) {
  return (...args) => {
    switch (core.decoratorTypeOf(args)) {
      case core.DecoratorTypes.METHOD:
        return core.useDecorators(core.StoreFn(store => {
          if (!store.has(guardAuth)) {
            return UseBefore(guardAuth);
          }
        }), AuthOptions(guardAuth, options))(...args);

      case core.DecoratorTypes.CLASS:
        core.decorateMethodsOf(args[0], UseAuth(guardAuth, options));
        break;

      default:
        throw new core.UnsupportedDecoratorType(UseAuth, args);
    }
  };
}

/**
 * Mounts the specified middleware function or functions at the specified path: the middleware function is executed when
 * the base of the requested path matches `path.
 *
 * ```typescript
 * @Controller('/')
 * @UseBeforeEach(Middleware1)  // Called before each endpoint
 * export class Ctrl {
 *
 *    @Get('/')
 *    get() { }
 * }
 *
 * ```
 *
 * @returns {Function}
 * @param args
 * @decorator
 * @operation
 */

function UseBeforeEach(...args) {
  return (...decoratorArgs) => {
    switch (core.decoratorTypeOf(decoratorArgs)) {
      case core.DecoratorTypes.METHOD:
        return UseBefore(...args)(...decoratorArgs);

      case core.DecoratorTypes.CLASS:
        core.decorateMethodsOf(decoratorArgs[0], UseBefore(...args));
        break;

      default:
        throw new core.UnsupportedDecoratorType(UseBeforeEach, decoratorArgs);
    }
  };
}

function getMiddlewaresForHook(hook, settings, defaultHook = "") {
  const {
    env,
    middlewares = []
  } = settings;
  return middlewares.map(middleware => {
    return core.isFunction(middleware) ? {
      env,
      hook: defaultHook,
      use: middleware
    } : _extends({
      env,
      hook: defaultHook
    }, middleware);
  }).filter(options => {
    return options.use && options.env === env && options.hook === hook;
  });
}

exports.AuthOptions = AuthOptions;
exports.Middleware = Middleware;
exports.Use = Use;
exports.UseAfter = UseAfter;
exports.UseAuth = UseAuth;
exports.UseBefore = UseBefore;
exports.UseBeforeEach = UseBeforeEach;
exports.getMiddlewaresForHook = getMiddlewaresForHook;
//# sourceMappingURL=index.js.map
