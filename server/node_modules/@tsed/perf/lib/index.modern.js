import { isPromise, methodsOf, classOf, descriptorOf, nameOf } from '@tsed/core';
import chalk from 'chalk';

var id = 0;

function _classPrivateFieldLooseKey(name) {
  return "__private_" + id++ + "_" + name;
}

function _classPrivateFieldLooseBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }

  return receiver;
}

function now() {
  return process.hrtime.bigint();
}
function toMs(time) {
  return Math.round(Number(time) / 1000) / 1000;
}
function fromNow(time) {
  return toMs(now() - time);
}

var _latest = /*#__PURE__*/_classPrivateFieldLooseKey("latest");

var _start = /*#__PURE__*/_classPrivateFieldLooseKey("start");

class Perf {
  constructor() {
    Object.defineProperty(this, _latest, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _start, {
      writable: true,
      value: void 0
    });
    this.start = this.start.bind(this);
    this.end = this.end.bind(this);
    this.run = this.run.bind(this);
    this.fromStart = this.fromStart.bind(this);
    this.fromLatest = this.fromLatest.bind(this);
  }

  start() {
    _classPrivateFieldLooseBase(this, _start)[_start] = _classPrivateFieldLooseBase(this, _latest)[_latest] = now();
    return this;
  }

  async runFor(it, fn) {
    const {
      time
    } = await this.run(async function () {
      for (let i = 0; i < it; i++) {
        await fn();
      }
    });
    return time;
  }

  run(fn, onTime) {
    const date = now();
    const result = fn();

    const getDiff = result => {
      const diff = fromNow(date);
      _classPrivateFieldLooseBase(this, _latest)[_latest] = now();
      onTime && onTime(diff);
      return onTime ? result : {
        result,
        time: diff
      };
    };

    if (isPromise(result)) {
      return result.then(getDiff);
    }

    return getDiff(result);
  }

  fromStart() {
    return fromNow(_classPrivateFieldLooseBase(this, _start)[_start]);
  }

  fromLatest() {
    const diff = fromNow(_classPrivateFieldLooseBase(this, _latest)[_latest]);
    _classPrivateFieldLooseBase(this, _latest)[_latest] = now();
    return diff;
  }

  end() {
    const diff = fromNow(_classPrivateFieldLooseBase(this, _start)[_start]);
    _classPrivateFieldLooseBase(this, _start)[_start] = _classPrivateFieldLooseBase(this, _latest)[_latest] = now();
    return diff;
  }

}

const loggers = new Map(); // istanbul ignore next

var _perf = /*#__PURE__*/_classPrivateFieldLooseKey("perf");

var _enabled = /*#__PURE__*/_classPrivateFieldLooseKey("enabled");

class PerfLogger {
  constructor(label = "perf", levels = {
    10: "green",
    50: "yellow",
    100: "red"
  }) {
    Object.defineProperty(this, _perf, {
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, _enabled, {
      writable: true,
      value: void 0
    });
    this.label = label;
    this.levels = levels;
    _classPrivateFieldLooseBase(this, _perf)[_perf] = new Perf();
    _classPrivateFieldLooseBase(this, _enabled)[_enabled] = false;
    this.wrap = this.wrap.bind(this);
    this.log = this.log.bind(this);
    this.start = this.start.bind(this);
    this.end = this.end.bind(this);
    this.bind = this.bind.bind(this);
  }

  static get(label) {
    if (loggers.get(label)) {
      return loggers.get(label);
    }

    const logger = loggers.get(label) || new PerfLogger(label);
    loggers.set(label, logger);
    return logger;
  }

  start() {
    _classPrivateFieldLooseBase(this, _enabled)[_enabled] = true;

    _classPrivateFieldLooseBase(this, _perf)[_perf].start();

    return this;
  }

  log(...args) {
    if (_classPrivateFieldLooseBase(this, _enabled)[_enabled]) {
      console.debug(this.formatLog(["LOG   -", ...args], _classPrivateFieldLooseBase(this, _perf)[_perf].fromLatest(), "from latest: "));
    }

    return this;
  }

  bind(instance) {
    const methods = methodsOf(classOf(instance));
    const {
      wrap,
      log
    } = this;
    methods.forEach(({
      target,
      propertyKey
    }) => {
      const descriptor = descriptorOf(target, propertyKey);
      const name = nameOf(target);

      if (descriptor.value) {
        const fn = instance[propertyKey].bind(instance);

        if (propertyKey === "log") {
          instance[propertyKey] = (...args) => {
            log(...args);
            return fn(...args);
          };
        } else {
          instance[propertyKey] = (...args) => {
            return wrap(() => fn(...args), `${name}.${propertyKey}()`);
          };
        }
      }
    });
    return instance;
  }

  wrap(fn, name = nameOf(fn)) {
    if (!_classPrivateFieldLooseBase(this, _enabled)[_enabled]) {
      return fn();
    }

    console.debug(this.formatLog([`START - ${name}`], _classPrivateFieldLooseBase(this, _perf)[_perf].fromLatest(), "from latest: "));
    return _classPrivateFieldLooseBase(this, _perf)[_perf].run(fn, time => {
      if (_classPrivateFieldLooseBase(this, _enabled)[_enabled]) {
        console.debug(this.formatLog([`END   - ${name}`], time, "method: "));
      }
    });
  }

  end() {
    if (_classPrivateFieldLooseBase(this, _enabled)[_enabled]) {
      console.debug(this.formatLog(["ending"], _classPrivateFieldLooseBase(this, _perf)[_perf].end(), "from start: "));
      _classPrivateFieldLooseBase(this, _enabled)[_enabled] = false;
    }

    return this;
  }

  formatLog(log, diff, wrap = "") {
    const dataLog = log.join(" ") + "                                                                                    ";
    const diffLabel = this.formatDiff(diff, wrap);

    const fromStart = _classPrivateFieldLooseBase(this, _perf)[_perf].fromStart();

    const globalDiff = ("     " + fromStart.toFixed(3) + "ms").slice(-10);
    return `[${this.label}] ${globalDiff} - ${String(dataLog)}`.slice(0, 80) + ` ${diffLabel}`;
  }

  formatDiff(diff, prefix = "") {
    const label = `(${prefix}+${diff}ms)`;
    const list = Object.entries(this.levels);
    const [, color] = list.find(([level]) => diff <= +level) || list[list.length - 1];
    return chalk[color](label);
  }

}

export { Perf, PerfLogger };
//# sourceMappingURL=index.modern.js.map
