var tslib = require('tslib');
var core = require('@tsed/core');
var exceptions = require('@tsed/exceptions');
var schema = require('@tsed/schema');

/**
 * @ignore
 */
// tslint:disable-next-line:variable-name
const JsonMapperTypesContainer = new Map();
/**
 * @ignore
 */

function registerJsonTypeMapper(type, token) {
  JsonMapperTypesContainer.set(type, new token());
}
/**
 * @ignore
 */

function getJsonMapperTypes() {
  return JsonMapperTypesContainer;
}

/**
 * Register a new JsonMapper Type
 * @param types
 * @constructor
 */

function JsonMapper(...types) {
  return target => {
    types.forEach(type => {
      registerJsonTypeMapper(type, target);
    });
  };
}

/**
 * Mapper for `Array` type.
 * @jsonmapper
 * @component
 */

exports.ArrayMapper = class ArrayMapper {
  deserialize(data, options) {
    return [].concat(data).map(item => options.next(item));
  }

  serialize(data, options) {
    return [].concat(data).map(item => options.next(item));
  }

};
exports.ArrayMapper = tslib.__decorate([JsonMapper(Array)], exports.ArrayMapper);

/**
 * Mapper for `Date` type.
 * @jsonmapper
 * @component
 */

exports.DateMapper = class DateMapper {
  deserialize(data) {
    // don't convert unexpected data. In normal case, Ajv reject unexpected data.
    // But by default, we have to skip data deserialization and let user to apply
    // the right mapping
    if (core.isBoolean(data) || data === null || data === undefined) {
      return data;
    }

    return new Date(data);
  }

  serialize(object) {
    return new Date(object).toISOString();
  }

};
exports.DateMapper = tslib.__decorate([JsonMapper(Date)], exports.DateMapper);

/**
 * Mapper for `Map` type.
 * @jsonmapper
 * @component
 */

exports.MapMapper = class MapMapper {
  deserialize(data, ctx) {
    const obj = new Map();
    core.objectKeys(data).forEach(key => {
      obj.set(key, ctx.next(data[key]));
    });
    return obj;
  }

  serialize(data, ctx) {
    const obj = {};
    data.forEach((value, key) => obj[key] = ctx.next(value));
    return obj;
  }

};
exports.MapMapper = tslib.__decorate([JsonMapper(Map)], exports.MapMapper);

/**
 * Mapper for the `String`, `Number` and `Boolean` types.
 * @jsonmapper
 * @component
 */

exports.PrimitiveMapper = class PrimitiveMapper {
  deserialize(data, ctx) {
    switch (ctx.type) {
      case String:
        return data === null ? null : "" + data;

      case Number:
        if ([null, "null"].includes(data)) return null;
        const n = +data;

        if (isNaN(n)) {
          throw new exceptions.BadRequest("Cast error. Expression value is not a number.");
        }

        return n;

      case Boolean:
        if (["true", "1", true].includes(data)) return true;
        if (["false", "0", false].includes(data)) return false;
        if ([null, "null"].includes(data)) return null;
        if (data === undefined) return undefined;
        return !!data;
    }
  }

  serialize(object) {
    return object;
  }

};
exports.PrimitiveMapper = tslib.__decorate([JsonMapper(String, Number, Boolean)], exports.PrimitiveMapper);

/**
 * Mapper for the `Set` Type.
 * @jsonmapper
 * @component
 */

exports.SetMapper = class SetMapper {
  deserialize(data, ctx) {
    const obj = new Set();
    core.objectKeys(data).forEach(key => {
      obj.add(ctx.next(data[key]));
    });
    return obj;
  }

  serialize(data, ctx) {
    const array = [];
    data.forEach(value => array.push(ctx.next(value)));
    return array;
  }

};
exports.SetMapper = tslib.__decorate([JsonMapper(Set)], exports.SetMapper);

/**
 * Mapper for the `Symbol` type.
 *
 * @jsonmapper
 * @component
 */

exports.SymbolMapper = class SymbolMapper {
  deserialize(data) {
    return Symbol.for(data);
  }

  serialize(object) {
    return object.toString().replace("Symbol(", "").replace(")", "");
  }

};
exports.SymbolMapper = tslib.__decorate([JsonMapper(Symbol)], exports.SymbolMapper);

/**
 * Call the function before property deserialization.
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @OnDeserialize(v => v + 1)
 *    property: string;
 * }
 * ```
 *
 * @returns {Function}
 * @decorator
 * @schema
 * @property
 * @param cb
 */

function OnDeserialize(cb) {
  return schema.JsonEntityFn(storedJson => {
    storedJson.schema.$hooks.on("onDeserialize", cb);
  });
}

/**
 * Call the function before property serialization.
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @OnSerialize(v => v + 1)
 *    property: string;
 * }
 * ```
 *
 * @returns {Function}
 * @decorator
 * @schema
 * @property
 * @param cb
 */

function OnSerialize(cb) {
  return schema.JsonEntityFn(storedJson => {
    storedJson.schema.$hooks.on("onSerialize", cb);
  });
}

/**
 * Call the function after JsonMapper.
 *
 * ## Example
 *
 * ```typescript
 * @AfterDeserialize((data: Model) => { // After deserialize get the instance class
 *    if (data.prop1 === 'VALUE' && data.prop2 !== 'VALUE2') {
 *      throw BadRequest('MyMessage'); // or throw a ValidationError
 *    } else {
 *      data.prop2 = 'VALUE2';
 *      return data;
 *    }
 * })
 * class Model {
 *    @Property()
 *    prop1: string;
 *    @Property()
 *    prop2: string;
 * }
 * ```
 *
 * @returns {Function}
 * @decorator
 * @schema
 * @property
 * @param cb
 */

function AfterDeserialize(cb) {
  return schema.JsonEntityFn(storedJson => {
    storedJson.schema.$hooks.on("afterDeserialize", cb);
  });
}

/**
 * Call the function before JsonMapper.
 *
 * ## Example
 *
 * ```typescript
 * @BeforeDeserialize((data: Record<string, unknown>) => { // Before deserialize get the data
 *    if (data.prop1 === 'VALUE' && data.prop2 !== 'VALUE2') {
 *      throw BadRequest('MyMessage'); // or throw a ValidationError
 *    } else {
 *      data.prop2 = 'VALUE2';
 *      return data;
 *    }
 * })
 * class Model {
 *    @Property()
 *    prop1: string;
 *    @Property()
 *    prop2: string;
 * }
 * ```
 *
 * @returns {Function}
 * @decorator
 * @schema
 * @property
 * @param cb
 */

function BeforeDeserialize(cb) {
  return schema.JsonEntityFn(storedJson => {
    storedJson.schema.$hooks.on("beforeDeserialize", cb);
  });
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/**
 * @ignore
 */

class JsonMapperContext {
  constructor({
    type,
    collectionType,
    next,
    options
  }) {
    this.type = type;
    this.collectionType = core.isCollection(collectionType) ? collectionType : undefined;
    this._next = next;
    this.options = options;
  }

  next(data) {
    return this._next(data, _extends({}, this.options, {
      type: this.type
    }));
  }

}

function alterAfterDeserialize(data, schema, options) {
  var _schema$$hooks;

  return schema == null ? void 0 : (_schema$$hooks = schema.$hooks) == null ? void 0 : _schema$$hooks.alter("afterDeserialize", data, [options]);
}

function alterBeforeDeserialize(data, schema, options) {
  var _schema$$hooks;

  return schema == null ? void 0 : (_schema$$hooks = schema.$hooks) == null ? void 0 : _schema$$hooks.alter("beforeDeserialize", data, [options]);
}

const _excluded$1 = ["collectionType"],
      _excluded2$1 = ["type"],
      _excluded3 = ["type", "store"];

function isDeserializable(obj, options) {
  if (!!options.collectionType && core.isNil(obj) || obj === undefined) {
    return false;
  }

  return !(core.isEmpty(options.type) || options.type === Object && !options.collectionType);
}

function alterValue$1(schema, value, options) {
  return schema.$hooks.alter("onDeserialize", value, [options]);
}

function transformCollection(src, options) {
  var _types$get;

  const {
    types,
    type = Object,
    collectionType
  } = options;
  const context = new JsonMapperContext({
    type,
    collectionType,
    options,
    next: (data, _ref) => {
      let options = _objectWithoutPropertiesLoose(_ref, _excluded$1);

      return deserialize(data, options);
    }
  });
  return types == null ? void 0 : (_types$get = types.get(options.collectionType)) == null ? void 0 : _types$get.deserialize(src, context);
}

function transformType(src, options) {
  var _types$get2;

  const {
    types,
    type = Object
  } = options;
  const context = new JsonMapperContext({
    type,
    options,
    next: (data, _ref2) => {
      let options = _objectWithoutPropertiesLoose(_ref2, _excluded2$1);

      return deserialize(data, options);
    }
  });
  return types == null ? void 0 : (_types$get2 = types.get(type)) == null ? void 0 : _types$get2.deserialize(src, context);
}
/**
 * Transform given plain object to class.
 * @param src
 * @param options
 */


function plainObjectToClass(src, options) {
  if (core.isEmpty(src)) {
    return src;
  }

  const {
    type,
    store = schema.JsonEntityStore.from(type)
  } = options,
        next = _objectWithoutPropertiesLoose(options, _excluded3);

  const propertiesMap = schema.getProperties(store, _extends({}, options, {
    withIgnoredProps: true
  }));
  let keys = core.objectKeys(src);
  const additionalProperties = propertiesMap.size ? !!store.schema.get("additionalProperties") || options.additionalProperties : true;
  src = alterBeforeDeserialize(src, store.schema, options);
  const out = new type(src);
  propertiesMap.forEach(propStore => {
    const key = options.useAlias ? propStore.parent.schema.getAliasOf(propStore.propertyName) || propStore.propertyName : propStore.propertyName;
    keys = keys.filter(k => k !== key);
    next.type = propStore.computedType;

    if (schema.alterIgnore(propStore.itemSchema, options)) {
      return;
    }

    let value = alterValue$1(propStore.schema, src[key], _extends({}, options, {
      self: src
    }));

    if (propStore.schema.hasGenerics) {
      next.nestedGenerics = propStore.schema.nestedGenerics;
    } else if (propStore.schema.isGeneric && options.nestedGenerics) {
      const [genericTypes = [], ...nestedGenerics] = options.nestedGenerics;
      const genericLabels = propStore.parent.schema.genericLabels || [];
      next.type = genericTypes[genericLabels.indexOf(propStore.schema.genericType)] || Object;

      if (next.type instanceof schema.JsonSchema) {
        next.type = next.type.getTarget();
      }

      next.nestedGenerics = nestedGenerics;
    }

    value = deserialize(value, _extends({}, next, {
      type: value === src[key] ? next.type : undefined,
      collectionType: propStore.collectionType
    }));

    if (value !== undefined) {
      out[propStore.propertyName] = value;
    }
  });

  if (additionalProperties) {
    keys.forEach(key => {
      out[key] = src[key];
    });
  }

  return alterAfterDeserialize(out, store.schema, options);
}

function buildOptions(options) {
  if (options.store instanceof schema.JsonEntityStore) {
    if (options.store.parameter && options.store.parameter.nestedGenerics.length) {
      options.nestedGenerics = options.store.parameter.nestedGenerics;
    }

    options.type = options.store.computedType;
    options.collectionType = options.store.collectionType;
    delete options.store;
  }

  return _extends({
    groups: false,
    useAlias: true
  }, options, {
    type: options.type ? options.type : undefined,
    types: options.types ? options.types : getJsonMapperTypes()
  });
}
/**
 * Transform given source to class base on the given `options.type`.
 *
 * @param src
 * @param options
 */


function deserialize(src, options = {}) {
  var _options$types2;

  options = buildOptions(options);

  if (!isDeserializable(src, options)) {
    return src;
  }

  if (!options.collectionType && core.isArray(src)) {
    options.collectionType = Array;
  }

  if (options.collectionType) {
    var _options$types;

    if (!((_options$types = options.types) != null && _options$types.has(options.collectionType))) {
      throw new Error(`${core.nameOf(options.collectionType)} is not supported by JsonMapper.`);
    }

    return transformCollection(src, options);
  }

  if ((_options$types2 = options.types) != null && _options$types2.has(options.type)) {
    return transformType(src, options);
  } // class converter


  return plainObjectToClass(src, options);
}

const _excluded = ["useAlias", "type"],
      _excluded2 = ["type", "collectionType", "groups"];

function alterValue(schema, value, options) {
  return schema.$hooks.alter("onSerialize", value, [options]);
}

function getSchemaProperties(storedJson, obj) {
  const stores = Array.from(schema.getPropertiesStores(storedJson).entries());

  if (!stores.length) {
    // fallback to auto discovering field from obj
    core.objectKeys(obj).forEach(key => {
      const propStore = schema.JsonEntityStore.from(core.classOf(storedJson.target), key);
      stores.push([key, propStore]);
    });
  }

  return stores;
}

function getObjectProperties(obj) {
  return Object.entries(obj).filter(([, value]) => !core.isFunction(value));
}

function getType(propStore, value) {
  if (core.isNil(value) || propStore.type === Object || core.isCollection(propStore.type)) {
    return undefined;
  }

  return propStore.type;
}

function classToPlainObject(obj, options) {
  const {
    useAlias = true,
    type
  } = options,
        props = _objectWithoutPropertiesLoose(options, _excluded);

  const entity = schema.JsonEntityStore.from(type || obj);
  return getSchemaProperties(entity, obj).reduce((newObj, [key, propStore]) => {
    const schema$1 = propStore.schema;

    if (schema.alterIgnore(schema$1, _extends({
      useAlias
    }, props, {
      self: obj
    }))) {
      return newObj;
    }

    let value = alterValue(schema$1, obj[key], _extends({
      useAlias
    }, props, {
      self: obj
    }));
    value = serialize(value, _extends({
      useAlias,
      type: value === obj[key] ? getType(propStore, value) : undefined,
      collectionType: propStore.collectionType
    }, props));

    if (value === undefined) {
      return newObj;
    }

    key = useAlias ? propStore.parent.schema.getAliasOf(key) || key : key;
    return _extends({}, newObj, {
      [key]: value
    });
  }, {});
}

function toObject(obj, options) {
  return getObjectProperties(obj).reduce((newObj, [key, value]) => _extends({}, newObj, {
    [key]: serialize(value, options)
  }), {});
}

function serialize(obj, _ref = {}) {
  let {
    type,
    groups = false
  } = _ref,
      options = _objectWithoutPropertiesLoose(_ref, _excluded2);

  const types = options.types ? options.types : getJsonMapperTypes(); // prevent Object metadata assignation. TypeScript set Object by default on endpoint.type

  type = type === Object ? undefined : type;
  options.groups = groups;

  if (core.isEmpty(obj)) {
    return obj;
  }

  if (typeof obj.toJSON === "function") {
    return obj.toJSON(options);
  }

  if (type && core.isClass(type)) {
    options.type = type;
  }

  if (core.isCollection(obj) && !options.collectionType) {
    type = core.classOf(obj);
    options.collectionType = type;
  }

  type = core.classOf(type || obj);
  const context = new JsonMapperContext({
    type,
    options,
    next: data => serialize(data, _extends({}, options, {
      collectionType: undefined,
      type: options.type
    }))
  });

  if (types.has(type)) {
    const jsonMapper = types.get(type);
    return jsonMapper.serialize(obj, context);
  }

  if (core.isArray(obj)) {
    var _types$get;

    // Serialize Array class like
    return (_types$get = types.get(Array)) == null ? void 0 : _types$get.serialize(obj, context);
  }

  return !core.isPlainObject(type) ? classToPlainObject(obj, options) : toObject(obj, options);
}

exports.AfterDeserialize = AfterDeserialize;
exports.BeforeDeserialize = BeforeDeserialize;
exports.JsonMapper = JsonMapper;
exports.JsonMapperContext = JsonMapperContext;
exports.OnDeserialize = OnDeserialize;
exports.OnSerialize = OnSerialize;
exports.classToPlainObject = classToPlainObject;
exports.deserialize = deserialize;
exports.getJsonMapperTypes = getJsonMapperTypes;
exports.plainObjectToClass = plainObjectToClass;
exports.registerJsonTypeMapper = registerJsonTypeMapper;
exports.serialize = serialize;
//# sourceMappingURL=index.js.map
