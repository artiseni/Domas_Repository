import { BadRequest } from '@tsed/exceptions';
import { __decorate, __metadata } from 'tslib';
import { getValue, cleanObject, deepClone, nameOf, prototypeOf, setValue, useDecorators, StoreSet } from '@tsed/core';
import { registerProvider, Configuration, InjectorService, ProviderScope, Constant, Inject, Injectable } from '@tsed/di';
import { getJsonSchema, JsonSchema, JsonEntityStore } from '@tsed/schema';
import Ajv from 'ajv';
import AjvFormats from 'ajv-formats';

class AjvValidationError extends BadRequest {
  constructor(message, errors = []) {
    super(message);
    this.name = "AJV_VALIDATION_ERROR";
    this.errors = errors;
  }

}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function getPath(error) {
  return getValue(error, "dataPath", getValue(error, "instancePath", "")).replace(/\//gi, ".");
}

function defaultErrorFormatter(error) {
  const value = JSON.stringify(error.data === undefined ? "undefined" : error.data);

  const join = list => list.filter(Boolean).join("").trim();

  error.dataPath = getPath(error);
  const [, indexPath, ...paths] = error.dataPath.split(".");
  const deepPaths = paths.length ? "." + paths.join(".") : "";

  if (error.collectionName) {
    switch (error.collectionName) {
      case "Array":
        return join([`${error.modelName || ""}[${indexPath}]${deepPaths}`, ` ${error.message}. Given value: ${value}`]);

      case "Map":
        return join([`Map<${indexPath}, ${error.modelName || ""}>${deepPaths}`, ` ${error.message}. Given value: ${value}`]);

      case "Set":
        return join([`Set<${indexPath}, ${error.modelName || ""}>${deepPaths}`, ` ${error.message}. Given value: ${value}`]);
    }
  }

  return join([!error.modelName && "Value", `${error.modelName || ""}`, error.dataPath, ` ${error.message}. Given value: ${value}`]);
}

const _excluded$1 = ["errorFormatter", "keywords"];

function getHandler(key, service) {
  if (service[key]) {
    return service[key].bind(service);
  }
}

function getKeywordProviders(injector) {
  return injector.getProviders("ajv:keyword");
}

function bindKeywords(injector) {
  return getKeywordProviders(injector).map(provider => {
    const options = provider.store.get("ajv:keyword", {});
    const service = injector.invoke(provider.token);
    return cleanObject(_extends({}, options, {
      validate: getHandler("validate", service),
      compile: getHandler("compile", service),
      code: getHandler("code", service),
      macro: getHandler("macro", service)
    }));
  });
}

function getFormatsProviders(injector) {
  return injector.getProviders("ajv:formats");
}

function getFormats(injector) {
  return getFormatsProviders(injector).map(provider => {
    var _service$compare;

    const {
      name,
      options
    } = provider.store.get("ajv:formats", {});
    const service = injector.invoke(provider.token);
    return {
      name,
      options: _extends({}, options, {
        validate: service.validate.bind(service),
        compare: (_service$compare = service.compare) == null ? void 0 : _service$compare.bind(service)
      })
    };
  });
}

registerProvider({
  provide: Ajv,
  deps: [Configuration, InjectorService],
  scope: ProviderScope.SINGLETON,

  useFactory(configuration, injector) {
    const _ref = configuration.get("ajv") || {},
          {
      keywords = []
    } = _ref,
          props = _objectWithoutPropertiesLoose(_ref, _excluded$1);

    const options = _extends({
      verbose: false,
      coerceTypes: true,
      strict: false,
      keywords: [...keywords, ...bindKeywords(injector)]
    }, props);

    const ajv = new Ajv(options);
    AjvFormats(ajv);
    getFormats(injector).forEach(({
      name,
      options
    }) => {
      ajv.addFormat(name, options);
    });
    return ajv;
  }

});

const _excluded = ["schema", "type", "collectionType"];
let AjvService = class AjvService {
  async validate(value, options) {
    let _this$mapOptions = this.mapOptions(options),
        {
      schema,
      type,
      collectionType
    } = _this$mapOptions,
        additionalOptions = _objectWithoutPropertiesLoose(_this$mapOptions, _excluded);

    schema = schema || getJsonSchema(type, _extends({}, additionalOptions, {
      customKeys: true
    }));

    if (schema) {
      const localValue = deepClone(value);
      const valid = await this.ajv.validate(schema, localValue);

      if (!valid) {
        throw this.mapErrors(this.ajv.errors || [], {
          type,
          collectionType,
          async: true,
          value: localValue
        });
      }
    }

    return value;
  }

  mapOptions(options) {
    if (options instanceof JsonSchema) {
      return {
        schema: options.toJSON({
          customKeys: true
        })
      };
    }

    return options;
  }

  mapErrors(errors, options) {
    const {
      type,
      collectionType,
      value
    } = options;
    const message = errors.map(error => {
      if (collectionType) {
        error.collectionName = nameOf(collectionType);
      }

      const dataPath = getPath(error);

      if (!error.data) {
        if (dataPath) {
          error.data = getValue(value, dataPath.replace(/^\./, ""));
        } else if (error.schemaPath !== "#/required") {
          error.data = value;
        }
      }

      if (dataPath && dataPath.match(/pwd|password|mdp|secret/)) {
        error.data = "[REDACTED]";
      }

      if (type) {
        error.modelName = nameOf(type);
        error.message = this.mapClassError(error, type);
      }

      return this.errorFormatter.call(this, error, {});
    }).join("\n");
    return new AjvValidationError(message, errors);
  }

  mapClassError(error, targetType) {
    const propertyKey = getValue(error, "params.missingProperty");

    if (propertyKey) {
      const store = JsonEntityStore.from(prototypeOf(targetType), propertyKey);

      if (store) {
        setValue(error, "params.missingProperty", store.name || propertyKey);
        return error.message.replace(`'${propertyKey}'`, `'${store.name || propertyKey}'`);
      }
    }

    return error.message;
  }

};

__decorate([Constant("ajv.errorFormatter", defaultErrorFormatter), __metadata("design:type", Function)], AjvService.prototype, "errorFormatter", void 0);

__decorate([Inject(), __metadata("design:type", Ajv)], AjvService.prototype, "ajv", void 0);

AjvService = __decorate([Injectable()], AjvService);

/**
 * Create new keyword custom validator
 * @param options
 * @decorator
 * @ajv
 */

function Keyword(options) {
  return useDecorators(Injectable({
    type: "ajv:keyword"
  }), StoreSet("ajv:keyword", _extends({}, options, {
    metaSchema: options.metaSchema && options.metaSchema.toJSON ? options.metaSchema.toJSON() : options.metaSchema
  })));
}

/**
 * Create a new custom formats validator
 * @param name
 * @param options
 * @decorator
 * @ajv
 */

function Formats(name, options = {}) {
  return useDecorators(Injectable({
    type: "ajv:formats"
  }), StoreSet("ajv:formats", {
    name,
    options
  }));
}

export { AjvService, AjvValidationError, Formats, Keyword };
//# sourceMappingURL=index.modern.js.map
