var exceptions = require('@tsed/exceptions');
var tslib = require('tslib');
var core = require('@tsed/core');
var di = require('@tsed/di');
var schema = require('@tsed/schema');
var Ajv = require('ajv');
var AjvFormats = require('ajv-formats');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var Ajv__default = /*#__PURE__*/_interopDefaultLegacy(Ajv);
var AjvFormats__default = /*#__PURE__*/_interopDefaultLegacy(AjvFormats);

class AjvValidationError extends exceptions.BadRequest {
  constructor(message, errors = []) {
    super(message);
    this.name = "AJV_VALIDATION_ERROR";
    this.errors = errors;
  }

}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

function getPath(error) {
  return core.getValue(error, "dataPath", core.getValue(error, "instancePath", "")).replace(/\//gi, ".");
}

function defaultErrorFormatter(error) {
  const value = JSON.stringify(error.data === undefined ? "undefined" : error.data);

  const join = list => list.filter(Boolean).join("").trim();

  error.dataPath = getPath(error);
  const [, indexPath, ...paths] = error.dataPath.split(".");
  const deepPaths = paths.length ? "." + paths.join(".") : "";

  if (error.collectionName) {
    switch (error.collectionName) {
      case "Array":
        return join([`${error.modelName || ""}[${indexPath}]${deepPaths}`, ` ${error.message}. Given value: ${value}`]);

      case "Map":
        return join([`Map<${indexPath}, ${error.modelName || ""}>${deepPaths}`, ` ${error.message}. Given value: ${value}`]);

      case "Set":
        return join([`Set<${indexPath}, ${error.modelName || ""}>${deepPaths}`, ` ${error.message}. Given value: ${value}`]);
    }
  }

  return join([!error.modelName && "Value", `${error.modelName || ""}`, error.dataPath, ` ${error.message}. Given value: ${value}`]);
}

const _excluded$1 = ["errorFormatter", "keywords"];

function getHandler(key, service) {
  if (service[key]) {
    return service[key].bind(service);
  }
}

function getKeywordProviders(injector) {
  return injector.getProviders("ajv:keyword");
}

function bindKeywords(injector) {
  return getKeywordProviders(injector).map(provider => {
    const options = provider.store.get("ajv:keyword", {});
    const service = injector.invoke(provider.token);
    return core.cleanObject(_extends({}, options, {
      validate: getHandler("validate", service),
      compile: getHandler("compile", service),
      code: getHandler("code", service),
      macro: getHandler("macro", service)
    }));
  });
}

function getFormatsProviders(injector) {
  return injector.getProviders("ajv:formats");
}

function getFormats(injector) {
  return getFormatsProviders(injector).map(provider => {
    var _service$compare;

    const {
      name,
      options
    } = provider.store.get("ajv:formats", {});
    const service = injector.invoke(provider.token);
    return {
      name,
      options: _extends({}, options, {
        validate: service.validate.bind(service),
        compare: (_service$compare = service.compare) == null ? void 0 : _service$compare.bind(service)
      })
    };
  });
}

di.registerProvider({
  provide: Ajv__default['default'],
  deps: [di.Configuration, di.InjectorService],
  scope: di.ProviderScope.SINGLETON,

  useFactory(configuration, injector) {
    const _ref = configuration.get("ajv") || {},
          {
      keywords = []
    } = _ref,
          props = _objectWithoutPropertiesLoose(_ref, _excluded$1);

    const options = _extends({
      verbose: false,
      coerceTypes: true,
      strict: false,
      keywords: [...keywords, ...bindKeywords(injector)]
    }, props);

    const ajv = new Ajv__default['default'](options);
    AjvFormats__default['default'](ajv);
    getFormats(injector).forEach(({
      name,
      options
    }) => {
      ajv.addFormat(name, options);
    });
    return ajv;
  }

});

const _excluded = ["schema", "type", "collectionType"];
exports.AjvService = class AjvService {
  async validate(value, options) {
    let _this$mapOptions = this.mapOptions(options),
        {
      schema: schema$1,
      type,
      collectionType
    } = _this$mapOptions,
        additionalOptions = _objectWithoutPropertiesLoose(_this$mapOptions, _excluded);

    schema$1 = schema$1 || schema.getJsonSchema(type, _extends({}, additionalOptions, {
      customKeys: true
    }));

    if (schema$1) {
      const localValue = core.deepClone(value);
      const valid = await this.ajv.validate(schema$1, localValue);

      if (!valid) {
        throw this.mapErrors(this.ajv.errors || [], {
          type,
          collectionType,
          async: true,
          value: localValue
        });
      }
    }

    return value;
  }

  mapOptions(options) {
    if (options instanceof schema.JsonSchema) {
      return {
        schema: options.toJSON({
          customKeys: true
        })
      };
    }

    return options;
  }

  mapErrors(errors, options) {
    const {
      type,
      collectionType,
      value
    } = options;
    const message = errors.map(error => {
      if (collectionType) {
        error.collectionName = core.nameOf(collectionType);
      }

      const dataPath = getPath(error);

      if (!error.data) {
        if (dataPath) {
          error.data = core.getValue(value, dataPath.replace(/^\./, ""));
        } else if (error.schemaPath !== "#/required") {
          error.data = value;
        }
      }

      if (dataPath && dataPath.match(/pwd|password|mdp|secret/)) {
        error.data = "[REDACTED]";
      }

      if (type) {
        error.modelName = core.nameOf(type);
        error.message = this.mapClassError(error, type);
      }

      return this.errorFormatter.call(this, error, {});
    }).join("\n");
    return new AjvValidationError(message, errors);
  }

  mapClassError(error, targetType) {
    const propertyKey = core.getValue(error, "params.missingProperty");

    if (propertyKey) {
      const store = schema.JsonEntityStore.from(core.prototypeOf(targetType), propertyKey);

      if (store) {
        core.setValue(error, "params.missingProperty", store.name || propertyKey);
        return error.message.replace(`'${propertyKey}'`, `'${store.name || propertyKey}'`);
      }
    }

    return error.message;
  }

};

tslib.__decorate([di.Constant("ajv.errorFormatter", defaultErrorFormatter), tslib.__metadata("design:type", Function)], exports.AjvService.prototype, "errorFormatter", void 0);

tslib.__decorate([di.Inject(), tslib.__metadata("design:type", Ajv__default['default'])], exports.AjvService.prototype, "ajv", void 0);

exports.AjvService = tslib.__decorate([di.Injectable()], exports.AjvService);

/**
 * Create new keyword custom validator
 * @param options
 * @decorator
 * @ajv
 */

function Keyword(options) {
  return core.useDecorators(di.Injectable({
    type: "ajv:keyword"
  }), core.StoreSet("ajv:keyword", _extends({}, options, {
    metaSchema: options.metaSchema && options.metaSchema.toJSON ? options.metaSchema.toJSON() : options.metaSchema
  })));
}

/**
 * Create a new custom formats validator
 * @param name
 * @param options
 * @decorator
 * @ajv
 */

function Formats(name, options = {}) {
  return core.useDecorators(di.Injectable({
    type: "ajv:formats"
  }), core.StoreSet("ajv:formats", {
    name,
    options
  }));
}

exports.AjvValidationError = AjvValidationError;
exports.Formats = Formats;
exports.Keyword = Keyword;
//# sourceMappingURL=index.js.map
