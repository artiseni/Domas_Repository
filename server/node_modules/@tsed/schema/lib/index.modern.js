import { constantCase, pascalCase, camelCase } from 'change-case';
import { Store, decoratorTypeOf, nameOf, isFunction, cleanObject, isPromise, isClass, isSymbol, isPrimitiveOrPrimitiveClass, isClassObject, isDate, isCollection, classOf, isArrowFn, primitiveOf, isArray, Hooks, uniq, isObject, uniqBy, deepMerge, toMap, Entity, DecoratorTypes, descriptorOf, Metadata, isPrimitiveClass, ancestorsOf, mergeReducerBuilder, UnsupportedDecoratorType, decorateMethodsOf, isString, isPlainObject, useDecorators, StoreSet } from '@tsed/core';
import micromatch from 'micromatch';

const HTTP_STATUS_MESSAGES = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "Success",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "306": "(Unused)",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "310": "Too Many Redirects",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Request Entity Too Large",
  "414": "Request URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Request Range Unsatisfiable",
  "417": "Expectation Failed",
  "418": "I'm a Teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "427": "Unassigned",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "430": "Unassigned",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
function getStatusConstant(status) {
  return constantCase(HTTP_STATUS_MESSAGES[status]);
}

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}

/**
 * @ignore
 */
const JsonSchemaMappersContainer = new Map();
/**
 * @ignore
 */

function registerJsonSchemaMapper(type, mapper) {
  return JsonSchemaMappersContainer.set(type, mapper);
}
/**
 * @ignore
 */

function getJsonSchemaMapper(type) {
  // istanbul ignore next
  if (!JsonSchemaMappersContainer.has(type)) {
    throw new Error(`JsonSchema ${type} mapper doesn't exists`);
  }

  return JsonSchemaMappersContainer.get(type);
}
/**
 * @ignore
 */

function execMapper(type, schema, options) {
  return getJsonSchemaMapper(type)(schema, options);
}

/**
 * @ignore
 */
const JsonEntitiesContainer = new Map();

/**
 * @ignore
 */

function getJsonEntityStore(...args) {
  const store = Store.from(...args);

  if (!store.has("JsonEntityStore")) {
    const entityStore = JsonEntitiesContainer.get(decoratorTypeOf(args)) || JsonEntitiesContainer.get("default");
    const jsonSchemaStore = new entityStore({
      store,
      target: args[0],
      propertyKey: args[1],
      index: typeof args[2] === "number" ? args[2] : undefined,
      descriptor: typeof args[2] === "object" ? args[2] : undefined
    });
    store.set("JsonEntityStore", jsonSchemaStore);
  }

  return store.get("JsonEntityStore");
}
function isJsonEntityStore(model) {
  return model.isStore;
}

class JsonLazyRef {
  constructor(getType) {
    this.getType = getType;
    this.isLazyRef = true;
  }

  get target() {
    return this.getType();
  }

  get schema() {
    return getJsonEntityStore(this.getType()).schema;
  }

  get name() {
    return nameOf(this.getType());
  }

  toJSON(options) {
    return this.getType() && execMapper("schema", this.schema, options);
  }

}

const _excluded$8 = ["genericLabels", "genericTypes"];

/**
 * @ignore
 * @param genericLabels
 * @param genericTypes
 */
function getGenericsMap(genericLabels, genericTypes) {
  return genericLabels.reduce((map, item, index) => map.set(item, genericTypes[index]), new Map());
}
/**
 * @ignore
 * @param options
 */

function mapGenericsOptions(options) {
  if (options.genericLabels && options.genericTypes) {
    const {
      genericLabels,
      genericTypes
    } = options,
          ops = _objectWithoutPropertiesLoose(options, _excluded$8);

    return _extends({}, ops, {
      generics: getGenericsMap(genericLabels, genericTypes)
    });
  }

  return options;
}
/**
 * @ignore
 * @param value
 */

function popGenerics(value) {
  const [genericTypes, ...out] = value.nestedGenerics;
  return {
    genericTypes,
    nestedGenerics: out
  };
}

var SpecTypes;

(function (SpecTypes) {
  SpecTypes["JSON"] = "jsonschema";
  SpecTypes["SWAGGER"] = "swagger2";
  SpecTypes["OPENAPI"] = "openapi3";
})(SpecTypes || (SpecTypes = {}));

/**
 * ignore
 * @param options
 */

function getHost(options) {
  const {
    host = `#/${options.specType === "openapi3" ? "components/schemas" : "definitions"}`
  } = options;
  return host;
}
/**
 * @ignore
 */


function createRefName(name, options) {
  if (options.groups && options.groups.length) {
    return pascalCase(`${name} ${options.groups.join(" ")}`);
  }

  return name;
}
/**
 * @ignore
 */

function createRef(name, schema, options) {
  const host = getHost(options);
  const ref = {
    $ref: `${host}/${name}`
  };

  if (schema.nullable) {
    switch (options.specType) {
      case SpecTypes.OPENAPI:
        return {
          nullable: true,
          allOf: [ref]
        };

      case SpecTypes.JSON:
        return {
          oneOf: [{
            type: "null"
          }, ref]
        };
    }
  }

  return ref;
}
/**
 * @ignore
 */

function toRef(value, schema, options) {
  const name = createRefName(value.getName(), options);
  options.schemas[value.getName()] = schema;
  return createRef(name, value, options);
}

function anyMapper(input, options = {}) {
  options.schemas = options.schemas || {};

  if (typeof input !== "object" || input === null) {
    return input;
  }

  if (input instanceof JsonLazyRef) {
    return execMapper("lazyRef", input, options);
  }

  if ("toJSON" in input) {
    const schema = input.toJSON(mapGenericsOptions(options));
    return input.canRef ? toRef(input, schema, options) : schema;
  }

  return execMapper("object", input, options);
}
registerJsonSchemaMapper("any", anyMapper);

const isSuccessStatus = code => Number(code) && 200 <= Number(code) && Number(code) < 300;

class JsonMap extends Map {
  constructor(obj = {}) {
    super();
    this.assign(obj);
  }

  assign(obj = {}) {
    Object.entries(obj).forEach(([key, value]) => {
      if (isFunction(this[key])) {
        this[key](value);
      } else {
        this.set(key, value);
      }
    });
    return this;
  }

  toJSON(options = {}) {
    return execMapper("map", this, options);
  }

}

var JsonParameterTypes;

(function (JsonParameterTypes) {
  JsonParameterTypes["BODY"] = "body";
  JsonParameterTypes["PATH"] = "path";
  JsonParameterTypes["QUERY"] = "query";
  JsonParameterTypes["HEADER"] = "header";
  JsonParameterTypes["COOKIES"] = "cookie";
  JsonParameterTypes["FILES"] = "files";
})(JsonParameterTypes || (JsonParameterTypes = {}));
/**
 * @ignore
 */


function formatParameterType(type) {
  return String(type).toLowerCase().replace("raw_", "").replace("cookies", "cookie");
}
/**
 * @ignore
 */

function isParameterType(type) {
  return Object.values(JsonParameterTypes).includes(formatParameterType(type));
}

/**
 * @ignore
 */

function toJsonMapCollection(content, klass = JsonMap) {
  return Object.entries(content).reduce((content, [key, value]) => {
    content.set(key, new klass(value));
    return content;
  }, new JsonMap());
}

class JsonRequestBody extends JsonMap {
  constructor(obj = {}) {
    super(obj);
    this.content(obj.content || {});
  }

  description(description) {
    this.set("description", description);
    return this;
  }

  content(content) {
    this.set("content", toJsonMapCollection(content));
    return this;
  }

  addContent(mediaType, schema) {
    const content = this.get("content");
    const mediaContent = new JsonMap();
    mediaContent.set("schema", schema);
    content.set(mediaType, mediaContent);
    return this;
  }

  required(required) {
    this.set("required", required);
    return this;
  }

}

/**
 * Map input header to a standard open spec header
 * @param headers
 * @ignore
 */

function mapHeaders(headers) {
  return Object.keys(headers).reduce((newHeaders, key) => {
    const value = headers[key];
    let type = typeof value;
    let options = {
      example: value
    };

    if (type === "object") {
      options = value;
      options.example = options.value === undefined ? options.example : options.value;
      delete options.value;
      type = typeof options.example;
    }

    options.type = options.type || type;
    newHeaders[key] = cleanObject(options);
    return newHeaders;
  }, {});
}

const _excluded$7 = ["type"];
class JsonMedia extends JsonMap {
  constructor() {
    super(...arguments);
    this.groups = [];
  }

  schema(schema) {
    this.set("schema", schema);
    return this;
  }

  examples(examples) {
    this.set("examples", examples);
    return this;
  }

  toJSON(options = {}) {
    return super.toJSON(_extends({}, options, {
      groups: this.groups
    }));
  }

}
class JsonResponse extends JsonMap {
  constructor(obj = {}) {
    super(obj);
    this.content(obj.content || {});
  }

  description(description) {
    this.set("description", description);
    return this;
  }

  headers(headers) {
    this.set("headers", mapHeaders(headers));
    return this;
  }

  content(content) {
    this.set("content", toJsonMapCollection(content, JsonMedia));
    return this;
  }

  getContent() {
    return this.get("content");
  }

  getMedia(mediaType, create = true) {
    var _this$getContent;

    create && this.addMedia(mediaType);
    return (_this$getContent = this.getContent()) == null ? void 0 : _this$getContent.get(mediaType);
  }

  addMedia(mediaType) {
    const content = this.get("content");

    if (!content.has(mediaType)) {
      content.set(mediaType, new JsonMedia());
    }

    return this;
  }

  toJSON(options = {}) {
    const response = super.toJSON(options);

    if (this.status === 204) {
      delete response.content;
    }

    if (options.specType === SpecTypes.OPENAPI && response.headers) {
      Object.entries(response.headers).forEach(([key, _ref]) => {
        let {
          type
        } = _ref,
            props = _objectWithoutPropertiesLoose(_ref, _excluded$7);

        response.headers[key] = _extends({}, props, {
          schema: {
            type
          }
        });
      });
    }

    if (options.specType !== SpecTypes.OPENAPI && response.content) {
      const key = Object.keys(response.content)[0];
      return cleanObject(_extends({}, response, response.content[key], {
        content: undefined
      }));
    }

    return response;
  }

}

/**
 * @ignore
 */

function getComputedType(target) {
  if (isPromise(target)) {
    return Object;
  }

  if (isClass(target) || isSymbol(target) || isPrimitiveOrPrimitiveClass(target) || isClassObject(target) || isDate(target) || isCollection(target)) {
    return classOf(target);
  }

  if (isArrowFn(target)) {
    return target();
  }

  return target;
}

/**
 * @ignore
 */

const JSON_TYPES = ["string", "number", "integer", "boolean", "object", "array", "null", "any"];
function getJsonType(value) {
  if (value === null) {
    return "null";
  }

  if (isPrimitiveOrPrimitiveClass(value)) {
    if (JSON_TYPES.indexOf(value) > -1) {
      return value;
    }

    if (typeof value === "string") {
      if (value === "file") {
        return "file";
      }

      return "generic";
    }

    return primitiveOf(value);
  }

  if (value === Array) {
    return "array";
  }

  if (isArray(value)) {
    return value.map(getJsonType);
  }

  if (value === Set) {
    return "array";
  }

  if (isDate(value)) {
    return "string";
  }

  return "object";
}

/**
 * @ignore
 * @param pattern
 */
function toJsonRegex(pattern) {
  return String(pattern).replace(/^(\/)(.*)(\/)$/, "$2");
}

function mapProperties(properties) {
  // istanbul ignore next
  if (properties instanceof JsonSchema) {
    return properties;
  }

  return Object.entries(properties).reduce((properties, [key, schema]) => {
    properties[toJsonRegex(key)] = isArray(schema) ? schema.map(mapToJsonSchema) : mapToJsonSchema(schema);
    return properties;
  }, {});
}

function mapToJsonSchema(item) {
  if (isArray(item)) {
    return item.map(mapToJsonSchema);
  }

  if (item.isStore || item.isJsonSchema || item.isLazyRef) {
    return item;
  }

  if (classOf(item) !== Object && isClass(item)) {
    return getJsonEntityStore(item).schema;
  }

  if (isObject(item)) {
    return JsonSchema.from(item);
  }

  return item;
}

class JsonSchema extends Map {
  // protected _specs: Map<SpecTypes, any> = new Map();
  constructor(obj = {}) {
    super();
    this.isJsonSchema = true;
    this.$hooks = new Hooks();
    this.$required = new Set();
    this.$allow = [];
    this.$forwardGroups = false;
    this._nullable = false;
    this._nestedGenerics = [];
    this._alias = new Map();
    this._isGeneric = false;
    this._isCollection = false;
    this._ref = false;

    if (obj) {
      this.assign(obj);
    }
  }

  get alias() {
    return this._alias;
  }

  get nestedGenerics() {
    return this._nestedGenerics;
  }

  set nestedGenerics(value) {
    this._nestedGenerics = value;
  }

  get genericLabels() {
    return this._genericLabels;
  }

  set genericLabels(value) {
    this._genericLabels = value;
  }

  get nullable() {
    return this._nullable || this.$allow.includes(null);
  }

  set nullable(value) {
    this._nullable = value;
  }

  get isClass() {
    return isClass(this.class) && ![Map, Array, Set, Object, Date, Boolean, Number, String].includes(this._target);
  }
  /**
   * Current schema is a collection
   */


  get isCollection() {
    return this._isCollection;
  }
  /**
   * Current schema is a generic
   */


  get isGeneric() {
    return this._isGeneric;
  }
  /**
   * Current schema has generics items
   */


  get hasGenerics() {
    return !!(this.nestedGenerics && this.nestedGenerics.length);
  }

  get genericType() {
    return this.get("$ref");
  }

  get class() {
    return this.getComputedType();
  }

  get canRef() {
    return this._ref;
  }

  static from(obj = {}) {
    return new JsonSchema(obj);
  }

  itemSchema(obj = {}) {
    this._itemSchema = this._itemSchema || mapToJsonSchema(obj);

    this._itemSchema.assign(obj);

    return this._itemSchema;
  }

  getAliasOf(property) {
    return this._alias.get(property);
  }

  addAlias(property, alias) {
    this._alias.set(property, alias);

    this._alias.set(alias, property);

    return this;
  }

  removeAlias(property) {
    const alias = this._alias.get(property);

    alias && this._alias.delete(alias);

    this._alias.delete(property);

    return this;
  }

  $id($id) {
    super.set("$id", $id);
    return this;
  }

  $ref($ref) {
    super.set("$ref", $ref);
    return this;
  }

  $schema($schema) {
    super.set("$schema", $schema);
    return this;
  }
  /**
   * Create a ref and use name to sharing schema
   * @param name
   */


  label(name) {
    this._ref = true;
    super.set("name", name);
    return this;
  }

  name(name) {
    super.set("name", name);
    return this;
  }

  ignore(cb) {
    if (typeof cb === "boolean") {
      const bool = cb;

      cb = () => bool;
    }

    this.$hooks.on("ignore", cb);
    return this;
  }
  /**
   * This keyword can be used to supply a default JSON value associated with a particular schema.
   * It is RECOMMENDED that a default value be valid against the associated schema.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.3
   */


  default(value) {
    super.set("default", value);
    return this;
  }
  /**
   * More readible form of a one-element "enum"
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.24
   */


  const(value) {
    super.set("const", value);
    return this;
  }
  /**
   * This attribute is a string that provides a full description of the of purpose the instance property.
   *
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.2
   */


  description(description) {
    super.set("description", description);
    return this;
  }
  /**
   * This keyword determines how child instances validate for arrays, and does not directly validate the immediate instance itself.
   * If "items" is an array of schemas, validation succeeds if every instance element
   * at a position greater than the size of "items" validates against "additionalItems".
   * Otherwise, "additionalItems" MUST be ignored, as the "items" schema
   * (possibly the default value of an empty schema) is applied to all elements.
   * Omitting this keyword has the same behavior as an empty schema.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.10
   */


  additionalItems(additionalItems) {
    super.set("additionalItems", mapToJsonSchema(additionalItems));
    return this;
  }
  /**
   * An array instance is valid against "contains" if at least one of its elements is valid against the given schema.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.14
   */


  contains(contains) {
    super.set("contains", mapToJsonSchema(contains));
    return this;
  }
  /**
   * Array of examples with no validation effect the value of "default" is usable as an example without repeating it under this keyword
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.4
   */


  examples(examples) {
    super.set("examples", examples);
    return this;
  }
  /**
   * Array of examples with no validation effect the value of "default" is usable as an example without repeating it under this keyword
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.4
   */


  example(...examples) {
    return this.examples(examples);
  }
  /**
   * This keyword determines how child instances validate for arrays, and does not directly validate the immediate instance itself.
   * Omitting this keyword has the same behavior as an empty schema.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.9
   */


  items(items) {
    super.set("items", this._itemSchema = mapToJsonSchema(items));
    return this;
  }
  /**
   * Must be a non-negative integer.
   * An array instance is valid against "maxItems" if its size is less than, or equal to, the value of this keyword.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.11
   */


  maxItems(maxItems) {
    super.set("maxItems", maxItems);
    return this;
  }
  /**
   * Must be a non-negative integer.
   * An array instance is valid against "maxItems" if its size is greater than, or equal to, the value of this keyword.
   * Omitting this keyword has the same behavior as a value of 0.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.12
   */


  minItems(minItems) {
    super.set("minItems", minItems);
    return this;
  }
  /**
   * If this keyword has boolean value false, the instance validates successfully.
   * If it has boolean value true, the instance validates successfully if all of its elements are unique.
   * Omitting this keyword has the same behavior as a value of false.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.13
   */


  uniqueItems(uniqueItems) {
    super.set("uniqueItems", uniqueItems);
    return this;
  }
  /**
   * Must be a non-negative integer.
   * An object instance is valid against "maxProperties" if its number of properties is less than, or equal to, the value of this keyword.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.15
   */


  maxProperties(maxProperties) {
    super.set("maxProperties", maxProperties);
    return this;
  }
  /**
   * Must be a non-negative integer.
   * An object instance is valid against "maxProperties" if its number of properties is greater than,
   * or equal to, the value of this keyword.
   * Omitting this keyword has the same behavior as a value of 0.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.16
   */


  minProperties(minProperties) {
    super.set("minProperties", minProperties);
    return this;
  }

  allow(...allow) {
    this.$allow.push(...allow);
    return this;
  }
  /**
   * Elements of this array must be unique.
   * An object instance is valid against this keyword if every item in the array is the name of a property in the instance.
   * Omitting this keyword has the same behavior as an empty array.
   *
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.17
   */


  required(required = true) {
    if (isArray(required)) {
      this.$required.clear();
      required.forEach(value => this.$required.add(value));
    } else {
      const schema = this.clone();
      schema.$selfRequired = required;
      return schema;
    }

    return this;
  }

  addRequired(property) {
    this.$required.add(property);
    return this;
  }

  removeRequired(property) {
    this.$required.delete(property);
    return this;
  }

  isRequired(property) {
    return this.$required.has(property);
  }
  /**
   * This keyword determines how child instances validate for objects, and does not directly validate the immediate instance itself.
   * Validation succeeds if, for each name that appears in both the instance and as a name within this keyword's value,
   * the child instance for that name successfully validates against the corresponding schema.
   * Omitting this keyword has the same behavior as an empty object.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.18
   */


  properties(properties) {
    super.set("properties", mapProperties(properties));
    return this;
  }

  addProperty(key, schema) {
    const properties = this.get("properties") || {};
    properties[key] = schema;
    super.set("properties", mapProperties(properties));
    return this;
  }
  /**
   * This attribute is an object that defines the schema for a set of property names of an object instance.
   * The name of each property of this attribute's object is a regular expression pattern in the ECMA 262, while the value is a schema.
   * If the pattern matches the name of a property on the instance object, the value of the instance's property
   * MUST be valid against the pattern name's schema value.
   * Omitting this keyword has the same behavior as an empty object.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.19
   */


  patternProperties(patternProperties) {
    super.set("patternProperties", mapProperties(patternProperties));
    return this;
  }
  /**
   * This attribute defines a schema for all properties that are not explicitly defined in an object type definition.
   * If specified, the value MUST be a schema or a boolean.
   * If false is provided, no additional properties are allowed beyond the properties defined in the schema.
   * The default value is an empty schema which allows any value for additional properties.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.20
   */


  additionalProperties(additionalProperties) {
    super.set("additionalProperties", mapToJsonSchema(additionalProperties));
    return this;
  }
  /**
   * This attribute defines a schema for all properties that are not explicitly defined in an object type definition.
   * If specified, the value MUST be a schema or a boolean.
   * If false is provided, no additional properties are allowed beyond the properties defined in the schema.
   * The default value is an empty schema which allows any value for additional properties.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.20
   * @alias additionalProperties
   * @param unknown
   */


  unknown(unknown = true) {
    return this.additionalProperties(unknown);
  }
  /**
   * This keyword specifies rules that are evaluated if the instance is an object and contains a certain property.
   * Each property specifies a dependency.
   * If the dependency value is an array, each element in the array must be unique.
   * Omitting this keyword has the same behavior as an empty object.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.21
   */


  dependencies(dependencies) {
    super.set("dependencies", mapProperties(dependencies));
    return this;
  }
  /**
   * Takes a schema which validates the names of all properties rather than their values.
   * Note the property name that the schema is testing will always be a string.
   * Omitting this keyword has the same behavior as an empty schema.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.22
   */


  propertyNames(propertyNames) {
    super.set("propertyNames", mapToJsonSchema(propertyNames));
    return this;
  }
  /**
   * This provides an enumeration of all possible values that are valid
   * for the instance property. This MUST be an array, and each item in
   * the array represents a possible value for the instance value. If
   * this attribute is defined, the instance value MUST be one of the
   * values in the array in order for the schema to be valid.
   *
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.23
   */


  enum(enumValues) {
    super.set("enum", uniq(enumValues));
    return this;
  }
  /**
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.1
   */


  definitions(definitions) {
    super.set("definitions", mapProperties(definitions));
    return this;
  }
  /**
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.26
   */


  allOf(allOf) {
    super.set("allOf", allOf.map(mapToJsonSchema));
    return this;
  }
  /**
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.27
   */


  anyOf(anyOf) {
    super.set("anyOf", anyOf.map(mapToJsonSchema));
    return this;
  }
  /**
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.28
   */


  oneOf(oneOf) {
    super.set("oneOf", oneOf.map(mapToJsonSchema));
    return this;
  }
  /**
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.29
   */


  not(not) {
    super.set("not", mapToJsonSchema(not));
    return this;
  }
  /**
   * Must be strictly greater than 0.
   * A numeric instance is valid only if division by this keyword's value results in an integer.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.1
   */


  multipleOf(multipleOf) {
    super.set("multipleOf", multipleOf);
    return this;
  }
  /**
   * Representing an inclusive upper limit for a numeric instance.
   * This keyword validates only if the instance is less than or exactly equal to "maximum".
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.2
   */


  maximum(maximum) {
    super.set("maximum", maximum);
    return this;
  }
  /**
   * Representing an exclusive upper limit for a numeric instance.
   * This keyword validates only if the instance is strictly less than (not equal to) to "exclusiveMaximum".
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.3
   */


  exclusiveMaximum(exclusiveMaximum) {
    super.set("exclusiveMaximum", exclusiveMaximum);
    return this;
  }
  /**
   * Representing an inclusive lower limit for a numeric instance.
   * This keyword validates only if the instance is greater than or exactly equal to "minimum".
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.4
   */


  minimum(minimum) {
    super.set("minimum", minimum);
    return this;
  }
  /**
   * Representing an exclusive lower limit for a numeric instance.
   * This keyword validates only if the instance is strictly greater than (not equal to) to "exclusiveMinimum".
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.5
   */


  exclusiveMinimum(exclusiveMinimum) {
    super.set("exclusiveMinimum", exclusiveMinimum);
    return this;
  }
  /**
   * Must be a non-negative integer.
   * A string instance is valid against this keyword if its length is less than, or equal to, the value of this keyword.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.6
   */


  maxLength(maxLength) {
    super.set("maxLength", maxLength);
    return this;
  }
  /**
   * Must be a non-negative integer.
   * A string instance is valid against this keyword if its length is greater than, or equal to, the value of this keyword.
   * Omitting this keyword has the same behavior as a value of 0.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.7
   */


  minLength(minLength) {
    super.set("minLength", minLength);
    return this;
  }
  /**
   * Should be a valid regular expression, according to the ECMA 262 regular expression dialect.
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.8
   */


  pattern(pattern) {
    super.set("pattern", toJsonRegex(pattern));
    return this;
  }
  /**
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-8
   */


  format(format) {
    super.set("format", format);
    return this;
  }
  /**
   * A single type, or a union of simple types
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.25
   */


  type(type) {
    switch (type) {
      case Map:
        super.set("type", getJsonType(type));
        this._target = type;
        this._isCollection = true;

        if (!this.has("additionalProperties")) {
          super.set("additionalProperties", this.itemSchema({}));
        }

        break;

      case Array:
        super.set("type", getJsonType(type));
        this._target = type;
        this._isCollection = true;

        if (!this.has("items")) {
          super.set("items", this.itemSchema({}));
        }

        break;

      case Set:
        super.set("type", getJsonType(type));
        this._target = type;
        this._isCollection = true;
        this.uniqueItems(true);

        if (!this.has("items")) {
          super.set("items", this.itemSchema({}));
        }

        break;

      case "integer":
        super.set("type", getJsonType(type));
        this.integer();
        break;

      case Object:
      case Date:
      case Boolean:
      case Number:
      case String:
        super.set("type", getJsonType(type));
        this._target = type;

        if (!this.has("properties")) {
          super.set("properties", {});
        }

        break;

      default:
        if (isClass(type) || isFunction(type)) {
          super.set("type", undefined);
          this._target = type;

          if (!this.has("properties")) {
            super.set("properties", {});
          }
        } else {
          const jsonType = getJsonType(type);

          if (jsonType === "generic") {
            this._isGeneric = true;
            super.set("$ref", type);
          } else {
            super.set("type", jsonType);
          }
        }

    }

    return this;
  }

  any(...types) {
    types = uniq(types.length ? types : ["integer", "number", "string", "boolean", "array", "object", "null"]).map(getJsonType);

    if (types.includes("null")) {
      this.nullable = true;
    }

    this.type(types.length === 1 ? types[0] : types);
    return this;
  }

  integer() {
    super.set("type", "integer");
    super.set("multipleOf", 1.0);
    return this;
  }
  /**
   * This attribute is a string that provides a short description of the instance property.
   *
   * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-7.2
   */


  title(title) {
    super.set("title", title);
    return this;
  }

  readOnly(readOnly) {
    super.set("readOnly", readOnly);
    return this;
  }

  writeOnly(readOnly) {
    super.set("writeOnly", readOnly);
    return this;
  }

  customKey(key, value) {
    super.set(`#${key}`, value);
    return this;
  }

  toObject(options) {
    return this.toJSON(options);
  }

  toJSON(options) {
    let addDef = false;

    if (!options) {
      addDef = true;
      options = {
        schemas: {}
      };
    }

    const schema = execMapper("schema", this, options);

    if (addDef && options.schemas && Object.keys(options.schemas).length) {
      schema.definitions = options.schemas;
    }

    return schema;
  }

  assign(obj = {}) {
    const entries = obj instanceof JsonSchema ? [...obj.entries()] : Object.entries(obj);
    entries.forEach(([key, value]) => {
      this.set(key, value);
    });

    if (obj instanceof JsonSchema) {
      this.$selfRequired = obj.$selfRequired;
      obj.$required.forEach(key => {
        this.$required.add(key);
      });
      this._ref = obj._ref;
      this._alias = new Map(this._alias.entries());
      obj._genericLabels && (this._genericLabels = [...obj._genericLabels]);
      this._nestedGenerics = obj._nestedGenerics.map(item => [...item]);
      this._target = obj._target;
      this._isGeneric = obj._isGeneric;
      this._isCollection = obj._isCollection;
      this._ref = obj._ref;
      super.set("type", obj.get("type"));
    }

    return this;
  }

  set(key, value) {
    if (key in this) {
      isFunction(this[key]) && this[key](value);
    } else {
      super.set(key, value);
    }

    return this;
  }
  /**
   * Return the itemSchema computed type.
   * If the type is a function used for recursive model,
   * the function will be called to get the right type.
   */


  getComputedType() {
    return getComputedType(this._target);
  }

  getComputedItemType() {
    return this._itemSchema ? this._itemSchema.getComputedType() : this.getComputedType();
  }
  /**
   * Return the Json type as string
   */


  getJsonType() {
    return this.get("type") || getJsonType(this.getComputedType());
  }

  getTarget() {
    return this._target;
  }
  /**
   * Get the symbolic name of the entity
   */


  getName() {
    return this.get("name") || (this._target ? nameOf(classOf(this.getComputedType())) : "");
  }

  clone() {
    return new JsonSchema(this);
  }

}

const _excluded$6 = ["schema", "in"];
class JsonOperation extends JsonMap {
  constructor(obj = {}) {
    super(_extends({
      parameters: [],
      responses: new JsonMap()
    }, obj));
    this.operationPaths = new Map();
  }

  get response() {
    return this.getResponses().get(this.getStatus().toString());
  }

  get status() {
    return this._status;
  }

  tags(tags) {
    super.set("tags", tags);
    return this;
  }

  addTags(tags) {
    tags = uniqBy([...(this.get("tags") || []), ...tags], "name");
    return this.tags(tags);
  }

  summary(summary) {
    super.set("summary", summary);
    return this;
  }

  operationId(operationId) {
    this.set("operationId", operationId);
    return this;
  }

  responses(responses) {
    this.set("responses", responses);
    return this;
  }

  defaultStatus(status) {
    this._status = status;
  }

  getStatus() {
    return this._status || 200;
  }

  addResponse(statusCode, response) {
    if (isSuccessStatus(statusCode) && !this._status) {
      const res = this.getResponseOf(200);
      this.getResponses().set(statusCode.toString(), res).delete("200");
      this.defaultStatus(Number(statusCode));
    }

    const currentCode = statusCode === "default" ? this.getStatus().toString() : statusCode.toString();
    const currentResponse = this.getResponses().get(currentCode);

    if (!currentResponse) {
      response.status = Number(currentCode);
      this.getResponses().set(currentCode, response);
    } else {
      response.forEach((value, key) => {
        if (!["content"].includes(key)) {
          currentResponse.set(key, deepMerge(currentResponse.get(key), value));
        }
      });
      currentResponse.status = Number(currentCode);
    }

    return this;
  }

  getResponses() {
    return this.get("responses");
  }

  getResponseOf(status) {
    return (status === "default" ? this.response : this.getResponses().get(String(status))) || new JsonResponse();
  }

  ensureResponseOf(status) {
    this.addResponse(status, this.getResponseOf(status));
    return this.getResponseOf(status);
  }

  getHeadersOf(status) {
    return this.getResponseOf(status).get("headers") || {};
  }

  getContentTypeOf(status) {
    return [...this.getResponseOf(status).get("content").keys()].slice(-1)[0];
  }

  security(security) {
    this.set("security", security);
    return this;
  }

  addSecurityScopes(name, scopes) {
    const security = this.get("security") || {};
    security[name] = uniq([...(security[name] || []), ...scopes]);
    return this.security(security);
  }

  description(description) {
    super.set("description", description);
    return this;
  }

  deprecated(deprecated) {
    super.set("deprecated", deprecated);
    return this;
  }

  parameters(parameters) {
    super.set("parameters", parameters);
    return this;
  }

  addParameter(index, parameter) {
    if (index === -1) {
      index = this.get("parameters").length;
    }

    this.get("parameters")[index] = parameter;
  }

  consumes(consumes) {
    super.set("consumes", consumes);
    return this;
  }

  produces(produces) {
    super.set("produces", produces);
    return this;
  }

  addProduce(produce) {
    const produces = uniq([].concat(this.get("produces"), produce)).filter(Boolean);
    this.set("produces", produces);
  }

  addOperationPath(method, path, options = {}) {
    this.operationPaths.set(String(method) + String(path), _extends({}, options, {
      method,
      path
    }));
    return this;
  }

  toJSON(options = {}) {
    const operation = super.toJSON(_extends({}, options, {
      ignore: ["parameters"]
    }));
    const bodyParameters = [];
    const parameters = [];

    if (operation.security) {
      operation.security = [].concat(operation.security);
    }

    this.get("parameters").forEach(parameter => {
      if (!isParameterType(this.get("in"))) {
        if (parameter.get("in")) {
          if ([JsonParameterTypes.BODY, JsonParameterTypes.FILES].includes(parameter.get("in"))) {
            bodyParameters.push(parameter);
          } else {
            parameters.push(...[].concat(parameter.toJSON(options)));
          }
        }
      }
    });
    operation.parameters = parameters.filter(Boolean);

    if (this.get("responses").size === 0) {
      operation.responses = {
        "200": {
          description: HTTP_STATUS_MESSAGES[200]
        }
      };
    }

    if (bodyParameters.length) {
      const parameter = buildSchemaFromBodyParameters(bodyParameters, options);

      if (options.specType === SpecTypes.OPENAPI) {
        operation.requestBody = toRequestBody(this, parameter).toJSON(options);
      } else {
        operation.parameters.push(toJsonParameter(parameter));
      }
    }

    if (options.specType === SpecTypes.OPENAPI) {
      delete operation.consumes;
      delete operation.produces;
    }

    return operation;
  }

}

function toRequestBody(operation, _ref) {
  var _operation$get;

  let {
    schema
  } = _ref,
      props = _objectWithoutPropertiesLoose(_ref, _excluded$6);

  const requestBody = new JsonRequestBody(props);
  const consumes = (_operation$get = operation.get("consumes")) != null && _operation$get.length ? operation.get("consumes") : ["application/json"];
  consumes.forEach(consume => {
    requestBody.addContent(consume, schema);
  });
  return requestBody;
}

function toJsonParameter(parameter) {
  return _extends({
    in: JsonParameterTypes.BODY,
    name: JsonParameterTypes.BODY
  }, parameter);
}

function buildSchemaFromBodyParameters(parameters, options) {
  let schema = new JsonSchema();
  const props = {};
  const refs = [];
  let propsLength = 0;
  parameters.forEach(parameter => {
    const name = parameter.getName();
    Array.from(parameter.entries()).filter(([key]) => !["in", "name"].includes(key)).forEach(([key, value]) => {
      if (props[key] === undefined) {
        props[key] = value;
      }
    });
    const jsonParameter = parameter.toJSON(options);

    if (name) {
      schema.addProperty(name, jsonParameter.schema || {
        type: jsonParameter.type
      });

      if (parameter.get("required")) {
        schema.addRequired(name);
      }

      propsLength++;
    } else {
      refs.push(jsonParameter);
    }
  });

  if (propsLength) {
    schema.type("object");
    return _extends({
      schema: schema.toJSON(options),
      required: false
    }, props);
  }

  if (refs.length === 1) {
    return refs[0];
  }

  if (refs.length > 0) {
    schema.allOf(refs);
  }

  return _extends({
    schema: schema.toJSON(options),
    required: false
  }, props);
}

const _excluded$5 = ["type", "schema"],
      _excluded2 = ["minLength"],
      _excluded3 = ["description"];
const IGNORE_OS2_PROPS = ["example", "examples", "title"];
class JsonParameter extends JsonMap {
  constructor() {
    super(...arguments);
    this.nestedGenerics = [];
  }

  getName() {
    const name = this.get("name");

    if (this.get("in") === "files") {
      return name.split(".")[0];
    }

    return name;
  }

  name(name) {
    this.set("name", name);
    return this;
  }

  description(description) {
    this.set("description", description);
    return this;
  }

  in(inType, expression = "") {
    this.set("in", formatParameterType(inType));
    this.expression = expression;
    return this;
  }

  required(required) {
    this.set("required", required);
    return this;
  }

  schema(schema) {
    this.$schema = schema;
    return this;
  }

  toJSON(options = {}) {
    if (!isParameterType(this.get("in"))) {
      return null;
    }

    const schemasContainer = toMap(options.schemas || {});
    return this.build(_extends({}, options, {
      groups: this.groups
    }), schemasContainer);
  }

  build(options, schemasContainer) {
    const _super$toJSON = super.toJSON(options),
          parameter = _objectWithoutPropertiesLoose(_super$toJSON, _excluded$5);

    const jsonSchema = execMapper("item", this.$schema, _extends({}, options, popGenerics(this)));
    parameter.required = parameter.required || this.get("in") === JsonParameterTypes.PATH;

    if (this.get("in") === JsonParameterTypes.FILES) {
      const isOpenApi = options.specType === SpecTypes.OPENAPI;
      const schema = {
        type: isOpenApi ? "string" : "file",
        format: isOpenApi ? "binary" : undefined,
        oneOf: undefined
      };

      if (jsonSchema.type === "array") {
        jsonSchema.items = cleanObject(_extends({}, jsonSchema.items, schema));
        parameter.schema = jsonSchema;
      } else {
        parameter.schema = cleanObject(_extends({}, jsonSchema, schema));
      }

      return parameter;
    }

    if (options.specType === SpecTypes.OPENAPI) {
      if (["query"].includes(this.get("in")) && jsonSchema.$ref) {
        if (!parameter.name) {
          return this.refToParameters(parameter, options, schemasContainer);
        }

        parameter.style = "deepObject";
      }
    }

    if (options.specType === SpecTypes.SWAGGER) {
      if (!jsonSchema.$ref && Object.keys(jsonSchema).length === 1) {
        parameter.type = jsonSchema.type;
        return parameter;
      }

      if (["formData", "query"].includes(this.get("in"))) {
        if (jsonSchema.$ref) {
          return this.refToParameters(parameter, options, schemasContainer);
        }

        if (jsonSchema.type === "array") {
          const props = _objectWithoutPropertiesLoose(jsonSchema, _excluded2);

          return cleanObject(_extends({}, parameter, props, {
            type: "array",
            collectionFormat: "multi",
            items: {
              type: "string"
            }
          }), IGNORE_OS2_PROPS);
        }
      }

      if (this.get("in") !== "body") {
        return cleanObject(_extends({}, parameter, jsonSchema), IGNORE_OS2_PROPS);
      }
    }

    parameter.schema = jsonSchema;
    return parameter;
  }

  refToParameters(parameter, options, schemasContainer) {
    const schema = options.schemas[this.$schema.getName()];

    if (options.schemas[this.$schema.getName()] && !schemasContainer.has(this.$schema.getName())) {
      delete options.schemas[this.$schema.getName()];
    }

    return Object.entries(schema.properties || {}).reduce((params, [key, _ref]) => {
      let {
        description
      } = _ref,
          prop = _objectWithoutPropertiesLoose(_ref, _excluded3);

      if (options.specType === SpecTypes.OPENAPI) {
        return [...params, cleanObject(_extends({}, parameter, {
          name: key,
          required: (schema.required || []).includes(key),
          description,
          schema: prop,
          style: prop.$ref ? "deepObject" : undefined
        }))];
      }

      return [...params, cleanObject(_extends({}, parameter, {
        name: key,
        required: (schema.required || []).includes(key),
        description
      }, prop))];
    }, []);
  }

}

const getSchema = type => {
  if (isCollection(type) || !isClass(type)) {
    return JsonSchema.from({
      type
    });
  }

  return getJsonEntityStore(type).schema;
};

class JsonEntityStore extends Entity {
  constructor(options) {
    super(options);
    this.isStore = true;
    /**
     * List of children JsonEntityStore (properties or methods or params)
     */

    this.children = new Map();
    /**
     * Path used to generate open spec.
     */

    this.path = "/";
    this.store = options.store;
    /* istanbul ignore next */

    if (options.children) {
      this.children = options.children;
    }

    this.build();
  }
  /**
   * Return the JsonSchema
   */


  get schema() {
    return this._schema;
  }
  /**
   * Return the JsonOperation
   */


  get operation() {
    return this._operation;
  }
  /**
   * Return the JsonParameter
   */


  get parameter() {
    return this._parameter;
  }

  get nestedGenerics() {
    switch (this.decoratorType) {
      case DecoratorTypes.PARAM:
        return this.parameter.nestedGenerics;

      default:
        return this.schema.nestedGenerics;
    }
  }

  set nestedGenerics(nestedGenerics) {
    switch (this.decoratorType) {
      case DecoratorTypes.PARAM:
        this.parameter.nestedGenerics = nestedGenerics;
        break;

      default:
        this.schema.nestedGenerics = nestedGenerics;
        break;
    }
  }
  /**
   *
   * @returns {Type<any>}
   */


  get type() {
    return this._type;
  }
  /**
   * Get original type without transformation
   * @param value
   */


  set type(value) {
    this._type = value;
    this.build();
  }
  /**
   * Return the itemSchema computed type. if the type is a function used for recursive model, the function will be called to
   * get the right type.
   */


  get computedType() {
    return this.itemSchema.getComputedType();
  }

  get itemSchema() {
    return this.isCollection ? this.schema.itemSchema() : this.schema;
  }

  get parentSchema() {
    return this.parent.schema;
  }

  get parent() {
    const {
      target,
      propertyKey,
      decoratorType
    } = this;

    switch (decoratorType) {
      case DecoratorTypes.PARAM:
        return JsonEntityStore.fromMethod(target, propertyKey);

      case DecoratorTypes.METHOD:
      case DecoratorTypes.PROP:
        return JsonEntityStore.from(target);
    }

    return this;
  }
  /**
   * Return the required state.
   * @returns {boolean}
   */


  get required() {
    switch (this.decoratorType) {
      case DecoratorTypes.PROP:
        return this.parent.schema.isRequired(this.propertyKey);

      case DecoratorTypes.PARAM:
        return this.parameter.get("required");
    }

    return false;
  }
  /**
   * Change the state of the required data.
   * @param value
   */


  set required(value) {
    switch (this.decoratorType) {
      case DecoratorTypes.PROP:
        if (value) {
          this.parent.schema.addRequired(this.propertyKey);
        } else {
          this.parent.schema.removeRequired(this.propertyKey);
        }

        break;

      case DecoratorTypes.PARAM:
        this.parameter.required(value);
        break;
    }
  }

  get allowedRequiredValues() {
    return this.schema.$allow;
  }
  /**
   *
   * @param args
   */


  static from(...args) {
    return getJsonEntityStore(...args);
  }

  static fromMethod(target, propertyKey) {
    return this.from(target, propertyKey, descriptorOf(target, propertyKey));
  }

  getResponseOptions(contentType = "application/json") {
    var _this$operation, _this$operation$getRe;

    const media = (_this$operation = this.operation) == null ? void 0 : (_this$operation$getRe = _this$operation.getResponseOf(this.statusCode)) == null ? void 0 : _this$operation$getRe.getMedia(contentType, false);

    if (media && media.has("schema")) {
      const schema = media.get("schema");
      return {
        type: schema.getComputedItemType(),
        groups: media.groups
      };
    }

    return {
      type: this.type
    };
  }
  /**
   * Check precondition between value, required and allowedRequiredValues to know if the entity is required.
   * @param value
   * @returns {boolean}
   */


  isRequired(value) {
    return this.required && [undefined, null, ""].includes(value) && !this.allowedRequiredValues.includes(value);
  }

  build() {
    if (!this._type) {
      let type;

      switch (this.decoratorType) {
        case DecoratorTypes.PARAM:
          type = Metadata.getParamTypes(this.target, this.propertyKey)[this.index];
          break;

        case DecoratorTypes.CLASS:
          type = this.target;
          break;

        case DecoratorTypes.PROP:
          type = Metadata.getType(this.target, this.propertyKey);
          break;

        case DecoratorTypes.METHOD:
          type = Metadata.getReturnType(this.target, this.propertyKey);
          type = isPromise(type) ? undefined : type;
          break;
      }

      if (isCollection(type)) {
        this.collectionType = type;
      } else {
        this._type = type;
      }
    }

    this._type = this._type || Object;

    switch (this.decoratorType) {
      default:
        this._schema = JsonSchema.from();
        break;

      case DecoratorTypes.CLASS:
        this._schema = JsonSchema.from({
          type: this.type
        });
        break;

      case DecoratorTypes.METHOD:
        this._operation = this.createOperation();
        break;

      case DecoratorTypes.PARAM:
        this._parameter = this.createParameter();
        break;

      case DecoratorTypes.PROP:
        this._schema = this.createProperty();
        break;
    }
  }

  createProperty() {
    const parentStore = this.parent;
    const properties = parentStore.schema.get("properties");
    let schema = properties[this.propertyName];

    if (!schema) {
      parentStore.children.set(this.propertyName, this);
      schema = JsonSchema.from({
        type: this.collectionType || this.type
      });

      if (this.collectionType) {
        schema.itemSchema(this.type);
      }
    }

    parentStore.schema.addProperty(this.propertyName, schema);
    return schema;
  }

  createOperation() {
    const parentStore = this.parent; // response schema of the method

    let operation = this.operation;

    if (!operation) {
      operation = new JsonOperation();
      parentStore.children.set(this.propertyName, this);
    }

    if (isCollection(this._type)) {
      this.collectionType = this._type; // @ts-ignore

      delete this._type;
    }

    this._schema = JsonSchema.from({
      type: this.collectionType || this.type
    });

    if (this.collectionType) {
      this._schema.itemSchema(this.type);
    }

    parentStore.schema.addProperty(this.propertyName, this.schema);
    return operation;
  }

  createParameter() {
    const parentStore = this.parent;
    let parameter = this.parameter;

    if (!parameter) {
      var _parentStore$operatio;

      parameter = new JsonParameter();
      parentStore.children.set(this.index, this);
      this._schema = getSchema(this.collectionType || this.type);
      parameter.schema(this._schema);

      if (this.collectionType) {
        this._schema.itemSchema(getSchema(this.type));
      }

      (_parentStore$operatio = parentStore.operation) == null ? void 0 : _parentStore$operatio.addParameter(this.index, parameter);
    }

    return parameter;
  }

}
JsonEntitiesContainer.set("default", JsonEntityStore);

const _excluded$4 = ["type", "properties", "additionalProperties", "items"];
function classMapper(value, options = {}) {
  const store = JsonEntityStore.from(value.class);
  const name = createRefName(store.schema.getName() || value.getName(), options);

  if (value.hasGenerics) {
    // Inline generic
    const _value$toJSON = value.toJSON(options),
          props = _objectWithoutPropertiesLoose(_value$toJSON, _excluded$4);

    const schema = _extends({}, execMapper("any", store.schema, _extends({}, options, popGenerics(value), {
      root: false
    })), props);

    if (schema.title) {
      const _name = createRefName(schema.title, options);

      options.schemas[_name] = schema;
      delete schema.title;
      return createRef(_name, value, options);
    }

    return schema;
  }

  if (options.schemas && !options.schemas[name]) {
    options.schemas[name] = {}; // avoid infinite calls

    options.schemas[name] = execMapper("any", store.schema, mapGenericsOptions(_extends({}, options, {
      root: false
    })));
  }

  return createRef(name, value, options);
}
registerJsonSchemaMapper("class", classMapper);

/**
 * @ignore
 */

function genericsMapper(obj, options) {
  const {
    generics
  } = options;

  if (generics && obj.$ref) {
    if (generics.has(obj.$ref)) {
      let type = generics.get(obj.$ref);

      if (isPrimitiveClass(type)) {
        return {
          type: getJsonType(type)
        };
      }

      if (type === Date) {
        return {
          type: "string",
          format: "date-time"
        };
      }

      if (type.toJSON) {
        return type.toJSON(_extends({}, options, {
          generics: undefined
        }));
      }

      if (type === Object) {
        return {
          type: "object"
        };
      }

      if (isClass(type)) {
        const model = {
          class: type
        };

        if (options.nestedGenerics.length === 0) {
          return execMapper("class", model, _extends({}, options, {
            generics: undefined
          }));
        }

        const store = JsonEntityStore.from(model.class);
        return execMapper("schema", store.schema, _extends({}, options, popGenerics(options), {
          root: false
        }));
      }
    }
  }

  return obj;
}
registerJsonSchemaMapper("generics", genericsMapper);

/**
 * Return store and his inherited stores
 * @param target
 * @ignore
 */

function getInheritedStores(target) {
  const store = target.isStore ? target : getJsonEntityStore(target);

  if (!store.$inherited) {
    store.$inherited = ancestorsOf(store.target).reverse().reduce((context, model) => {
      return context.set(model, getJsonEntityStore(model));
    }, new Map());
  }

  return store.$inherited;
}

const _excluded$3 = ["target"];
/**
 * @ignore
 */

function inheritedClassMapper(obj, _ref = {}) {
  let {
    target
  } = _ref,
      options = _objectWithoutPropertiesLoose(_ref, _excluded$3);

  const stores = Array.from(getInheritedStores(target).entries()).filter(([model]) => classOf(model) !== classOf(target));

  if (stores.length) {
    const schema = stores.reduce((obj, [, store]) => {
      return deepMerge(obj, execMapper("schema", store.schema, options));
    }, {});
    obj = deepMerge(schema, obj);
  }

  return obj;
}
registerJsonSchemaMapper("inheritedClass", inheritedClassMapper);

function itemMapper(value, options) {
  return value && value.isClass ? execMapper("class", value, options) : execMapper("any", value, options);
}
registerJsonSchemaMapper("item", itemMapper);

function lazyRefMapper(input, options) {
  var _options$$refs;

  const name = input.name;

  if ((_options$$refs = options.$refs) != null && _options$$refs.find(t => t === input.target)) {
    return createRef(name, input.schema, options);
  }

  options.$refs = [...(options.$refs || []), input.target];
  const schema = input.toJSON(mapGenericsOptions(options));
  return toRef(input.schema, schema, options);
}
registerJsonSchemaMapper("lazyRef", lazyRefMapper);

const _excluded$2 = ["ignore"];
/**
 * Serialize class which inherit from Map like JsonMap, JsonOperation, JsonParameter.
 * @param input
 * @param ignore
 * @param options
 * @ignore
 */

function mapMapper(input, _ref = {}) {
  let {
    ignore = []
  } = _ref,
      options = _objectWithoutPropertiesLoose(_ref, _excluded$2);

  options = mapGenericsOptions(options);
  return Array.from(input.entries()).reduce((obj, [key, value]) => {
    if (ignore.includes(key)) {
      return obj;
    }

    obj[key] = execMapper("item", value, options);
    return obj;
  }, {});
}
registerJsonSchemaMapper("map", mapMapper);

/**
 * @ignore
 * @param schema
 * @param options
 */
function alterIgnore(schema, options) {
  var _schema$$hooks;

  let result = schema == null ? void 0 : (_schema$$hooks = schema.$hooks) == null ? void 0 : _schema$$hooks.alter("ignore", false, [options]);

  if (result) {
    return result;
  }

  if (options.groups !== false) {
    var _schema$$hooks2;

    return schema == null ? void 0 : (_schema$$hooks2 = schema.$hooks) == null ? void 0 : _schema$$hooks2.alter("groups", false, [options.groups]);
  }

  return result;
}

const _excluded$1 = ["specType", "operationIdFormatter", "root", "schemas", "genericTypes", "nestedGenerics", "useAlias", "genericLabels"];
/**
 * Serialize Any object to a json schema
 * @param input
 * @param options
 * @ignore
 */

function objectMapper(input, options) {
  const ctx = _objectWithoutPropertiesLoose(options, _excluded$1);

  return Object.entries(input).reduce((obj, [key, value]) => {
    if (options.withIgnoredProps !== false && !alterIgnore(value, ctx)) {
      // remove groups to avoid bad schema generation over children models
      obj[key] = execMapper("item", value, _extends({}, options, {
        groups: value != null && value.$forwardGroups ? options.groups : undefined
      }));
    }

    return obj;
  }, isArray(input) ? [] : {});
}
registerJsonSchemaMapper("object", objectMapper);

/**
 * @ignore
 */
function mapAliasedProperties(value, alias) {
  return Object.entries(value).reduce((properties, [key, value]) => {
    key = alias.get(key) || key;
    properties[key] = value;
    return properties;
  }, {});
}

/**
 * @ignore
 */
function alterRequiredGroups(required, schema, options) {
  if (options.groups !== false) {
    var _schema$$hooks;

    return schema == null ? void 0 : (_schema$$hooks = schema.$hooks) == null ? void 0 : _schema$$hooks.alter("requiredGroups", required, [options.groups]);
  }

  return required;
}

function applyStringRule(obj, propSchema) {
  if (!(propSchema != null && propSchema.$allow.includes(""))) {
    if ([].concat(propSchema == null ? void 0 : propSchema.get("type")).includes("string")) {
      const minLength = obj == null ? void 0 : obj.minLength; // Disallow empty string

      if (minLength === undefined) {
        return _extends({}, obj, {
          minLength: 1
        });
      }
    }
  }

  return obj;
}

function mapRequiredProps(obj, schema, options = {}) {
  const {
    useAlias
  } = options;
  const props = Object.keys(obj.properties || {});
  return (keys, key) => {
    const aliasedKey = useAlias ? schema.alias.get(key) || key : key;

    if (props.includes(aliasedKey)) {
      const propSchema = schema.get("properties")[key];
      const serializeSchema = obj.properties[aliasedKey];
      obj.properties[aliasedKey] = applyStringRule(serializeSchema, propSchema); // applyNullRule(applyStringRule(serializeSchema, propSchema), propSchema);
      // obj.properties[aliasedKey] = mapNullableType(obj.properties[aliasedKey]);

      return keys.concat(aliasedKey);
    }

    return keys;
  };
}

function extractRequiredProps(obj, schema, options) {
  let required = obj.required || [];
  required = [...required, ...schema.$required];

  if (schema.get("properties")) {
    required = Object.entries(schema.get("properties")).reduce((required, [key, prop]) => {
      if (prop && prop.$selfRequired !== undefined) {
        return prop.$selfRequired ? required.concat(key) : required.filter(k => k === key);
      }

      return required;
    }, required);
  }

  return alterRequiredGroups(uniq(required), schema, options);
}
/**
 * @ignore
 */


function getRequiredProperties(obj, schema, options) {
  if (options.groups && options.groups.includes("partial")) {
    return obj;
  }

  let required = extractRequiredProps(obj, schema, options);
  required = uniq(required).reduce(mapRequiredProps(obj, schema, options), []);

  if (required.length) {
    return _extends({}, obj, {
      required
    });
  }

  return obj;
}

function mapNullableType(obj, schema, options) {
  if (!schema.nullable) {
    return obj;
  }

  let types = [].concat(obj.type).filter(type => type !== "null");

  switch (options.specType) {
    case SpecTypes.SWAGGER:
    case SpecTypes.JSON:
      obj.type = ["null", ...types];
      break;

    case SpecTypes.OPENAPI:
      if (types.length > 1) {
        obj.oneOf = types.map(type => {
          return cleanObject({
            type,
            nullable: true
          });
        }, []);
      } else {
        obj.type = types[0];
        obj.nullable = true;
      }

  }

  return obj;
}

/**
 * @ignore
 */

const IGNORES = ["name", "$required", "$hooks", "_nestedGenerics", SpecTypes.OPENAPI, SpecTypes.SWAGGER, SpecTypes.JSON];
/**
 * @ignore
 */

const IGNORES_OPENSPEC = ["const"];
const IGNORES_OS2 = ["writeOnly", "readOnly"];
/**
 * @ignore
 */

function isEmptyProperties(key, value) {
  return typeof value === "object" && ["items", "properties", "additionalProperties"].includes(key) && Object.keys(value).length === 0;
}
/**
 * @ignore
 */


function shouldMapAlias(key, value, useAlias) {
  return typeof value === "object" && useAlias && ["properties", "additionalProperties"].includes(key);
}
/**
 * @ignore
 */


function shouldSkipKey(key, {
  specType = SpecTypes.JSON,
  customKeys = false
}) {
  return IGNORES.includes(key) || key.startsWith("#") && (customKeys === false || specType !== SpecTypes.JSON) || specType === SpecTypes.SWAGGER && IGNORES_OS2.includes(key) || specType !== SpecTypes.JSON && IGNORES_OPENSPEC.includes(key);
}

function schemaMapper(schema, options = {}) {
  const {
    useAlias = true,
    schemas = {},
    genericTypes
  } = options;
  let obj = [...schema.entries()].reduce((item, [key, value]) => {
    if (shouldSkipKey(key, options)) {
      return item;
    }

    key = key.replace(/^#/, "");

    if (key === "type") {
      value = schema.getJsonType();
    }

    if (key === "examples" && isObject(value) && [SpecTypes.OPENAPI, SpecTypes.SWAGGER].includes(options.specType)) {
      key = "example";
      value = Object.values(value)[0];
    }

    if (value) {
      if (value.isClass) {
        value = execMapper("class", value, _extends({}, options, {
          useAlias,
          schemas
        }));
      } else {
        value = execMapper("any", value, _extends({}, options, {
          useAlias,
          schemas,
          genericTypes,
          genericLabels: schema.genericLabels
        }));
      }
    }

    if (isEmptyProperties(key, value)) {
      return item;
    }

    if (shouldMapAlias(key, value, useAlias)) {
      value = mapAliasedProperties(value, schema.alias);
    }

    item[key] = value;
    return item;
  }, {});

  if (schema.isClass) {
    obj = execMapper("inheritedClass", obj, _extends({}, options, {
      root: false,
      schemas,
      target: schema.getComputedType()
    }));
  }

  obj = execMapper("generics", obj, _extends({}, options, {
    root: false,
    schemas
  }));

  if (schema.has(options.specType)) {
    obj = _extends({}, obj, schema.get(options.specType).toJSON(options));
  }

  obj = getRequiredProperties(obj, schema, _extends({}, options, {
    useAlias
  }));
  obj = mapNullableType(obj, schema, options);

  if ((obj.oneOf || obj.allOf || obj.anyOf) && !(obj.items || obj.properties)) {
    delete obj.type;
  }

  return obj;
}
registerJsonSchemaMapper("schema", schemaMapper);

/**
 * @ignore
 */

const CACHE_KEY = "$cache:schemes";
/**
 * @ignore
 */

function getKey(options) {
  return JSON.stringify(options);
}
/**
 * @ignore
 */


function get$1(entity, options) {
  const cache = entity.store.get(CACHE_KEY) || new Map();
  const key = getKey(options);

  if (!cache.has(key)) {
    const schema = execMapper("schema", entity.schema, options);

    if (Object.keys(options.schemas).length) {
      schema.definitions = options.schemas;
    }

    cache.set(key, schema);
  }

  entity.store.set(CACHE_KEY, cache);
  return cache.get(key);
}

function getJsonSchema(model, options = {}) {
  const entity = isJsonEntityStore(model) ? model : getJsonEntityStore(model);
  options = _extends({
    endpoint: true,
    groups: []
  }, options, {
    specType: options.specType || SpecTypes.JSON,
    schemas: {}
  });

  if (entity.decoratorType === "parameter") {
    var _entity$parameter;

    options = _extends({}, options, {
      genericTypes: entity.nestedGenerics[0],
      nestedGenerics: entity.nestedGenerics,
      groups: (_entity$parameter = entity.parameter) == null ? void 0 : _entity$parameter.groups
    });
  }

  return get$1(entity, options);
}

/**
 * Return the list of properties including properties from inherited classes
 * @param target
 * @ignore
 */

function getPropertiesStores(target) {
  const store = target.isStore ? target : getJsonEntityStore(target);

  if (!store.$properties) {
    const stores = getInheritedStores(store);
    store.$properties = new Map();
    stores.forEach(currentStore => {
      currentStore.children.forEach(propStore => {
        if (!store.$properties.has(propStore.propertyKey)) {
          store.$properties.set(propStore.propertyKey, propStore);
        }
      });
    });
  }

  return store.$properties;
}
/**
 * @ignore
 */

function getProperties(target, options = {}) {
  const stores = getPropertiesStores(target);
  const map = new Map();
  stores.forEach((store, key) => {
    if (!options.withIgnoredProps) {
      if (alterIgnore(store.itemSchema, options)) {
        return;
      }
    }

    map.set(key, store);
  });
  return map;
}

/**
 * @ignore
 */

function getOperationsStores(target) {
  const store = target.isStore ? target : getJsonEntityStore(target);

  if (!store.$operations) {
    const stores = getInheritedStores(store);
    store.$operations = new Map();
    stores.forEach(currentStore => {
      currentStore.children.forEach(propStore => {
        if (propStore.operation && !store.$operations.has(propStore.propertyKey)) {
          store.$operations.set(propStore.propertyKey, propStore);
        }
      });
    });
  }

  return store.$operations;
}

/**
 * Return a sanitized path
 * @param path
 * @ignore
 */
function buildPath(path) {
  return path.split("/").filter(Boolean).join("/");
}

/**
 * @ignore
 */
function concatParameters(parameters, operation) {
  return parameters.map(param => {
    const f = operation.parameters.find(p => p.in === param.in && p.name === param.name);
    return f || param;
  }).concat(...operation.parameters.filter(param => param.in !== "path"));
}

/**
 * @ignore
 */
function getVariable(subpath) {
  const [prefix, right] = subpath.split("=");
  const splited = (right || prefix).split(".");
  const name = splited.splice(0, 1)[0];
  return {
    prefix: right && prefix ? `${prefix}=` : "",
    name,
    postfix: splited.length ? `.${splited.join(".")}` : ""
  };
}
/**
 * @ignore
 */


function getJsonPathParameters(base, path = "") {
  if (path instanceof RegExp) {
    path = path.toString().replace(/^\//, "").replace(/\/$/, "").replace(/\\/, "");
  }

  const params = [];
  const paths = [];
  let isOptional = false;
  let current = "";
  `${base}${path}`.replace(/\((.*)\)/gi, "").split("/").filter(o => !!o).map(key => {
    const subpath = key.replace(":", "").replace("?", "");

    if (key.includes(":")) {
      const optional = key.includes("?"); // Append previous config

      if (optional && !isOptional) {
        isOptional = true;
        paths.push({
          path: current,
          parameters: [].concat(params)
        });
      }

      const {
        prefix,
        name,
        postfix
      } = getVariable(subpath);
      current += `/${prefix}{${name}}${postfix}`;
      params.push({
        in: "path",
        name,
        type: "string",
        required: true
      });

      if (optional && isOptional) {
        paths.push({
          path: current,
          parameters: [].concat(params)
        });
      }
    } else {
      current += `/${key}`;
    }
  });
  return paths.length ? paths : [{
    path: current,
    parameters: [].concat(params)
  }];
}

const _excluded = ["type"];
/**
 * @ignore
 */

function mergeOperation(obj, operation, {
  rootPath,
  specType,
  operationId,
  defaultTags,
  tags,
  path,
  method
}) {
  const pathParameters = getJsonPathParameters(rootPath, path).map(({
    path,
    parameters
  }) => {
    path = path ? path : "/";

    if (specType === SpecTypes.OPENAPI) {
      parameters = parameters.map(_ref => {
        let {
          type
        } = _ref,
            param = _objectWithoutPropertiesLoose(_ref, _excluded);

        return _extends({}, param, {
          schema: {
            type
          }
        });
      });
    }

    return {
      path,
      parameters
    };
  });
  return pathParameters.reduce((obj, {
    path,
    parameters
  }) => {
    var _operation$tags;

    parameters = concatParameters(parameters, operation);
    path = path ? path : "/";
    const operationTags = (_operation$tags = operation.tags) != null && _operation$tags.length ? operation.tags : [defaultTags];
    obj.paths[path] = _extends({}, obj.paths[path], {
      [method.toLowerCase()]: _extends({
        operationId: operation.operationId || operationId(path)
      }, operation, {
        tags: operationTags.map(({
          name
        }) => name),
        parameters
      })
    });
    tags.push(...operationTags);
    return obj;
  }, obj);
}

const DEFAULT_PATTERN = "%c.%m";
/**
 * @ignore
 */

function operationIdFormatter(pattern = "") {
  const OPERATION_IDS = new Map();

  const transform = (name, propertyKey) => {
    const str = (pattern || DEFAULT_PATTERN).replace(/%c/, name).replace(/%m/, propertyKey);
    return pattern === "" ? camelCase(str) : str;
  };

  return (name, propertyKey, path = "") => {
    const operationId = transform(name, propertyKey);
    const operationKey = name + propertyKey;

    if (!OPERATION_IDS.has(operationKey)) {
      OPERATION_IDS.set(operationKey, 0);
      return operationId;
    } // try with paths


    const result = path.match(/{(\w+)}/gi);

    if (result) {
      const _operationKey = name + propertyKey + result[0];

      if (!OPERATION_IDS.has(_operationKey)) {
        OPERATION_IDS.set(_operationKey, 0);
        return camelCase(`${operationId} By ${result}`);
      }
    }

    const id = OPERATION_IDS.get(operationKey) + 1;
    OPERATION_IDS.set(operationKey, id);
    return `${operationId}_${id}`;
  };
}

/**
 * @ignore
 */

const caches = new Map();
/**
 * @ignore
 */

function get(model, options, cb) {
  if (!caches.has(model)) {
    caches.set(model, new Map());
  }

  const cache = caches.get(model);
  const key = JSON.stringify(options);

  if (!cache.has(key)) {
    cache.set(key, cb());
  }

  return cache.get(key);
}
/**
 * Return the swagger or open spec for the given class.
 * @param model
 * @param options
 */


function getSpec(model, options = {
  specType: SpecTypes.SWAGGER
}) {
  if (!options.specType) {
    options.specType = SpecTypes.SWAGGER;
  }

  options = _extends({}, options, {
    operationIdFormatter: options.operationIdFormatter || operationIdFormatter(options.operationIdPattern),
    root: false,
    specType: options.specType
  });
  return get(model, options, () => {
    const store = getJsonEntityStore(model);
    const {
      specType = SpecTypes.SWAGGER,
      schemas = {},
      paths = {},
      rootPath = "/",
      tags = []
    } = options;
    const ctrlPath = store.path;
    const defaultTags = cleanObject({
      name: store.schema.getName(),
      description: store.schema.get("description")
    });
    const specJson = {
      paths
    };
    getOperationsStores(model).forEach(operationStore => {
      if (operationStore.store.get("hidden")) {
        return;
      }

      const operation = operationStore.operation.toJSON(_extends({}, options, {
        specType,
        schemas
      }));
      operationStore.operation.operationPaths.forEach(({
        path,
        method
      }) => {
        if (method) {
          mergeOperation(specJson, operation, {
            rootPath: buildPath(rootPath + ctrlPath),
            path,
            method,
            defaultTags,
            tags,
            specType,
            operationId: path => options.operationIdFormatter(operationStore.parent.schema.get("name") || operationStore.parent.targetName, operationStore.propertyName, path)
          });
        }
      });
    });
    specJson.tags = uniqBy(tags, "name");

    if (Object.keys(schemas).length) {
      if (specType === SpecTypes.OPENAPI) {
        specJson.components = {
          schemas
        };
      } else {
        specJson.definitions = schemas;
      }
    }

    return specJson;
  });
}

/**
 * @ignore
 */

const schemesReducer = mergeReducerBuilder((current, value) => current.type && current.type === value.type || current.$ref && current.$ref === value.$ref);
/**
 * @ignore
 */

const parameters = mergeReducerBuilder((current, value) => current.in === value.in && current.name === value.name);
/**
 * @ignore
 */

const security = mergeReducerBuilder((current, value) => {
  return !!Object.keys(value).find(key => !!current[key]);
});
/**
 * @ignore
 */

const tagsReducer = mergeReducerBuilder((current, value) => current.name === value.name);
/**
 * @ignore
 */

const SPEC_REDUCERS = {
  security,
  parameters,
  oneOf: schemesReducer,
  anyOf: schemesReducer,
  allOf: schemesReducer,
  tags: tagsReducer
};
/**
 * Merge two spec
 * @param spec
 * @param input
 */

function mergeSpec(spec, input) {
  return deepMerge(spec, input, {
    reducers: SPEC_REDUCERS,
    cleanUndefinedProps: true
  });
}

var JsonFormatTypes;

(function (JsonFormatTypes) {
  JsonFormatTypes["DATE_TIME"] = "date-time";
  JsonFormatTypes["DATE"] = "date";
  JsonFormatTypes["TIME"] = "time";
  JsonFormatTypes["EMAIL"] = "email";
  JsonFormatTypes["HOSTNAME"] = "hostname";
  JsonFormatTypes["IPV4"] = "ipv4";
  JsonFormatTypes["IPV6"] = "ipv6";
  JsonFormatTypes["URI"] = "uri";
  JsonFormatTypes["URL"] = "url";
  JsonFormatTypes["URI_REF"] = "uri-reference";
  JsonFormatTypes["URI_TEMPLATE"] = "uri-template";
  JsonFormatTypes["JSON_POINTER"] = "json-pointer";
  JsonFormatTypes["RELATIVE_JSON_POINTER"] = "relative-json-pointer";
  JsonFormatTypes["UUID"] = "uuid";
  JsonFormatTypes["REGEX"] = "regex";
})(JsonFormatTypes || (JsonFormatTypes = {}));

/**
 * Create a new model from the given type.
 *
 * ```typescript
 * from(String)
 * ```
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function from(type = Object) {
  if (isClass(type)) {
    const {
      schema
    } = getJsonEntityStore(type);

    schema.properties = function properties(obj) {
      Object.entries(obj).forEach(([propertyKey, propSchema]) => {
        getJsonEntityStore(type.prototype, propertyKey).schema.assign(propSchema);
      });
      return this;
    };

    return schema;
  }

  return JsonSchema.from({
    type
  });
}
/**
 * Declare a new number model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function number() {
  return from(Number);
}
/**
 * Declare a new integer model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function integer() {
  return from(Number).integer();
}
/**
 * Declare a new string model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function string() {
  return from(String);
}
/**
 * Declare a new boolean model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function boolean() {
  return from(Boolean);
}
/**
 * Declare a new string model with `format: date`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function date() {
  return from(Date).format(JsonFormatTypes.DATE);
}
/**
 * Declare a new string model with `format: datetime`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function datetime() {
  return from(Date).format(JsonFormatTypes.DATE_TIME);
}
/**
 * Declare a new string model with `format: time`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function time() {
  return from(Date).format(JsonFormatTypes.TIME);
}
/**
 * Declare a new string model with `format: email`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function email() {
  return from(String).format(JsonFormatTypes.EMAIL);
}
/**
 * Declare a new string model with `format: uri`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function uri() {
  return from(String).format(JsonFormatTypes.URI);
}
/**
 * Declare a new string model with `format: url`.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function url() {
  return from(String).format(JsonFormatTypes.URL);
}
/**
 * Declare a new object model with `additionalProperties: true`.
 *
 * ```json
 * {
 *   "type": "array"
 * }
 * ```
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function array() {
  return from(Array);
}
/**
 * Declare a new object model with `additionalProperties: true`.
 *
 * ```json
 * {
 *   "type": "object",
 *   "additionalProperties": true
 * }
 * ```
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function map() {
  return from(Map).unknown(true);
}
/**
 * Declare a new array model with `uniqueItems: true`.
 *
 * ```json
 * {
 *   "type": "array",
 *   "uniqueItems": true
 * }
 * ```
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function set() {
  return from(Array).uniqueItems(true);
}
/**
 * Declare a new object model.
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function object(properties = {}) {
  return from(Object).properties(properties);
}
/**
 * Declare a model with any type (By default: `integer`, `number`, `string`, `boolean`, `array`, `object`, `null`)
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 */

function any(...types) {
  return from().any(...types);
}
/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.27
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.27
 * @schemaFunctional
 */

function anyOf(...anyOf) {
  return from().anyOf(anyOf);
}
/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.28
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @schemaFunctional
 * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.28
 */

function oneOf(...oneOf) {
  return from().oneOf(oneOf);
}
/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.26
 *
 *  * See @@JsonSchema@@ to discover available methods.
 *
 * @see https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.26
 * @schemaFunctional
 */

function allOf(...allOf) {
  return from().allOf(allOf);
}
/**
 * Declare a sub schema which will be resolved later. Use this function when you have a circular reference between two schemes.
 *
 * @schemaFunctional
 */

function lazyRef(cb) {
  try {
    // solve issue with a self referenced model
    if (cb()) {
      // type is already accessible
      return JsonEntityStore.from(cb()).schema;
    }
  } catch (er) {}

  return new JsonLazyRef(cb);
}

const statusesModel = new Map();
function defineStatusModel(status, model) {
  statusesModel.set(status, model);
}
function getStatusModel(status) {
  return statusesModel.get(status);
}

/**
 * Set the type of the item collection. The possible value is String, Boolean, Number, Date, Object, Class, etc...
 *
 * ```typescript
 * class Model {
 *    @CollectionOf(String).MinLength(0).MaxLength(0)
 *    property: string[];
 * }
 * ```
 * ::: warning
 * You mustn't use the `type Type = string | number` as parameters Type.
 *
 * This example doesn't work:
 *
 * ```typescript
 * type Type = "string" | "number"
 * class Model {
 *    @CollectionOf(Type)
 *    property: Type[];
 * }
 * ```
 * :::
 *
 * @param {Type<any>} type
 * @param collectionType
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */

function CollectionOf(type, collectionType) {
  const schema = {};
  let contains = false;

  const decorator = (...args) => {
    const store = JsonEntityStore.from(...args); // const itemSchema = store.itemSchema.toJSON();

    if (collectionType) {
      store.collectionType = collectionType;
      store.schema.type(collectionType);
    }

    store.type = type; // console.log(type);

    store.itemSchema.type(type); // console.log(store.itemSchema.getComputedType(), schema);
    // store.itemSchema.assign({...itemSchema, type});

    store.schema.assign(schema);

    if (store.isArray && contains) {
      store.schema.set("contains", store.schema.get("items"));
      store.schema.delete("items");
    }
  };

  decorator.MinItems = minItems => {
    schema.minItems = minItems;
    return decorator;
  };

  decorator.MaxItems = maxItems => {
    schema.maxItems = maxItems;
    return decorator;
  };

  decorator.MinProperties = minProperties => {
    schema.minProperties = minProperties;
    return decorator;
  };

  decorator.MaxProperties = maxProperties => {
    schema.maxProperties = maxProperties;
    return decorator;
  };

  decorator.Contains = () => {
    contains = true;
    return decorator;
  };

  decorator.UniqueItems = (uniqueItems = true) => {
    schema.uniqueItems = uniqueItems;
    return decorator;
  };

  return decorator;
}
/**
 * Alias of @@GenericOf@@ decorator.
 * @param type
 * @decorator
 */

function ArrayOf(type) {
  return CollectionOf(type, Array);
}
/**
 * Alias of @@GenericOf@@ decorator.
 * @param type
 * @decorator
 */

function MapOf(type) {
  return CollectionOf(type, Map);
}

/**
 * Set the type of the item collection. The possible value is String, Boolean, Number, Date, Object, Class, etc...
 *
 * The array instance will be valid against "contains" if at least one of its elements is valid against the given schema.
 *
 * ```typescript
 * class Model {
 *    @CollectionContains(String).MinLength(0).MaxLength(0)
 *    property: string[];
 * }
 * ```
 *
 * @param {Type<any>} type
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */

function CollectionContains(type) {
  return CollectionOf(type).Contains();
}

/**
 * Decorator util to compose another decorator. See @@Description@@ decorator implementation for more details.
 *
 * ## Usage
 *
 * ```typescript
 * export function Description(description: any) {
 *   return JsonEntityFn((entity: JsonEntityStore, args: DecoratorParameters) => {
 *       entity.itemSchema.description(description)
 *   });
 * }
 * ```
 *
 * @param fn
 * @decorator
 * @utils
 * @model
 */

function JsonEntityFn(fn) {
  return (...parameters) => {
    const result = fn(getJsonEntityStore(...parameters), parameters);

    if (typeof result === "function") {
      result(...parameters);
    }
  };
}

/**
 * The value `maxItems` MUST be a non-negative integer.
 *
 * An array instance is valid against `maxItems` if its size is less than, or equal to, the value of this keyword.
 *
 * :: warning
 * The value `maxItems` MUST be a non-negative integer.
 * :::
 *
 * :: warning
 * This decorator will be removed in v7.
 * For v6 user, use @@MaxItems@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @CollectionOf(String)
 *    @MaxItems(10)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "maxItems": 10
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} maxItems
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */

function MaxItems(maxItems) {
  if (maxItems < 0) {
    throw new Error("The value of maxItems MUST be a non-negative integer.");
  }

  return JsonEntityFn(storedJson => {
    storedJson.schema.maxItems(maxItems);
  });
}

/**
 * An array instance is valid against `minItems` if its size is greater than, or equal to, the value of this keyword.
 *
 * ::: warning
 * The value `minItems` MUST be a non-negative integer.
 * :::
 *
 * ::: tip
 * Omitting this keyword has the same behavior as a value of 0.
 * :::
 *
 * ::: warning
 * For v6 user, use @@MinItems@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @CollectionOf(String)
 *    @MinItems(10)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "minItems": 10,
 *       "items": {
 *         "type": "string"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} minItems
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */

function MinItems(minItems) {
  if (minItems < 0) {
    throw new Error("The value of minItems MUST be a non-negative integer.");
  }

  return JsonEntityFn(storedJson => {
    storedJson.schema.minItems(minItems);
  });
}

/**
 * If this keyword has boolean value false, the instance validates successfully. If it has boolean value true, the instance validates successfully if all of its elements are unique.
 *
 * ::: warning
 * For v6 user, use @@UniqueItems@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @UniqueItems()  // default true
 *    property: number[];
 * }
 * ```
 *
 *  * ```typescript
 * class Model {
 *    @CollectionOf(String)
 *    @UniqueItems()
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "uniqueItems": true,
 *       "items": {
 *         "type": "string"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {boolean} uniqueItems
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */

function UniqueItems(uniqueItems = true) {
  return JsonEntityFn(store => {
    store.schema.uniqueItems(uniqueItems);
  });
}

/**
 * An object instance is valid against `maxProperties` if its number of properties is less than, or equal to, the value of this keyword.
 *
 * ::: warning
 * The value of this keyword MUST be a non-negative integer.
 * :::
 *
 * ::: warning
 * This decorator will be removed in v7.
 * For v6 user, use @@MaxProperties@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### On prop
 * ```typescript
 * class Model {
 *    @MaxProperties(10)
 *    property: any;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "any",
 *       "maxProperties": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### On class
 *
 * ```typescript
 * @MaxProperties(10)
 * class Model {
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "maxProperties": 10
 * }
 * ```
 *
 * ### On Parameter
 *
 * ```typescript
 *
 * class Model {
 *   method(@Any() @MaxProperties(10) obj: any){}
 * }
 * ```
 *
 * @param {number} maxProperties The maximum properties allowed on the given object
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */

function MaxProperties(maxProperties) {
  if (maxProperties < 0) {
    throw new Error("The value of maxProperties MUST be a non-negative integer.");
  }

  return JsonEntityFn(store => {
    store.isCollection ? store.schema.maxProperties(maxProperties) : store.itemSchema.maxProperties(maxProperties);
  });
}

/**
 * An object instance is valid against `minProperties` if its number of properties is less than, or equal to, the value of this keyword.
 *
 * ::: warning
 * The value of this keyword MUST be a non-negative integer.
 * :::
 *
 * ::: warning
 * For v6 user, use @@MinProperties@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### On prop
 * ```typescript
 * class Model {
 *    @MinProperties(10)
 *    property: any;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "any",
 *       "minProperties": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### On class
 *
 * ```typescript
 * @MinProperties(10)
 * class Model {
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "minProperties": 10
 * }
 * ```
 *
 * ### On Parameter
 *
 * ```typescript
 *
 * class Model {
 *   method(@Any() @MinProperties(10) obj: any){}
 * }
 * ```
 *
 * @param {number} minProperties The minimum properties allowed on the object.
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @collections
 */

function MinProperties(minProperties) {
  if (minProperties < 0) {
    throw new Error("The value of minProperties MUST be a non-negative integer.");
  }

  return JsonEntityFn(store => {
    store.isCollection ? store.schema.minProperties(minProperties) : store.itemSchema.minProperties(minProperties);
  });
}

/**
 * Define generics list. This list is used by @@GenericOf@@ and the @@getJsonSchema@@ function to build the correct JsonSchema.
 *
 * See @@GenericOf@@ decorator for more details.
 *
 * @param generics
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @generics
 */

function Generics(...generics) {
  return target => {
    const storedSchema = JsonEntityStore.from(target);
    storedSchema.schema.genericLabels = generics;
  };
}

/**
 * @ignore
 */

function isEnum$1(type) {
  return isObject(type) && !("toJSON" in type);
}
/**
 * Set the types of a Generic class.
 *
 * ## Example
 *
 * ```typescript
 * class Product {
 *   @Property()
 *   label: string;
 * }
 *
 * @Generics("T")
 * class Paginated<T> {
 *   @CollectionOf("T")
 *   data: T[];
 *
 *   @Property()
 *   totalCount: number;
 * }
 *
 * class Payload {
 *    @GenericOf(Product)
 *    products: Paginated<Product>;
 * }
 * ```
 *
 * ## Example with nested generics
 *
 * ```typescript
 * class Product {
 *   @Property()
 *   label: string;
 * }
 *
 * @Generics("T")
 * class Paginated<T> {
 *   @CollectionOf("T")
 *   data: T[];
 *
 *   @Property()
 *   totalCount: number;
 * }
 *
 * @Generics("D")
 * class Submission<D> {
 *   @Property()
 *   _id: string;
 *
 *   @Property("D")
 *   data: D;
 * }
 *
 * class Payload {
 *    @GenericOf(Submissions).Nested(Product)
 *    submissions: Paginated<Submission<Product>>;
 * }
 * ```
 *
 * @param {Type<any>[]} generics
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @generics
 */


function GenericOf(...generics) {
  const nestedGenerics = [generics.map(type => {
    if (isEnum$1(type)) {
      return string().enum(Object.values(type));
    }

    return type;
  })];

  const decorator = (...args) => {
    const store = JsonEntityStore.from(...args);
    store.nestedGenerics = nestedGenerics;
  };

  decorator.Nested = (...generics) => {
    nestedGenerics.push(generics);
    return decorator;
  };

  return decorator;
}

/**
 * Add deprecated metadata on the decorated element.
 *
 * ## Examples
 *
 * ```typescript
 *
 * @Deprecated()
 * class MyCtrl {
 *   @Deprecated()
 *   @Get("/")
 *   method(){
 *   }
 * }
 * ```
 *
 * @param deprecated
 * @decorator
 * @swagger
 * @schema
 * @operation
 */

function Deprecated(deprecated = true) {
  return JsonEntityFn((store, args) => {
    switch (store.decoratorType) {
      case DecoratorTypes.METHOD:
        store.operation.deprecated(deprecated);
        break;

      case DecoratorTypes.CLASS:
        decorateMethodsOf(args[0], Deprecated(deprecated));
        break;

      default:
        throw new UnsupportedDecoratorType(Deprecated, args);
    }
  });
}

/**
 * Add consumes metadata on the decorated element.
 *
 * ## Examples
 *
 * ```typescript
 * class Model {
 *    @Consumes("application/x-www-form-urlencoded")
 *    id: string;
 * }
 * ```
 *
 * @param consumes
 * @decorator
 * @swagger
 * @classDecorator
 * @operation
 */

function Consumes(...consumes) {
  return JsonEntityFn((store, args) => {
    switch (store.decoratorType) {
      case DecoratorTypes.METHOD:
        store.operation.consumes(consumes);
        break;

      case DecoratorTypes.CLASS:
        decorateMethodsOf(args[0], Consumes(...consumes));
        break;

      default:
        throw new UnsupportedDecoratorType(Consumes, args);
    }
  });
}

/**
 * @ignore
 */

class DecoratorContext extends Map {
  constructor() {
    super(...arguments);
    this.actions = [];
  }

  addAction(cb) {
    this.actions.push(cb);
    return this;
  }

  build() {
    const decorator = (...args) => this.onInit(args, decorator);

    const wrap = cb => {
      return (...args) => {
        cb(...args);
        return decorator;
      };
    };

    const wrapKey = key => {
      return wrap((...values) => {
        key in this ? this[key](...values) : this.set(key, values[0]);
      });
    };

    this.methods.forEach(name => {
      decorator[pascalCase(name)] = wrapKey(name);
    });
    return decorator;
  }

  toObject() {
    return [...this.entries()].reduce((obj, [key, value]) => {
      return _extends({}, obj, {
        [key]: value
      });
    }, {});
  }

  getMergedKey(key, defaultValue) {
    let value = this.get(key) || defaultValue;

    if (!value) {
      return;
    }

    if (this.decoratorType === DecoratorTypes.CLASS) {
      value = _extends({}, value, defaultValue || {});
    }

    return _extends({}, defaultValue || {}, value);
  }

  runActions() {
    this.actions.forEach(action => {
      action(this);
    });
    return this;
  }

}

/**
 * @ignore
 */

function isEnum(type) {
  return isObject(type) && !("toJSON" in type);
}

function mapGenerics(types) {
  return types.map(type => {
    if (isEnum(type)) {
      return string().enum(Object.values(type));
    }

    return type;
  });
}
/**
 * @ignore
 */


class ReturnDecoratorContext extends DecoratorContext {
  constructor({
    status,
    model
  }) {
    super();
    this.methods = ["contentType", "description", "examples", "type", "status", "of", "nested", "header", "headers", "schema", "title", "groups"];
    this.set("status", status);
    this.set("model", model);

    if (status && HTTP_STATUS_MESSAGES[status]) {
      this.set("description", HTTP_STATUS_MESSAGES[status]);

      if (!model) {
        this.model(getStatusModel(+status));
      }
    }
  }

  type(model) {
    return this.model(model);
  }

  model(model) {
    this.set("model", model);
    return this;
  }

  status(status) {
    this.set("status", status);
    return this;
  }

  headers(headers) {
    this.set("headers", _extends({}, this.get("headers") || {}, mapHeaders(headers)));
    return this;
  }

  header(key, value) {
    return this.headers({
      [key]: value
    });
  }

  groups(...groups) {
    this.set("groups", groups);
    return this;
  }

  nested(...generics) {
    const model = this.get("model");
    this.checkPrimitive(model);
    this.checkCollection(model);
    this.addAction(ctx => {
      this.get("schema").nestedGenerics.push(mapGenerics(generics));
    });
    return this;
  }

  of(...types) {
    const model = this.get("model");
    this.checkPrimitive(model);
    this.addAction(() => {
      const schema = this.get("schema");

      if (isCollection(model)) {
        schema == null ? void 0 : schema.itemSchema({
          type: types[0]
        });
      } else {
        schema == null ? void 0 : schema.nestedGenerics.push(mapGenerics(types));
      }
    });
    return this;
  }

  schema(partial) {
    this.addAction(() => {
      const schema = this.get("schema");
      schema.assign(partial);
    });
    return this;
  }

  examples(examples) {
    this.set("examples", isString(examples) ? [examples] : examples);
    return this;
  }

  title(title) {
    return this.schema({
      title
    });
  }

  checkPrimitive(model) {
    if (isPrimitiveOrPrimitiveClass(model)) {
      throw new Error("Returns.Of cannot be used with the following primitive classes: String, Number, Boolean");
    }
  }

  checkCollection(model) {
    if (isCollection(model)) {
      throw new Error("Returns.Nested cannot be used with the following classes: Map, Set, Array, String, Number, Boolean");
    }
  }

  getContentType() {
    const model = this.get("model");
    let contentType = this.get("contentType");

    if (model && !isPlainObject(model) && !isPrimitiveOrPrimitiveClass(model)) {
      contentType = contentType || "application/json";
    }

    return contentType;
  }

  getStatus() {
    return this.get("status") || "default";
  }

  onInit(args, decorator) {
    const type = decoratorTypeOf(args);

    switch (type) {
      case DecoratorTypes.METHOD:
        this.store = JsonEntityStore.from(...args);

        if (this.store.operation) {
          this.map();
        }

        break;

      case DecoratorTypes.CLASS:
        this.decoratorType = DecoratorTypes.CLASS;
        decorateMethodsOf(args[0], decorator);
        break;

      default:
        throw new UnsupportedDecoratorType(Returns, args);
    }
  }

  map() {
    const model = this.get("model");
    const {
      store,
      decoratorType
    } = this;
    const operation = this.store.operation;
    const currentStatus = this.getStatus();
    const response = operation.ensureResponseOf(currentStatus);
    const contentType = this.getContentType();
    let {
      description = response.get("description")
    } = this.toObject();

    if (description) {
      description = decoratorType === DecoratorTypes.CLASS ? response.get("description") || description : description;
      response.description(description);
    }

    const headers = this.getMergedKey("headers", response.get("headers"));

    if (headers) {
      response.headers(headers);
    }

    this.mapMedia(response);

    if (isSuccessStatus(this.get("status")) || currentStatus === "default") {
      if (model) {
        store.type = model;
      }
    } // additional info for OS2


    contentType && operation.addProduce(contentType); // run additional actions

    return this.runActions();
  }

  mapMedia(response) {
    const contentType = this.getContentType();
    const model = this.get("model");
    const media = response.getMedia(contentType || "*/*");
    const schema = media.get("schema") || new JsonSchema({
      type: model
    });
    model && schema.type(model);
    this.set("schema", schema);
    media.schema(schema);
    media.groups = this.get("groups");
    const examples = this.get("examples");

    if (examples) {
      media.examples(examples);
    }

    return media;
  }

}

function Returns(status, model) {
  const context = new ReturnDecoratorContext({
    status,
    model
  });
  return context.build();
}

/**
 * Sets the Content-Type HTTP header to the MIME type as determined by mime.lookup() for the specified type.
 * If type contains the / character, then it sets the `Content-Type` to type.
 *
 * ```typescript
 *  @ContentType('.html');              // => 'text/html'
 *  @ContentType('html');               // => 'text/html'
 *  @ContentType('json');               // => 'application/json'
 *  @ContentType('application/json');   // => 'application/json'
 *  @ContentType('png');                // => image/png
 *  private myMethod() {}
 * ```
 *
 * @param type
 * @decorator
 * @operation
 * @response
 * @headers
 */

function ContentType(type) {
  return Returns().ContentType(type);
}

/**
 * Add a input parameter.
 *
 * ::: warning
 * Don't use decorator with Ts.ED application to decorate parameters. Use @@BodyParams@@, @@PathParams@@, etc... instead.
 * But you can use this decorator on Method, to add extra in parameters like Authorization header.
 *
 * ```typescript
 * @Controller("/")
 * class MyController {
 *    @Get("/")
 *    @In("header").Type(String).Name("Authorization").Required()
 *    method() {
 *    }
 *  }
 * ```
 * :::
 *
 * @param inType
 * @decorator
 * @swagger
 * @schema
 * @input
 * @operation
 */

function In(inType) {
  const jsonParameter = new JsonParameter();
  const schema = {};

  const decorator = (target, propertyKey, index) => {
    const store = JsonEntityStore.from(target, propertyKey, index);

    switch (store.decoratorType) {
      case DecoratorTypes.PARAM:
        store.parameter.in(inType);
        break;

      case DecoratorTypes.METHOD:
        jsonParameter.in(inType);
        store.operation.addParameter(-1, jsonParameter);
        jsonParameter.schema(JsonSchema.from(schema));
        break;

      case DecoratorTypes.CLASS:
        decorateMethodsOf(target, decorator);
        break;

      default:
        throw new UnsupportedDecoratorType(In, [target, propertyKey, index]);
    }
  };

  decorator.Type = type => {
    schema.type = type;
    return decorator;
  };

  decorator.Name = name => {
    jsonParameter.name(name);
    return decorator;
  };

  decorator.Description = description => {
    jsonParameter.description(description);
    return decorator;
  };

  decorator.Required = (required = true) => {
    jsonParameter.required(required);
    return decorator;
  };

  decorator.Pattern = pattern => {
    return decorator.Schema({
      pattern: pattern.toString()
    });
  };

  decorator.Schema = _schema => {
    Object.assign(schema, _schema);
    return decorator;
  };

  return decorator;
}

/**
 * Set a swagger operationId explicitly.
 *
 * @param operationId
 * @decorator
 * @swagger
 * @schema
 * @operation
 */

function OperationId(operationId) {
  return JsonEntityFn((store, args) => {
    if (store.decoratorType !== DecoratorTypes.METHOD) {
      throw new UnsupportedDecoratorType(OperationId, args);
    }

    store.operation.operationId(operationId);
  });
}

var OperationMethods;

(function (OperationMethods) {
  OperationMethods["ALL"] = "ALL";
  OperationMethods["GET"] = "GET";
  OperationMethods["POST"] = "POST";
  OperationMethods["PUT"] = "PUT";
  OperationMethods["PATCH"] = "PATCH";
  OperationMethods["HEAD"] = "HEAD";
  OperationMethods["DELETE"] = "DELETE";
  OperationMethods["OPTIONS"] = "OPTIONS";
  OperationMethods["CUSTOM"] = "CUSTOM";
})(OperationMethods || (OperationMethods = {}));
/**
 * Declare new Operation with his path and http method.
 *
 * ::: warning
 * Don't use decorator with Ts.ED application.
 *
 * Use theses decorators instead:
 *
 * <ApiList query="status.includes('decorator') && status.includes('httpMethod')" />
 *
 * :::
 *
 * @param method
 * @param path
 * @decorator
 * @swagger
 * @schema
 * @operation
 */


function OperationPath(method, path = "/") {
  return JsonEntityFn((store, args) => {
    if (store.decoratorType !== DecoratorTypes.METHOD) {
      throw new UnsupportedDecoratorType(OperationPath, args);
    }

    store.operation.addOperationPath(method.toUpperCase(), path);
  });
}

/**
 * Set class path to expose all endpoints
 *
 * ::: warning
 * Don't use this decorator to change the path if you develop your application with Ts.ED.
 * :::
 *
 * @param path
 * @decorator
 * @swagger
 * @schema
 * @classDecorator
 * @operation
 */

function Path(path) {
  return JsonEntityFn((store, args) => {
    if (store.decoratorType !== DecoratorTypes.CLASS) {
      throw new UnsupportedDecoratorType(Path, args);
    }

    store.path = path;
  });
}

/**
 * Add produces metadata on the decorated element.
 *
 * ## Examples
 * ### On method
 *
 * ```typescript
 * class Model {
 *    @Produces("text/html")
 *    id: string;
 * }
 * ```
 *
 * ::: warning
 * For openspec v3 prefer `@Returns().ContentType()` usage (see @@Returns@@).
 * :::
 *
 * @param produces
 * @decorator
 * @swagger
 * @methodDecorator
 * @classDecorator
 * @operation
 * @response
 */

function Produces(...produces) {
  return JsonEntityFn((store, args) => {
    switch (store.decoratorType) {
      case DecoratorTypes.METHOD:
        store.operation.produces(produces);
        break;

      case DecoratorTypes.CLASS:
        decorateMethodsOf(args[0], Produces(...produces));
        break;

      default:
        throw new UnsupportedDecoratorType(Produces, args);
    }
  });
}

/**
 * Add responses documentation for a specific status code.
 *
 * ## Usage
 *
 * Ts.ED v6 API introducing the chaining decorator concept.
 * Now a decorator like Returns can be used with another decorators like Description.
 *
 * ```typescript
 * import {Returns} from "@tsed/schema";
 *
 * @Controller("/")
 * class MyController {
 *   @Status(404, String).Description("Not Found")
 *   @Status(200, Model).Description("Success")
 *   async myMethod(): Promise<Model> {}
 * }
 * ```
 *
 * ::: tip
 * TypeScript and your IDE will discover automatically the chained decorators. But for more details you can look on @@ReturnsChainedDecorators@@ interface, to know
 * what chained decorators are available under Returns decorator.
 * :::
 *
 * This example will produce this documentation in swagger:
 *
 * ```json
 * {
 *   "responses": {
 *     "404": {
 *       "description": "Description",
 *       "schema": {"type": "string"}
 *     },
 *     "2OO": {
 *       "description": "Description",
 *       "schema": {"$ref": "..."}
 *     }
 *   }
 * }
 * ```
 *
 * ### Declaring a generic model
 *
 * Sometime, it might be useful to use generic models. TypeScript doesn't store the generic type in the metadata. This is why we need to
 * declare explicitly the generic models with the decorators.
 *
 * One of the generic's usage, can be a paginated list. With Returns decorator it's now possible to declare generic type and generate the appropriate OpenSpec documentation.
 *
 * Starting with the pagination model, by using @@Generics@@ and @@CollectionOf@@:
 *
 * ```typescript
 * @Generics("T")
 * class Pagination<T> {
 *  @CollectionOf("T")
 *  data: T[];
 *
 *  @Property()
 *  totalCount: number;
 * }
 * ```
 *
 * Now, we need a model to be used with the generic Pagination model:
 *
 * ```typescript
 * class Product {
 *  @Property()
 *  id: string;
 *
 *  @Property()
 *  title: string;
 * }
 * ```
 *
 * Finally, we can use our models on a method as following:
 *
 * ```typescript
 * class Controller {
 *   @OperationPath("POST", "/")
 *   @Status(200, Pagination).Of(Product).Description("description")
 *   async method(): Promise<Pagination<Product> | null> {
 *     return null;
 *   }
 * }
 * ```
 *
 * ### Declaring a nested generics models <Badge text="6+"/>
 *
 * It's also possible to declare a nested generics models in order to have this type `Pagination<Submission<Product>>`:
 *
 * ```typescript
 * import {Generics, Property, Returns} from "@tsed/schema";
 * import {Post} from "@tsed/common";
 *
 * class Controller {
 *   @Post("/")
 *   @Status(200, Pagination).Of(Submission).Nested(Product).Description("description")
 *   async method(): Promise<Pagination<Submission<Product>> | null> {
 *     return null;
 *   }
 * }
 * ```
 *
 * And here is the Submission model:
 *
 * ```typescript
 * import {Generics, Property} from "@tsed/schema";
 *
 * @Generics("T")
 * class Submission<T> {
 *   @Property()
 *   _id: string;
 *   @Property("T")
 *   data: T;
 * }
 * ```
 *
 * @param status
 * @param model
 * @decorator
 * @swagger
 * @schema
 * @response
 * @operation
 */

function Status(status, model) {
  return Returns(status, model);
}

/**
 * Sets the responses HTTP header field to value. To set multiple fields at once, pass an object as the parameter.
 *
 * ```typescript
 * @Header('Content-Type', 'text/plain');
 * private myMethod() {}
 *
 * @Status(204)
 * @Header({
 *   "Content-Type": "text/plain",
 *   "Content-Length": 123,
 *   "ETag": {
 *     "value": "12345",
 *     "description": "header description"
 *   }
 * })
 * private myMethod() {}
 * ```
 *
 * This example will produce the swagger responses object:
 *
 * ```json
 * {
 *   "responses": {
 *     "204": {
 *       "description": "Description",
 *       "headers": {
 *          "Content-Type": {
 *             "type": "string"
 *          },
 *          "Content-Length": {
 *             "type": "number"
 *          },
 *          "ETag": {
 *             "type": "string",
 *             "description": "header description"
 *          }
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @decorator
 * @operation
 * @response
 */

function Header(headers, value) {
  if (value !== undefined) {
    headers = {
      [headers]: value
    };
  }

  return Returns().Headers(headers);
}

/**
 * Add security metadata on the decorated method.
 *
 * ## Examples
 * ### On method
 *
 * ```typescript
 * @Controller("/")
 * class ModelCtrl {
 *    @Security("write:calendars")
 *    async method() {}
 * }
 * ```
 *
 * @param name
 * @param scopes
 * @decorator
 * @swagger
 * @schema
 * @classDecorator
 * @operation
 */

function Security(name, ...scopes) {
  return JsonEntityFn((store, args) => {
    switch (store.decoratorType) {
      case DecoratorTypes.METHOD:
        store.operation.addSecurityScopes(name, scopes);
        break;

      case DecoratorTypes.CLASS:
        decorateMethodsOf(args[0], Security(name, ...scopes));
        break;

      default:
        throw new UnsupportedDecoratorType(Security, args);
    }
  });
}

function mapTags(tags) {
  return tags.map(tag => {
    if (typeof tag === "string") {
      return {
        name: tag
      };
    }

    return tag;
  });
}
/**
 * Add tags metadata on the decorated element.
 *
 * ## Examples
 * ### On method
 *
 * ```typescript
 * @Controller("/")
 * class MyController {
 *  @Tags("api")
 *  get() {}
 * }
 * ```
 *
 * @param tags
 * @decorator
 * @swagger
 * @schema
 * @classDecorator
 * @operation
 */


function Tags(...tags) {
  return JsonEntityFn((store, args) => {
    switch (store.decoratorType) {
      case DecoratorTypes.METHOD:
        store.operation.addTags(mapTags(tags));
        break;

      case DecoratorTypes.CLASS:
        decorateMethodsOf(args[0], Tags(...tags));
        break;

      default:
        throw new UnsupportedDecoratorType(Tags, args);
    }
  });
}

/**
 * Add summary metadata on the decorated element.
 *
 * ## Examples
 * ### On method
 *
 * ```typescript
 * class Model {
 *    @Summary("summary")
 *    id: string;
 * }
 * ```
 *
 * @param summary
 * @decorator
 * @swagger
 * @schema
 * @operation
 */

function Summary(summary) {
  return JsonEntityFn((store, args) => {
    if (store.decoratorType !== DecoratorTypes.METHOD) {
      throw new UnsupportedDecoratorType(Summary, args);
    }

    store.operation.summary(summary);
  });
}

/**
 * @ignore
 */

function matchGroups(groups, compareWith = []) {
  const groupsExcludes = groups.filter(group => group.startsWith("!")).map(group => group.replace("!", ""));
  const groupsIncludes = groups.filter(group => !group.startsWith("!"));

  if (groupsExcludes.length) {
    if (compareWith.length && micromatch(groupsExcludes, compareWith).length) {
      return true;
    }
  }

  if (groupsIncludes.length) {
    return !micromatch(groups.filter(group => !group.startsWith("!")), compareWith).length;
  }

  return false;
}

function Groups(...groups) {
  return JsonEntityFn(entity => {
    switch (entity.decoratorType) {
      case DecoratorTypes.CLASS:
        const entries = Object.entries(groups[0]);
        entity.children.forEach(propEntity => {
          const groups = entries.filter(([, props]) => props.includes(propEntity.propertyName)).map(([key]) => key);
          const decorator = Groups(...groups);
          decorator(propEntity.target, propEntity.propertyKey);
        });
        break;

      case DecoratorTypes.PROP:
        entity.schema.$hooks.on("groups", (prev, givenGroups) => {
          if (!prev) {
            if (matchGroups(groups, givenGroups)) {
              return true;
            }
          }

          return prev;
        });
        break;

      case DecoratorTypes.PARAM:
        entity.parameter.groups = groups;
        break;
    }
  });
}

/**
 * Apply Partial group strategy on the input model
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Partial() {
  return Groups("partial");
}

/**
 * Accept unknown properties on the deserialized model.
 *
 * @param schema
 * @decorator
 * @validation
 * @swagger
 * @schema
 */

function AdditionalProperties(schema) {
  return JsonEntityFn((entity, parameters) => {
    entity.itemSchema.additionalProperties(schema);
  });
}

/**
 * Declare a new property on a model.
 *
 * @param type
 * @decorator
 * @validation
 * @swagger
 * @schema
 */

function Property(type) {
  return JsonEntityFn(store => {
    if (type) {
      if (isClass(type)) {
        store.type = type;
      }

      store.itemSchema.type(type);
    }
  });
}

/**
 * Add allowed values when the property or parameters is required.
 *
 * #### Example on parameter:
 *
 * ```typescript
 * @Post("/")
 * async method(@Allow("") @BodyParams("field") field: string) {}
 * ```
 * > Required will throw a BadRequest when the given value is `null` or `undefined` but not for an empty string.
 *
 * #### Example on model:
 *
 * ```typescript
 * class Model {
 *   @Allow("")
 *   field: string;
 * }
 * ```
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Allow(...values) {
  const model = values.find(item => isClass(item));
  return useDecorators(model && Property(model), JsonEntityFn((store, args) => {
    store.schema.allow(...values);

    switch (store.decoratorType) {
      case DecoratorTypes.PARAM:
        store.parameter.required(true);
        break;

      case DecoratorTypes.PROP:
        store.parentSchema.addRequired(store.propertyName);
        break;

      default:
        throw new UnsupportedDecoratorType(Allow, args);
    }
  }));
}

/**
 * Set the type of the array items.
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @Any()
 *    property: any;
 *
 *    @Any(String, Number, Boolean)
 *    property: string | number | boolean;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": ["integer", "number", "string", "boolean", "array", "object", "null"]
 *     }
 *   }
 * }
 * ```
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Any(...types) {
  return JsonEntityFn(store => {
    store.itemSchema.any(...types);
  });
}

/**
 * Set integer type.
 *
 * ::: warning
 * For v6 user, use @@Integer@@ from @tsed/schema instead of @@Integer@@ from @tsed/common.
 * :::
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @Integer()
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "integer"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array of multiple types
 *
 * ```typescript
 * class Model {
 *    @Integer()
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "integer"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Integer() {
  return JsonEntityFn(store => {
    store.itemSchema.type("integer");
  });
}

/**
 * The const keyword is used to restrict a value to a fixed value.
 *
 * ::: warning
 * For v6 user, use @@Const@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With a string
 *
 * ```typescript
 * class Model {
 *    @Const("value1")
 *    property: "value1";
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "const": "value1"
 *     }
 *   }
 * }
 * ```
 *  * ### With a boolean
 *
 * ```typescript
 * class Model {
 *    @Const(true)
 *    property: boolean;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "boolean",
 *       "const": true
 *     }
 *   }
 * }
 * ```
 *
 * @param {string | number | boolean } constValue
 * @decorator
 * @validation
 * @swagger
 * @schema
 */

function Const(constValue) {
  return JsonEntityFn(store => {
    store.itemSchema.const(constValue);
  });
}

/**
 * There are no restrictions placed on the value of this keyword.
 *
 * ::: warning
 * For v6 user, use @@Default@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * This keyword can be used to supply a default JSON value associated with a particular schema.
 * It is RECOMMENDED that a default value be valid against the associated schema.
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @Default("10")
 *    property: string = "10";
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "default": "10"
 *     }
 *   }
 * }
 * ```
 *
 * @param {string | number | boolean | {}} defaultValue
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Default(defaultValue) {
  return JsonEntityFn(store => {
    store.itemSchema.default(defaultValue);
  });
}

/**
 * Add a description to the class, method or property
 *
 * ## Examples
 * ### On class
 *
 * ```typescript
 * @Description("description")
 * class Model {
 *
 * }
 * ```
 *
 * ### On method
 *
 * ```typescript
 * @Controller("/")
 * class ModelCtrl {
 *    @Description("description")
 *    async method() {}
 * }
 * ```
 *
 * ### On parameter
 *
 * ```typescript
 * @Controller("/")
 * class ModelCtrl {
 *    async method(@Description("description") @PathParam("id") id: string) {}
 * }
 * ```
 *
 * ### On property
 *
 * ```typescript
 * class Model {
 *    @Description("description")
 *    id: string;
 * }
 * ```
 *
 * @param {string} description
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @classDecorator
 * @methodDecorator
 * @propertyDecorator
 * @parameterDecorator
 */

function Description(description) {
  return JsonEntityFn((store, args) => {
    var _store$parameter, _store$operation;

    switch (decoratorTypeOf(args)) {
      case DecoratorTypes.PROP:
      case DecoratorTypes.CLASS:
        store.schema.description(description);
        break;

      case DecoratorTypes.PARAM:
        (_store$parameter = store.parameter) == null ? void 0 : _store$parameter.description(description);
        break;

      case DecoratorTypes.METHOD:
        (_store$operation = store.operation) == null ? void 0 : _store$operation.description(description);
        break;

      default:
        throw new UnsupportedDecoratorType(Description, args);
    }
  });
}

/**
 * Add a example metadata on the decorated element.
 *
 * @decorator
 * @swagger
 * @schema
 * @input
 * @methodDecorator
 * @classDecorator
 */

function Example(...examples) {
  return JsonEntityFn((store, args) => {
    switch (decoratorTypeOf(args)) {
      case DecoratorTypes.CLASS:
      case DecoratorTypes.PROP:
      case DecoratorTypes.PARAM:
      case DecoratorTypes.METHOD:
        store.schema.examples(examples);
        break;

      default:
        throw new UnsupportedDecoratorType(Example, args);
    }
  });
}

const transformTsEnum = enumValue => {
  return Object.keys(enumValue).reduce((acc, key) => {
    if (isNaN(+key)) {
      const value = enumValue[key];
      return acc.concat(value);
    }

    return acc;
  }, []);
};

function Enum(enumValue, ...enumValues) {
  return JsonEntityFn(store => {
    const values = [enumValue].concat(enumValues).reduce((acc, value) => {
      if (isObject(value) && value !== null) {
        value = transformTsEnum(value);
      }

      return acc.concat(value);
    }, []);
    const types = values.reduce((set, value) => {
      return set.add(value === null ? "null" : typeof value);
    }, new Set());
    store.itemSchema.enum(values).any(...types);
  });
}

/**
 * The value of `maximum` MUST be a number, representing an inclusive upper limit for a numeric instance.
 *
 * If the instance is a number, then this keyword validates only if the instance is less than or exactly equal to `maximum`.
 *
 * ::: warning
 * For v6 user, use @@Maximum@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Maximum(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "maximum": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Maximum(10)
 *    @CollectionOf(Number)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "maximum": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} maximum The maximum value allowed
 * @param {boolean} exclusive Same effect as ExclusiveMaximum decorator.
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Maximum(maximum, exclusive = false) {
  return JsonEntityFn(store => {
    exclusive ? store.itemSchema.exclusiveMaximum(maximum) : store.itemSchema.maximum(maximum);
  });
}
/**
 * The value of `maximum` MUST be a number, representing an inclusive upper limit for a numeric instance.
 *
 * If the instance is a number, then this keyword validates only if the instance is less than or exactly equal to `maximum`.
 *
 * ::: warning
 * For v6 user, use @@Maximum@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Max(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "maximum": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Max(10)
 *    @CollectionOf(Number)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "maximum": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} maximum The maximum value allowed
 * @param {boolean} exclusive Same effect as ExclusiveMaximum decorator.
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Max(maximum, exclusive = false) {
  return Maximum(maximum, exclusive);
}

/**
 * The value of `exclusiveMaximum` MUST be number, representing an exclusive upper limit for a numeric instance.
 *
 * If the instance is a number, then the instance is valid only if it has a value strictly less than (not equal to) `exclusiveMaximum`.
 *
 * ::: warning
 * For v6 user, use @@ExclusiveMaximum@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @ExclusiveMaximum(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "exclusiveMaximum": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @ExclusiveMaximum(10)
 *    @CollectionOf(Number)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "exclusiveMaximum": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param maximum
 * @param {boolean} exclusiveMaximum
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function ExclusiveMaximum(maximum, exclusiveMaximum = true) {
  return Maximum(maximum, exclusiveMaximum);
}

/**
 * The value of `minimum` MUST be a number, representing an inclusive upper limit for a numeric instance.
 *
 * If the instance is a number, then this keyword validates only if the instance is greater than or exactly equal to `minimum`.
 *
 * ::: warning
 * This decorator will be removed in v7.
 * For v6 user, use @@Minimum@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Minimum(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "minimum": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Minimum(10)
 *    @CollectionOf(Number)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "minimum": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} minimum The minimum value allowed
 * @param {boolean} exclusive
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Minimum(minimum, exclusive = false) {
  return JsonEntityFn(store => {
    exclusive ? store.itemSchema.exclusiveMinimum(minimum) : store.itemSchema.minimum(minimum);
  });
}
/**
 * The value of `minimum` MUST be a number, representing an inclusive upper limit for a numeric instance.
 *
 * If the instance is a number, then this keyword validates only if the instance is greater than or exactly equal to `minimum`.
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Min(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "minimum": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Min(10)
 *    @CollectionOf(Number)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "minimum": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @alias Minimum
 * @param minimum The minimum value allowed
 * @param exclusive
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Min(minimum, exclusive = false) {
  return Minimum(minimum, exclusive);
}

/**
 * The value of `exclusiveMinimum` MUST be number, representing an exclusive upper limit for a numeric instance.
 *
 * If the instance is a number, then the instance is valid only if it has a value strictly greater than (not equal to) `exclusiveMinimum`.
 *
 * ::: warning
 * For v6 user, use @@ExclusiveMinimum@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @ExclusiveMinimum(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "exclusiveMinimum": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @ExclusiveMinimum(10)
 *    @CollectionOf(Number)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "exclusiveMinimum": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param minimum
 * @param {boolean} exclusiveMinimum
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function ExclusiveMinimum(minimum, exclusiveMinimum = true) {
  return Minimum(minimum, exclusiveMinimum);
}

/**
 * The following formats are supported for string validation with `format` keyword:
 *
 * - **date**: full-date according to [RFC3339](https://json-schema.org/latest/json-schema-validation.html#RFC3339).
 * - **time**: time with optional time-zone.
 * - **date-time**: date-time from the same source (time-zone is mandatory).
 * - **uri**: full uri with optional protocol.
 * - **email**: email address.
 * - **hostname**: host name according to [RFC1034](https://tools.ietf.org/html/rfc1034#section-3.1).
 * - **ipv4**: IP address v4.
 * - **ipv6**: IP address v6.
 * - **regex**: tests whether a string is a valid regular expression by passing it to RegExp constructor.
 *
 * ::: warning
 * For v6 user, use @@Format@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Format("email")
 *    property: string;
 * }
 * ```
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "email"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Format("email")
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "email"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {string} format
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Format(format) {
  return JsonEntityFn(store => {
    store.itemSchema.format(format);
  });
}
/**
 * Apply an email validation on property.
 *
 * ::: warning
 * For v6 user, use @@Email@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Email()
 *    property: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "email"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Email()
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "email"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * > See [Format](api/common/jsonschema/schema) decorator.
 * @returns {Function}
 * @decorator
 * @validation
 * @schema
 * @swagger
 * @input
 */

function Email() {
  return Format(JsonFormatTypes.EMAIL);
}
/**
 * Apply a date-time validation on property.
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @DateTime()
 *    property: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "date-time"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @DateTime()
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "date-time"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * > See [Format](api/common/jsonschema/schema) decorator.
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 * @auto-map The data will be stored on the right place according to the type and collectionType (primitive or collection).
 */

function DateTime() {
  return Format(JsonFormatTypes.DATE_TIME);
}
/**
 * Apply a time validation on property.
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Time()
 *    property: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "time"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Time()
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "time"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * > See [Format](api/common/jsonschema/schema) decorator.
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */

function DateFormat() {
  return Format(JsonFormatTypes.DATE);
}
/**
 * Apply a time validation on property.
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @TimeFormat()
 *    property: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "time"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @TimeFormat()
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "time"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * > See [Format](api/common/jsonschema/schema) decorator.
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */

function TimeFormat() {
  return Format(JsonFormatTypes.TIME);
}
/**
 * Apply a uri validation on property.
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Uri()
 *    property: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "uri"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Uri()
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "uri"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * > See [Format](api/common/jsonschema/schema) decorator.
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */

function Uri() {
  return Format(JsonFormatTypes.URI);
}
/**
 * Apply a url validation on property.
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Url()
 *    property: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "format": "url"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @Url()
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "format": "url"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * > See [Format](api/common/jsonschema/schema) decorator.
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */

function Url() {
  return Format(JsonFormatTypes.URL);
}

/**
 * Allow to forward group on specific property.
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function ForwardGroups(bool = true) {
  return JsonEntityFn(entity => {
    entity.schema.$forwardGroups = bool;
  });
}

/**
 * The pattern and Pattern Properties keywords use regular expressions to express constraints.
 * The regular expression syntax used is from JavaScript (ECMA 262, specifically). However, that complete syntax is not widely supported, therefore it is recommended that you stick to the subset of that syntax described below.
 *
 * ::: warning
 * For v6 user, use @@Pattern@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * A single unicode character (other than the special characters below) matches itself.
 *
 * * `^`: Matches only at the beginning of the string.
 * * `$`: Matches only at the end of the string.
 * * `(...)`: Group a series of regular expressions into a single regular expression.
 * * `|`: Matches either the regular expression preceding or following the | symbol.
 * * `[abc]`: Matches any of the characters inside the square brackets.
 * * `[a-z]`: Matches the range of characters.
 * * `[^abc]`: Matches any character not listed.
 * * `[^a-z]`: Matches any character outside of the range.
 * * `+`: Matches one or more repetitions of the preceding regular expression.
 * * `*`: Matches zero or more repetitions of the preceding regular expression.
 * * `?`: Matches zero or one repetitions of the preceding regular expression.
 * * `+?`, *?`, ??`: The `*`, `+`, and `?` qualifiers are all greedy; they match as much text as possible. Sometimes this behavior isnt desired and you want to match as few characters as possible.
 * * `{x}`: Match exactly x occurrences of the preceding regular expression.
 * * `{x,y}`: Match at least x and at most y occurrences of the preceding regular expression.
 * * `{x,}`: Match x occurrences or more of the preceding regular expression.
 * * `{x}?`, {x,y}?, {x,}?`: Lazy versions of the above expressions.
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @Pattern("^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$")
 *    @Pattern(/^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$/)
 *    property: string;
 * }
 * ```
 *
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @Pattern(/^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$/)
 *    property: string;
 * }
 * ```
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "pattern": "^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$"
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @CollectionOf(string)
 *    @Pattern(/^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$/)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *         "type": "string",
 *         "pattern": "^(\\([0-9]{3}\\))?[0-9]{3}-[0-9]{4}$"
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {string} pattern
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Pattern(pattern) {
  return JsonEntityFn(store => {
    store.itemSchema.pattern(pattern);
  });
}

/**
 * @ignore
 */

const defaultCB = (value, ctx) => ctx.mongoose !== true;
/**
 * Ignore the property when JsonMapper serialize the class to a Plain Object JavaScript.
 *
 * ::: warning
 * Swagger will not generate documentation for the ignored property.
 * :::
 *
 * ```typescript
 * class User {
 *   @Ignore()
 *   _id: string;
 *
 *   @Property()
 *   firstName: string;
 *
 *   @Property()
 *   lastName: string;
 *
 *   @Ignore((value, ctx) => !ctx.mongoose) // don't ignore prop only if mongoose
 *   password: string;
 * }
 * ```
 *
 * The controller:
 * ```typescript
 * import {Post, Controller, BodyParams} from "@tsed/common";
 * import {Person} from "../models/Person";
 *
 * @Controller("/")
 * export class UsersCtrl {
 *   @Get("/")
 *   get(): User {
 *     const user = new User();
 *     user._id = "12345";
 *     user.firstName = "John";
 *     user.lastName = "Doe";
 *     user.password = "secretpassword";
 *     return
 *   }
 * }
 * ```
 *
 * The expected json object:
 *
 * ```json
 * {
 *  "firstName": "John",
 *  "lastName": "Doe"
 * }
 * ```
 * @param cb Callback to know if the property must be ignored
 * @decorator
 * @validation
 * @swagger
 * @schema
 */


function Ignore(cb = defaultCB) {
  return JsonEntityFn(store => {
    store.schema.ignore(cb);
  });
}

/**
 * A string instance is valid against this keyword if its length is greater than, or equal to, the value of this keyword.
 *
 * The length of a string instance is defined as the number of its characters as defined by [RFC 7159](http://json-schema.org/latest/json-schema-validation.html#RFC7159).
 *
 * ::: warning
 * The value of maxLength MUST be a non-negative integer.
 * :::
 *
 * ::: tip
 * Omitting this keyword has the same behavior as a value of 0.
 * :::
 *
 * ::: warning
 * For v6 user, use @@MaxLength@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @MaxLength(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "maxLength": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @MaxLength(10)
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "maxLength": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} maxLength The maximum length allowed
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function MaxLength(maxLength) {
  if (maxLength < 0) {
    throw new Error("The value of maxLength MUST be a non-negative integer.");
  }

  return JsonEntityFn(store => {
    store.itemSchema.maxLength(maxLength);
  });
}

/**
 *
 * A string instance is valid against this keyword if its length is greater than, or equal to, the value of this keyword.
 *
 * The length of a string instance is defined as the number of its characters as defined by [RFC 7159](http://json-schema.org/latest/json-schema-validation.html#RFC7159).
 *
 * ::: warning
 * The value of minLength MUST be a non-negative integer.
 * :::
 *
 * ::: tip
 * Omitting this keyword has the same behavior as a value of 0.
 * :::
 *
 * ::: warning
 * For v6 user, use @@MinLength@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @MinLength(10)
 *    property: number;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "string",
 *       "maxLength": 10
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @MinLength(10)
 *    @CollectionOf(String)
 *    property: string[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "string",
 *          "minLength": 10
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} minLength
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function MinLength(minLength) {
  if (minLength < 0) {
    throw new Error("The value of minLength MUST be a non-negative integer.");
  }

  return JsonEntityFn(store => {
    store.itemSchema.minLength(minLength);
  });
}

/**
 * A numeric instance is valid only if division by this keyword's value results in an integer.
 *
 * ::: warning
 * The value of `multipleOf` MUST be a number, strictly greater than 0.
 * :::
 *
 * ::: warning
 * For v6 user, use @@MultipleOf@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 * ### With primitive type
 *
 * ```typescript
 * class Model {
 *    @MultipleOf(2)
 *    property: Number;
 * }
 * ```
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "number",
 *       "multipleOf": 2
 *     }
 *   }
 * }
 * ```
 *
 * ### With array type
 *
 * ```typescript
 * class Model {
 *    @CollectionOf(number)
 *    @MultipleOf(2)
 *    property: number[];
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "property": {
 *       "type": "array",
 *       "items": {
 *          "type": "number",
 *          "multipleOf": 2
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * @param {number} multipleOf The multiple value allowed
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function MultipleOf(multipleOf) {
  if (multipleOf <= 0) {
    throw new Error("The value of multipleOf MUST be a number, strictly greater than 0.");
  }

  return JsonEntityFn(store => {
    store.itemSchema.multipleOf(multipleOf);
  });
}

/**
 * Add a name metadata on the decorated element.
 *
 * ## Examples
 * ### On parameters
 *
 * ```typescript
 * async myMethod(@Name("nameOf") @PathParams("id") id: string): Promise<Model>  {
 *
 * }
 * ```
 *
 * ### On parameters
 *
 * ```typescript
 * @Name("AliasName")
 * @Controller("/")
 * class ModelCtrl {
 *
 * }
 * ```
 *
 * @param name
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 * @classDecorator
 * @operation
 */

function Name(name) {
  return JsonEntityFn((store, args) => {
    switch (decoratorTypeOf(args)) {
      case DecoratorTypes.CLASS:
        store.schema.name(name);
        break;

      case DecoratorTypes.PARAM:
        store.parameter.name(name);
        break;

      default:
        store.parent.schema.addAlias(args[1], name);
    }
  });
}

/**
 * Add optional annotation on Property or Parameter.
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Optional() {
  return JsonEntityFn((store, args) => {
    switch (store.decoratorType) {
      case DecoratorTypes.PARAM:
        store.parameter.required(false);
        break;

      case DecoratorTypes.PROP:
        store.parentSchema.removeRequired(store.propertyName);
        break;

      default:
        throw new UnsupportedDecoratorType(Optional, args);
    }
  });
}

/**
 * Add required annotation on Property or Parameter.
 *
 * The @@Required@@ decorator can be used on two cases.
 *
 * To decorate a parameters:
 *
 * ```typescript
 * @Post("/")
 * async method(@Required() @BodyParams("field") field: string) {}
 * ```
 *
 * To decorate a model:
 *
 * ```typescript
 * class Model {
 *   @Required()
 *   field: string;
 * }
 * ```
 *
 * ::: tip
 * Required will throw a BadRequest when the given value is `null`, an empty string or `undefined`.
 * :::
 *
 * ### Allow values
 *
 * In some case, you didn't want trigger a BadRequest when the value is an empty string for example.
 * The decorator `@Allow()`, allow you to configure a value list for which there will be no exception.
 *
 * ```typescript
 * class Model {
 *   @Allow("") // add automatically required flag
 *   field: string;
 * }
 * ```
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Required(required = true, ...allowedRequiredValues) {
  return required ? Allow(...allowedRequiredValues) : Optional();
}

/**
 * Apply groups validation strategy for required property.
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function RequiredGroups(...groups) {
  return JsonEntityFn(entity => {
    if (entity.decoratorType === DecoratorTypes.PROP) {
      entity.parent.schema.$hooks.on("requiredGroups", (required, givenGroups) => {
        if (matchGroups(groups, givenGroups)) {
          return required.filter(key => key !== entity.propertyKey);
        }

        return required;
      });
    }
  });
}

/**
 * Disable documentation for the class and his endpoint.
 *
 * ````typescript
 * @Controller('/')
 * export class Ctrl {
 *
 *   @Get('/')
 *   @Hidden()
 *   hiddenRoute(){
 *
 *   }
 * }
 *
 * @Controller('/')
 * @Hidden()
 * export class Ctrl {
 *   @Get('/')
 *   hiddenRoute() {
 *
 *   }
 *   @Get('/2')
 *   hiddenRoute2() {
 *
 *   }
 * }
 * ```
 *
 * @decorator
 * @ignore
 */

function Hidden() {
  return StoreSet("hidden", true);
}

/**
 * Add title metadata on the decorated element.
 *
 * ::: warning
 * For v6 user, use @@Title@@ from @tsed/schema instead of @tsed/common.
 * :::
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @Title("title")
 *    id: string;
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "properties": {
 *     "id": {
 *        "type": "string",
 *        "title": "title"
 *     }
 *   }
 * }
 * ```
 *
 * @param {string} title
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @classDecorator
 * @input
 */

function Title(title) {
  return JsonEntityFn(entity => {
    entity.schema.title(title);
  });
}

/**
 * Write data formatted to JsonSchema.
 *
 * ## Example
 *
 * ```typescript
 * @Schema({title: "test"})
 * class Model {
 *    @Schema({formatMinimum: "1987-10-24"})
 *    @Format("date")
 *    birthDate: Date
 * }
 * ```
 *
 * Will produce:
 *
 * ```json
 * {
 *   "type": "object",
 *   "title": "test",
 *   "properties": {
 *     "birthdate": {
 *        "type": "string",
 *        "format": "date",
 *        "formatMinimum": "1987-10-24"
 *     }
 *   }
 * }
 * ```
 *
 * @param partialSchema
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @classDecorator
 * @input
 */

function Schema(partialSchema) {
  return JsonEntityFn(entity => {
    Object.entries(partialSchema).forEach(([key, value]) => {
      entity.schema.set(key, value);
    });
  });
}
/**
 * Apply specific schema depending on the spec version
 * @param specType
 * @param schema
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @classDecorator
 * @input
 */

function For(specType, schema) {
  return JsonEntityFn(entity => {
    entity.schema.set(specType, schema);
  });
}

/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.28
 *
 * ::: warning
 * OneOf isn't supported by OS2
 * :::
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @classDecorator
 * @input
 * @param oneOf
 */

function OneOf(...oneOf) {
  return JsonEntityFn(entity => {
    entity.itemSchema.oneOf(oneOf);
  });
}

/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.26
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @classDecorator
 * @input
 * @param allOf
 */

function AllOf(...allOf) {
  return JsonEntityFn(entity => {
    entity.itemSchema.allOf(allOf);
  });
}

/**
 * See https://tools.ietf.org/html/draft-wright-json-schema-validation-01#section-6.27
 *
 * ::: warning
 * AnyOf isn't supported by OS2
 * :::
 *
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @classDecorator
 * @input
 * @param anyOf
 */

function AnyOf(...anyOf) {
  return JsonEntityFn(entity => {
    entity.itemSchema.anyOf(anyOf);
  });
}

/**
 * Set the property as WriteOnly.
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */

function WriteOnly(writeOnly = true) {
  return JsonEntityFn(store => {
    store.itemSchema.writeOnly(writeOnly);
  });
}

/**
 * Set the property as readOnly.
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */

function ReadOnly(readOnly = true) {
  return JsonEntityFn(store => {
    store.itemSchema.readOnly(readOnly);
  });
}

/**
 * Set a custom key on JsonSchema that is not a part of the official spec.
 *
 * This custom key can only be displayed if the @@getJsonSchema@@ is called with `{customKeys: true}`.
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */

function CustomKey(key, value) {
  return JsonEntityFn(store => {
    store.itemSchema.customKey(key, value);
  });
}
/**
 * Set a group of custom keys on JsonSchema that is not a part of the official spec.
 *
 * This custom key can only be displayed if the @@getJsonSchema@@ is called with `{customKeys: true}`.
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @property
 * @parameter
 * @schema
 */

function CustomKeys(obj) {
  return JsonEntityFn(store => {
    Object.entries(obj).forEach(([key, value]) => {
      store.itemSchema.customKey(key, value);
    });
  });
}

/**
 * Set field as nullable.
 *
 * ## Example
 *
 * ```typescript
 * class Model {
 *    @Nullable(Date)
 *    property: Date | null;
 *
 *    @Nullable(String, Number, Boolean)
 *    property: string | number | boolean | null;
 * }
 * ```
 *
 * @returns {Function}
 * @decorator
 * @validation
 * @swagger
 * @schema
 * @input
 */

function Nullable(type, ...types) {
  types = [type, ...types];
  return useDecorators(types.length === 1 && Property(types[0]), Any(null, ...types));
}

/**
 * Declare a new JsonEntityStore class for a specific decorator type.
 *
 * @ignore
 * @param type
 * @decorator
 */

function JsonEntityComponent(type) {
  return target => {
    JsonEntitiesContainer.set(type, target);
  };
}

export { AdditionalProperties, AllOf, Allow, Any, AnyOf, ArrayOf, CollectionContains, CollectionOf, Const, Consumes, ContentType, CustomKey, CustomKeys, DateFormat, DateTime, Default, Deprecated, Description, Email, Enum, Example, ExclusiveMaximum, ExclusiveMinimum, For, Format, ForwardGroups, GenericOf, Generics, Groups, HTTP_STATUS_MESSAGES, Header, Hidden, Ignore, In, Integer, JSON_TYPES, JsonEntityComponent, JsonEntityFn, JsonEntityStore, JsonFormatTypes, JsonLazyRef, JsonMap, JsonMedia, JsonOperation, JsonParameter, JsonParameterTypes, JsonRequestBody, JsonResponse, JsonSchema, MapOf, Max, MaxItems, MaxLength, MaxProperties, Maximum, Min, MinItems, MinLength, MinProperties, Minimum, MultipleOf, Name, Nullable, OneOf, OperationId, OperationMethods, OperationPath, Optional, Partial, Path, Pattern, Produces, Property, ReadOnly, Required, RequiredGroups, Returns, Schema, Security, SpecTypes, Status, Summary, Tags, TimeFormat, Title, UniqueItems, Uri, Url, WriteOnly, allOf, alterIgnore, any, anyOf, array, boolean, date, datetime, defineStatusModel, email, formatParameterType, from, getGenericsMap, getJsonSchema, getJsonType, getOperationsStores, getProperties, getPropertiesStores, getSpec, getStatusConstant, getStatusModel, integer, isParameterType, isSuccessStatus, lazyRef, map, mapGenericsOptions, mapHeaders, mergeSpec, number, object, oneOf, parameters, popGenerics, schemesReducer, security, set, string, tagsReducer, time, uri, url };
//# sourceMappingURL=index.modern.js.map
